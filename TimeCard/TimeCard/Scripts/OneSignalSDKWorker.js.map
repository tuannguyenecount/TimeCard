{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/tslib/tslib.es6.js","webpack:///./build/ts-to-es6/src/libraries/Log.js","webpack:///./build/ts-to-es6/src/errors/TimeoutError.js","webpack:///./build/ts-to-es6/src/context/shared/utils/Utils.js","webpack:///./build/ts-to-es6/src/libraries/Emitter.js","webpack:///./build/ts-to-es6/src/services/IndexedDb.js","webpack:///./build/ts-to-es6/src/models/AppState.js","webpack:///./build/ts-to-es6/src/models/ServiceWorkerState.js","webpack:///./build/ts-to-es6/src/models/Subscription.js","webpack:///./build/ts-to-es6/src/models/EmailProfile.js","webpack:///./build/ts-to-es6/src/services/Database.js","webpack:///./build/ts-to-es6/src/libraries/sw/Log.js","webpack:///./build/ts-to-es6/src/models/WindowEnvironmentKind.js","webpack:///./build/ts-to-es6/src/models/EnvironmentKind.js","webpack:///./build/ts-to-es6/src/managers/SdkEnvironment.js","webpack:///./build/ts-to-es6/src/libraries/WorkerMessenger.js","webpack:///./build/ts-to-es6/src/utils/OneSignalUtils.js","webpack:///./build/ts-to-es6/src/helpers/shared/OutcomesHelper.js","webpack:///./build/ts-to-es6/src/helpers/ServiceWorkerHelper.js","webpack:///./build/ts-to-es6/src/Environment.js","webpack:///./build/ts-to-es6/src/config/index.js","webpack:///./build/ts-to-es6/src/utils.js","webpack:///./node_modules/bowser/src/bowser.js","webpack:///./build/ts-to-es6/src/models/SubscriptionStateKind.js","webpack:///./build/ts-to-es6/src/models/NotificationPermission.js","webpack:///./build/ts-to-es6/src/errors/OneSignalError.js","webpack:///./build/ts-to-es6/src/models/PermissionPromptType.js","webpack:///./build/ts-to-es6/src/errors/InvalidStateError.js","webpack:///./build/ts-to-es6/src/errors/InvalidArgumentError.js","webpack:///./build/ts-to-es6/src/models/IntegrationKind.js","webpack:///./build/ts-to-es6/src/models/Session.js","webpack:///./build/ts-to-es6/src/OneSignalApiBase.js","webpack:///./build/ts-to-es6/src/errors/PushPermissionNotGrantedError.js","webpack:///./build/ts-to-es6/src/Event.js","webpack:///./build/ts-to-es6/src/models/RawPushSubscription.js","webpack:///./build/ts-to-es6/src/errors/NotImplementedError.js","webpack:///./build/ts-to-es6/src/models/EmailDeviceRecord.js","webpack:///./build/ts-to-es6/src/OneSignalApiShared.js","webpack:///./build/ts-to-es6/src/errors/SdkInitError.js","webpack:///./build/ts-to-es6/src/models/Outcomes.js","webpack:///./build/ts-to-es6/src/errors/OneSignalApiError.js","webpack:///./build/ts-to-es6/src/utils/LocalStorage.js","webpack:///./build/ts-to-es6/src/utils/PermissionUtils.js","webpack:///./build/ts-to-es6/src/models/PushDeviceRecord.js","webpack:///./build/ts-to-es6/src/OneSignalApiSW.js","webpack:///./build/ts-to-es6/src/models/DeliveryPlatformKind.js","webpack:///./build/ts-to-es6/src/models/DeviceRecord.js","webpack:///./build/ts-to-es6/src/helpers/sw/CancelableTimeout.js","webpack:///./build/ts-to-es6/src/models/TestEnvironmentKind.js","webpack:///./build/ts-to-es6/src/managers/PageViewManager.js","webpack:///./build/ts-to-es6/src/models/Path.js","webpack:///./build/ts-to-es6/src/errors/ServiceWorkerRegistrationError.js","webpack:///./build/ts-to-es6/src/managers/ServiceWorkerManager.js","webpack:///./build/ts-to-es6/src/errors/SubscriptionError.js","webpack:///./build/ts-to-es6/src/managers/SubscriptionManager.js","webpack:///./build/ts-to-es6/src/utils/Encoding.js","webpack:///./build/ts-to-es6/src/helpers/ContextHelper.js","webpack:///./build/ts-to-es6/src/errors/NotSubscribedError.js","webpack:///./build/ts-to-es6/src/managers/UpdateManager.js","webpack:///./build/ts-to-es6/src/managers/sessionManager/sw/SessionManager.js","webpack:///./build/ts-to-es6/src/models/ContextSW.js","webpack:///./build/ts-to-es6/src/managers/PermissionManager.js","webpack:///./build/ts-to-es6/src/utils/BrowserUtils.js","webpack:///./build/ts-to-es6/src/modules/TimedLocalStorage.js","webpack:///./build/ts-to-es6/src/LimitStore.js","webpack:///./build/ts-to-es6/src/CustomLink.js","webpack:///./build/ts-to-es6/src/helpers/PromptsHelper.js","webpack:///./build/ts-to-es6/src/helpers/EventHelper.js","webpack:///./build/ts-to-es6/src/context/browser/models/Browser.js","webpack:///./build/ts-to-es6/src/helpers/SubscriptionHelper.js","webpack:///./build/ts-to-es6/src/helpers/MainHelper.js","webpack:///./build/ts-to-es6/src/helpers/page/ServiceWorkerHelper.js","webpack:///./build/ts-to-es6/src/models/AppConfig.js","webpack:///./build/ts-to-es6/src/helpers/ConfigHelper.js","webpack:///./build/ts-to-es6/src/utils/TagUtils.js","webpack:///(webpack)/buildin/global.js","webpack:///./build/ts-to-es6/src/service-worker/ServiceWorker.js","webpack:///(webpack)/buildin/amd-define.js","webpack:///./build/ts-to-es6/src/entries/worker.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","setPrototypeOf","Array","assign","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Log","[object Object]","window","localStorage","level","getItem","toLowerCase","setItem","proxyMethodsCreated","undefined","createProxyMethods","methods","log","trace","info","warn","error","nativeMethod","keys","nativeMethodExists","console","methodToMapTo","shouldMap","shouldLog","bind","TimeoutError_TimeoutError","OneSignalError","message","super","this","Utils_Utils","indexOfAble","match","indexOf","style","text","charAt","toUpperCase","slice","defaultValue","obj","JSON","stringify","_","hash","uriComponent","key","encodeURIComponent","promise","milliseconds","timeoutPromise","setTimeout","race","str","targetLength","padString","length","version","osVersionParts","toString","split","majorVersion","padStart","minorVersion","Number","subject","delimiter","maxParts","parts","skipParts","Math","max","join","toCheck","compareTo","parseVersionString","appId","Error","playerId","funcToExecute","enforceAppId","enforcePlayerId","isArray","errors","contains","OneSignalApiError","MissingAppId","arrayToSort","predicateForProperty","descending","doItInPlace","internalArrayToSort","sort","a","b","propertyA","propertyB","__webpack_exports__","Emitter_Emitter","_events","event","listener","push","that","fn","off","arguments","on","listeners","j","splice","removeAllListeners","args","shift","len","IndexedDb_DATABASE_VERSION","IndexedDb_IndexedDb","databaseName","emitter","request","indexedDB","open","onerror","onDatabaseOpenError","onblocked","onDatabaseOpenBlocked","onupgradeneeded","onDatabaseUpgradeNeeded","onsuccess","database","onDatabaseError","onversionchange","onDatabaseVersionChange","openLock","preventDefault","target","Utils","debug","errorCode","db","oldVersion","createObjectStore","keyPath","OneSignal","_isNewVisitor","table","ensureDatabaseOpen","transaction","objectStore","jsonResult","cursor","openCursor","cursorResult","cursorResultKey","continue","tslib_es6","put","store","delete","clear","AppState","ServiceWorkerState","Subscription","deviceId","subscriptionToken","optedOut","createdAt","expirationTime","bundle","subscription","EmailProfile","emailId","emailAddress","emailAuthHash","Database_DatabaseEventName","DatabaseEventName","Database_Database","databaseInstance","singletonInstance","databaseInstanceName","id","data","timestamp","SdkEnvironment","getWindowEnv","WindowEnvironmentKind","ServiceWorker","OneSignalUtils","isUsingSubscriptionWorkaround","getTestEnv","TestEnvironmentKind","None","shouldUsePostmam","proxyFrameHost","POSTMAM_COMMANDS","REMOTE_DATABASE_GET","reply","applyDbResultFilter","REMOTE_DATABASE_GET_ALL","getAll","keypath","REMOTE_DATABASE_PUT","REMOTE_OPERATION_COMPLETE","emit","EVENTS","SET","REMOTE_DATABASE_REMOVE","remove","config","appIdStr","subdomain","vapidPublicKey","emailAuthRequired","externalUserId","externalIdToSave","getValueOrDefault","type","appConfig","httpUseOneSignalCom","state","defaultNotificationUrl","defaultNotificationTitle","lastKnownPushEnabled","clickedNotifications","appState","clickedNotificationUrls","url","notificationDetails","workerVersion","updaterWorkerVersion","dbOptedOut","dbNotOptedOut","setDeviceId","profileJson","deserialize","emailProfile","serialize","consent","sessionKey","session","allClickedNotifications","find","notification","URL","origin","notificationId","promises","map","sentDuringSession","all","getSession","Session","setSession","removeSession","setEmailProfile","getEmailProfile","setSubscription","getSubscription","setProvideUserConsent","getProvideUserConsent","workerState","setServiceWorkerState","getServiceWorkerState","setAppState","getAppState","setAppConfig","getAppConfig","getExternalUserId","getLastNotificationClicked","removeNotificationClickedById","removeAllNotificationClicked","resetSentUniqueOutcomes","getNotificationClickedByUrl","getNotificationClickedById","getNotificationReceivedById","setExternalUserId","self","EnvironmentKind","SdkEnvironment_RESOURCE_HTTP_PORT","SdkEnvironment_API_URL_PORT","SdkEnvironment_TURBINE_API_URL_PORT","SdkEnvironment_TURBINE_ENDPOINTS","SdkEnvironment_SdkEnvironment","Production","usingProxyOrigin","Environment","isSafari","IntegrationKind","Secure","isTopFrame","top","isHttpsProtocol","location","protocol","context","InvalidArgumentError","Empty","SecureProxy","isLocalhostAllowedAsSecureOrigin","hostname","InsecureProxy","isFrameContextInsecure","navigator","serviceWorker","getRegistration","ServiceWorkerHelper","isBrowser","ServiceWorkerGlobalScope","registration","scope","Unknown","href","pathname","search","endsWith","getBuildEnv","Development","OneSignalSubscriptionPopup","Host","OneSignalProxyFrame","OneSignalSubscriptionModal","CustomIframe","buildEnv","Staging","EnumOutOfRange","getApiEnv","action","isTurbineEndpoint","port","some","turbine_endpoint","WorkerMessengerCommand","WorkerMessengerReplyBuffer","replies","command","callback","onceListenerOnly","record","targetRecord","listenersForCommand","listenerRecordIndex","WorkerMessenger","payload","_managers_SdkEnvironment__WEBPACK_IMPORTED_MODULE_2__","_models_WindowEnvironmentKind__WEBPACK_IMPORTED_MODULE_4__","clients","matchAll","includeUncontrolled","client","_Log__WEBPACK_IMPORTED_MODULE_6__","postMessage","windowClient","_errors_InvalidArgumentError__WEBPACK_IMPORTED_MODULE_1__","isWorkerControllingPage","waitUntilWorkerControlsPage","directPostMessageToSW","controller","listenIfPageUncontrolled","_Environment__WEBPACK_IMPORTED_MODULE_5__","supportsServiceWorkers","addEventListener","onWorkerMessageReceivedFromPage","listenForPage","onPageMessageReceivedFromServiceWorker","listenerRecords","findListenersForMessage","listenersToRemove","listenersToCall","listenerRecord","deleteListenerRecord","addListener","deleteListenerRecords","deleteAllListenerRecords","active","serviceWorkerManager","getActiveState","_helpers_ServiceWorkerHelper__WEBPACK_IMPORTED_MODULE_3__","WorkerA","WorkerB","tslib__WEBPACK_IMPORTED_MODULE_0__","_e","userConfig","allowLocalhostAsSecureOrigin","windowEnv","_managers_SdkEnvironment__WEBPACK_IMPORTED_MODULE_1__","bowser__WEBPACK_IMPORTED_MODULE_0___default","safari","internalIsUsingSubscriptionWorkaround","_models_WindowEnvironmentKind__WEBPACK_IMPORTED_MODULE_3__","_detect","userAgent","uuid","test","uuidStr","crypto","global","msCrypto","replace","getRandomValues","Uint8Array","random","methodName","_libraries_Log__WEBPACK_IMPORTED_MODULE_4__","_context_shared_utils_Utils__WEBPACK_IMPORTED_MODULE_5__","getConsoleStyle","_Environment__WEBPACK_IMPORTED_MODULE_2__","OutcomesHelper_SEND_OUTCOME","OutcomesHelper_SEND_UNIQUE_OUTCOME","OutcomesHelper_OutcomesHelper","outcomeName","isUnique","getAttribution","outcomeMethodString","utils","privateIsPushNotificationsEnabled","libraries_Log","Database","filter","reduce","acc","curr","notificationIds","previouslyAttributedArr","getAttributedNotifsByUniqueOutcomeName","outcomeAttribution","notifArr","Outcomes","Unattributed","newNotificationIds","existingSentOutcome","currentSession","getCurrentSession","startTimestamp","sentOutcome","sessionExistsAndWasPreviouslySent","sessionWasClearedButWasPreviouslySent","outcomeProps","weight","Direct","saveSentUniqueOutcome","updateManager","sendOutcomeDirect","Indirect","sendOutcomeInfluenced","wasSentDuringSession","sendOutcomeUnattributed","direct","enabled","indirect","timeframeMs","influencedTimePeriodMin","maxTimestamp","Date","getTime","allReceivedNotification","influencedNotificationsLimit","allReceivedNotificationSorted","sortArrayOfObjects","notif","matchingNotificationIds","notificationIdsToDelete","forEach","unattributed","NotSupported","ServiceWorkerHelper_ServiceWorkerActiveState","ServiceWorkerActiveState","ServiceWorkerHelper_ServiceWorkerHelper","page_ServiceWorkerHelper","workerFullPath","workerBPath","getFullPath","ThirdParty","workerAPath","Bypassed","InvalidStateError","UnsupportedEnvironment","getBaseUrl","sessionThresholdInSeconds","sendOnFocusEnabled","deviceRecord","sessionOrigin","outcomesConfig","app_id","existingSession","deviceType","device_type","clickedNotification","upsertSession","sendOnSessionCallIfNecessary","status","Active","lastDeactivatedTimestamp","currentTimestamp","timeInSecondsBetweenTimestamps","lastActivatedTimestamp","finalizeSession","thresholdInSeconds","Inactive","CancelableTimeout","timeSinceLastActivatedInSeconds","accumulatedDuration","cancelableFinalize","PlayerCreate","identifier","pushManager","rawPushSubscription","RawPushSubscription","setFromW3cSubscription","fullDeviceRecord","PushDeviceRecord","newPlayerId","OneSignalApiSW","updateUserSession","attribution","sendSessionDuration","cleanupCurrentSession","timestamp1","timestamp2","floor","bowser__WEBPACK_IMPORTED_MODULE_2___default","TRADITIONAL_CHINESE_LANGUAGE_TAG","SIMPLIFIED_CHINESE_LANGUAGE_TAG","languageTag","language","languageSubtags","traditionalSubtag","simpleSubtag","substring","_managers_SdkEnvironment__WEBPACK_IMPORTED_MODULE_0__","_models_WindowEnvironmentKind__WEBPACK_IMPORTED_MODULE_1__","__SRC_STYLESHEETS_MD5_HASH__","SERVER_CONFIG_DEFAULTS_SESSION","reportingThreshold","enableOnSessionForUnsubcribed","enableOnFocus","SERVER_CONFIG_DEFAULTS_PROMPT_DELAYS","pageViews","timeDelay","SERVER_CONFIG_DEFAULTS_SLIDEDOWN","actionMessage","acceptButton","cancelButton","categoryDefaults","updateMessage","positiveUpdateButton","negativeUpdateButton","savingText","awaitOneSignalInitAndSupported","initialized","once","SDK_INITIALIZED","logMethodCall","_utils_OneSignalUtils__WEBPACK_IMPORTED_MODULE_5__","addCssClass","targetSelectorOrElement","cssClass","element","document","querySelector","classList","add","removeCssClass","hasCssClass","deepCopy","parse","definition","t","detect","ua","getFirstMatch","regex","iosdevice","android","nexusMobile","nexusTablet","chromeos","silk","sailfish","tizen","webos","windowsphone","windows","mac","linux","edgeVersion","versionIdentifier","tablet","mobile","xbox","opera","samsungBrowser","coast","yandexbrowser","ucbrowser","maxthon","epiphany","puffin","sleipnir","kMeleon","msedge","msie","chromeBook","chrome","vivaldi","seamonkey","firefox","firefoxos","phantom","slimer","blackberry","touchpad","bada","qupzilla","chromium","googlebot","blink","webkit","gecko","ios","osVersion","getWindowsVersion","osversion","osMajorVersion","x","bowser","getVersionPrecision","arr","iterator","compareVersions","versions","precision","chunks","delta","chunk","reverse","isUnsupportedBrowser","minVersions","strictMode","_bowser","browser","String","browserList","browserItem","check","SubscriptionStateKind","NotificationPermission","writable","constructor","captureStackTrace","stack","PermissionPromptType","InvalidStateError_InvalidStateReason","InvalidStateReason","InvalidStateError_InvalidStateError","reason","extra","RedundantPermissionMessage","extraInfo","permissionPromptType","PushPermissionAlreadyGranted","ServiceWorkerNotActivated","NoProxyFrame","description","InvalidArgumentReason","_OneSignalError__WEBPACK_IMPORTED_MODULE_0__","argName","Malformed","argument","SessionStatus","SessionOrigin","ONESIGNAL_SESSION_KEY","initializeNewSession","options","OneSignalApiBase","headers","method","_errors_OneSignalApiError__WEBPACK_IMPORTED_MODULE_3__","callHeaders","Headers","append","getOrigin","_Environment__WEBPACK_IMPORTED_MODULE_0__","contents","cache","body","fetch","getOneSignalApiUrl","response","json","identifyError","catch","err","_context_shared_utils_Utils__WEBPACK_IMPORTED_MODULE_2__","PushPermissionNotGrantedErrorReason","PushPermissionNotGrantedError","Dismissed","Blocked","Default","SILENT_EVENTS","RETRIGGER_REMOTE_EVENTS","LEGACY_EVENT_MAP","notificationPermissionChange","subscriptionChange","customPromptClick","Event","eventName","remoteTriggerEnv","displayData","env","capitalize","_Environment__WEBPACK_IMPORTED_MODULE_1__","legacyEventName","_triggerLegacy","opener","parent","subscriptionPopup","REMOTE_RETRIGGER_EVENT","eventData","proxyFrame","retriggerRemoteEvent","CustomEvent","bubbles","cancelable","detail","dispatchEvent","existingW3cPushSubscription","w3cEndpoint","w3cP256dh","w3cAuth","existingSafariDeviceToken","safariDeviceToken","pushSubscription","endpoint","getKey","p256dh","auth","p256dh_base64encoded","btoa","fromCharCode","auth_base64encoded","existingPushSubscription","NotImplementedError","EmailDeviceRecord_EmailDeviceRecord","DeviceRecord","email","pushDeviceRecordId","deliveryPlatform","DeliveryPlatformKind","Email","serializedBundle","email_auth_hash","device_player_id","OneSignalApiShared_OneSignalApiShared","playerIds","titles","icon","buttons","params","include_player_ids","isAnyWeb","web_buttons","headings","chrome_web_icon","firefox_icon","trimUndefined","post","serializedDeviceRecord","success","emailRecord","parent_player_id","userId","SdkInitErrorKind","SdkInitError","InvalidAppId","AppNotConfiguredForWebPush","MissingSubdomain","WrongSiteUrl","siteUrl","MultipleInitialization","MissingSafariWebId","OutcomeAttributionType","OneSignalApiErrorKind","IS_OPTED_OUT","IS_PUSH_NOTIFICATIONS_ENABLED","PAGE_VIEWS","LocalStorage","_managers_PermissionManager__WEBPACK_IMPORTED_MODULE_1__","STORED_PERMISSION_KEY","_models_NotificationPermission__WEBPACK_IMPORTED_MODULE_0__","Granted","Denied","count","PermissionUtils","updateIfIdentical","newPermission","privateGetNotificationPermission","_services_Database__WEBPACK_IMPORTED_MODULE_1__","_Event__WEBPACK_IMPORTED_MODULE_2__","trigger","NATIVE_PROMPT_PERMISSIONCHANGED","to","_DeviceRecord__WEBPACK_IMPORTED_MODULE_3__","web_auth","web_p256","subscriptionState","pushRegistration","_SubscriptionStateKind__WEBPACK_IMPORTED_MODULE_2__","Subscribed","NotSubscribed","_errors_NotImplementedError__WEBPACK_IMPORTED_MODULE_1__","_context_shared_utils_Utils__WEBPACK_IMPORTED_MODULE_4__","_reject","_OneSignalApiBase__WEBPACK_IMPORTED_MODULE_1__","notification_types","_models_SubscriptionStateKind__WEBPACK_IMPORTED_MODULE_2__","TemporaryWebRecord","_libraries_Log__WEBPACK_IMPORTED_MODULE_3__","enforceAppIdAndPlayerId","sessionDuration","active_time","_models_Outcomes__WEBPACK_IMPORTED_MODULE_5__","notification_ids","getLanguage","timezone","getTimezoneOffset","browserVersion","parseInt","isNaN","deviceModel","platform","sdkVersion","getDeliveryPlatform","pushNotification","_utils_OneSignalUtils__WEBPACK_IMPORTED_MODULE_4__","redetectBrowserUserAgent","_DeliveryPlatformKind__WEBPACK_IMPORTED_MODULE_3__","Safari","Firefox","Edge","ChromeLike","device_os","device_model","sdk","_errors_NotImplementedError__WEBPACK_IMPORTED_MODULE_2__","doNothing","_libraries_sw_Log__WEBPACK_IMPORTED_MODULE_1__","cancelableTimeout","delayInSeconds","delayInMilliseconds","timerId","clearTimeoutHandle","startedExecution","clearTimeout","cancel","PageViewManager_PageViewManager","incrementedPageViewCount","pageViewCountStr","sessionStorage","SESSION_STORAGE_KEY_NAME","pageViewCount","sessionCount","SET_SESSION_COUNT","newCountSingleTab","getPageViewCount","newCountAcrossTabs","getLocalPageViewCount","setPageViewCount","setLocalPageViewCount","Path_Path","path","trim","indexOfDelimiter","QUERY_STRING","getWithoutQueryString","pop","newPath","fileNameIndex","lastIndexOf","getFileName","pathWithoutFileName","ServiceWorkerRegistrationError_ServiceWorkerRegistrationError","statusText","errors_ServiceWorkerRegistrationError","ServiceWorkerManager_ServiceWorkerManager","integration","getIntegration","Indeterminate","runCommand","SERVICE_WORKER_STATE","workerRegistration","installing","Installing","swFileName","activeSwFileName","swActiveStateByFileName","workerScriptPath","scriptURL","importedSw","URLSearchParams","fileName","proxyWorkerVersion","GET_WORKER_VERSION","NaN","workerMessenger","WorkerVersion","unicast","environmentInfo","browserType","permissionManager","getNotificationPermission","safariWebId","workerNeedsUpdate","getWorkerVersion","shouldInstallWorker","preInstallWorkerState","installAlternatingWorker","postInstallWorkerState","establishServiceWorkerChannel","NotificationDisplayed","NOTIFICATION_DISPLAYED","NotificationClicked","clickedListenerCallbackCount","messenger","GET_EVENT_LISTENER_COUNT","NOTIFICATION_CLICKED","callbackCount","numberOfListeners","now","RedirectPage","SERVICEWORKER_COMMAND_REDIRECT","NotificationDismissed","NOTIFICATION_DISMISSED","isHttps","AreYouVisible","incomingPayload","focused","hasFocus","AreYouVisibleResponse","httpPayload","ARE_YOU_VISIBLE_REQUEST","fullWorkerPath","getServiceWorkerHref","encodeHashAsUriComponent","registrationOptions","register","SubscriptionError_SubscriptionErrorReason","SubscriptionErrorReason","SubscriptionError_SubscriptionError","InvalidSafariSetup","SubscriptionManager_SubscriptionManager","subscriptionStrategy","subscribeFcmFromWorker","subscribeSafari","installWorker","subscribeFcmFromPage","createFromPushSubscription","newDeviceId","isAlreadyRegisteredWithOneSignal","sendPlayerUpdate","sendPlayerCreate","associateSubscriptionWithEmail","REGISTERED","_sessionInitAlreadyRunning","requestNotificationPermission","strategy","OneSignalApiShared","updatePlayer","MutedByApi","results","Notification","requestPermission","deviceToken","pushSubscriptionDetails","existingDeviceToken","permission","PERMISSION_PROMPT_DISPLAYED","subscribeSafariPromptPermission","triggerNotificationPermissionChanged","setFromSafariSubscription","requestPresubscribeNotificationPermission","_isRegisteringForPush","subscriptionManager","registerFailedSubscription","ServiceWorkerStatus403","ServiceWorkerStatus404","ready","subscribeWithVapidKey","swRegistration","bowser_default","pushPermission","permissionState","userVisibleOnly","onesignalVapidPublicKey","base64String","base64","repeat","rawData","atob","outputArray","charCodeAt","base64ToUint8Array","buffer","doPushUnsubscribe","newPushSubscription","isNewSubscription","doPushSubscribe","getVapidKeyForBrowser","updateSubscriptionTime","updateCreatedAt","unsubscribe","applicationServerKey","subscriptionOptions","existingSubscription","subscribe","integrationKind","isSubscriptionExpiringForSecureIntegration","SUBSCRIPTION_EXPIRATION_STATE","serviceWorkerState","serviceWorkerRegistration","subscriptionCreatedAt","ONE_YEAR","midpointExpirationTime","getSubscriptionStateForSecure","subscribed","GET_SUBSCRIPTION_STATE","getSubscriptionStateForInsecure","notificationPermission","isWorkerActive","pageViewManager","isFirstPageView","registerSubscription","incrementPageViewCount","NotSubscribedError_NotSubscribedReason","NotSubscribedReason","helpers_ContextHelper","envPrefix","getBuildEnvPrefix","serviceWorkerManagerConfig","serviceWorkerPath","serviceWorkerUpdaterPath","serviceWorkerParam","subscriptionManagerConfig","NotSubscribedError_NotSubscribedError","NoDeviceId","NoEmailSet","OptedOut","UpdateManager_UpdateManager","onSessionSent","MainHelper","createDeviceRecord","getDeviceId","sendOnSessionUpdate","enableOnSession","sessionManager","PlayerOnSession","createUser","external_user_id","outcomeRequestData","sendOutcome","SessionManager_SessionManager","_context","_deviceId","_deviceRecord","_sessionOrigin","ContextSW_ContextSW","getSubscriptionManager","getServiceWorkerManager","PermissionManager","reportedPermission","getReportedNotificationPermission","isPermissionEnvironmentAmbiguous","getInterpretedAmbiguousPermission","getSafariNotificationPermission","_utils_OneSignalUtils__WEBPACK_IMPORTED_MODULE_1__","getOneSignalSubdomainNotificationPermission","getW3cNotificationPermission","_errors_InvalidArgumentError__WEBPACK_IMPORTED_MODULE_3__","REMOTE_NOTIFICATION_PERMISSION","remoteNotificationPermission","_models_NotificationPermission__WEBPACK_IMPORTED_MODULE_4__","isCurrentFrameContextCrossOrigin","_managers_SdkEnvironment__WEBPACK_IMPORTED_MODULE_5__","isInsecureOrigin","topFrameOrigin","storedPermission","getStoredPermission","_utils_LocalStorage__WEBPACK_IMPORTED_MODULE_6__","setStoredPermission","BrowserUtils","decodeTextArea","createElement","innerHTML","TimedLocalStorage","expirationInMinutes","isLocalStorageSupported","expirationInMilliseconds","parsedRecord","removeItem","parsedRecordValue","LimitStore","LIMIT","values","CustomLink_CustomLink","dynamicResourceLoader","loadSdkStylesheet","querySelectorAll","containerSelector","isInitialized","injectMarkup","isPushEnabled","isOptedOut","internalIsOptedOut","subscribeSelector","initSubscribeElement","explanationSelector","initExplanationElement","container","explanation","explanationClass","appendChild","subscribeClass","markAsInitialized","textContent","setResetClass","setStateClass","setStyleClass","setSizeClass","setCustomColors","unsubscribeEnabled","setAttribute","subscriptionStateAttribute","optedOutAttribute","handleClick","getAttribute","autoAccept","requiresUserInteraction","registerForPushNotifications","color","button","backgroundColor","oldClassName","newClassName","size","resetClass","initializedAttribute","containerClass","PromptsHelper","promptOptions","slidedown","categories","tags","EventHelper_EventHelper","checkAndTriggerSubscriptionChanged","getSubscriptionState","setIsPushNotificationsEnabled","triggerSubscriptionChanged","newSubscriptionState","onSubscriptionChanged_showWelcomeNotification","onSubscriptionChanged_sendCategorySlidedownTags","onSubscriptionChanged_evaluateNotifyButtonDisplayPredicate","onSubscriptionChanged_updateCustomLink","isSubscribed","isCategorySlidedownConfigured","tagManager","sendTags","__doNotShowWelcomeNotification","welcome_notification_opts","welcomeNotification","welcome_notification_disabled","title","unopenableWelcomeNotificationUrl","decodeHtmlEntities","sendNotification","en","__isOneSignalWelcomeNotification","WELCOME_NOTIFICATION_SENT","notifyButton","displayPredicate","launcher","show","hide","initialize","customlink","SUBSCRIPTION_CHANGED","fireEventWithNotification","clickedNotificationInfo","clickedNotificationUrl","pageClickedNotifications","urlWithoutTrailingSlash","Browser","SubscriptionHelper_SubscriptionHelper","getIsPushNotificationsEnabled","internalRegisterForPush","MainHelper_MainHelper","PageRefresh","rawSubscription","windowCreator","updateStoredPermission","REMOTE_NOTIFICATION_PERMISSION_CHANGED","forceUpdatePermission","close","FINISH_REMOTE_REGISTRATION","progress","swSubscription","getRawPushSubscriptionForSafari","getRawPushSubscriptionWhenUsingSubscriptionWorkaround","isBrowserAndSupportsServiceWorkers","getRawPushSubscriptionFromServiceWorkerRegistration","currentPermission","existingUser","isOptedIn","previousPermission","getAppId","autoPrompt","src_config","acceptButtonText","cancelButtonText","fullscreen","autoAcceptTitle","exampleNotificationTitleDesktop","exampleNotificationTitleMobile","exampleNotificationMessageDesktop","exampleNotificationMessageMobile","exampleNotificationCaption","caption","promptOptionsStr","getFullscreenPermissionMessageOptions","getPromptOptionsPostHash","legacyParams","legacyParamKey","legacyParamValue","allowedPromptOptions","encoded_value","clickResult","CUSTOM_PROMPT_CLICKED","includeSubscription","getRawPushSubscription","getCurrentNotificationType","_libraries_Log__WEBPACK_IMPORTED_MODULE_1__","ConfigIntegrationKind","NotificationClickMatchBehavior","NotificationClickActionBehavior","ConfigHelper_IntegrationConfigurationKind","IntegrationConfigurationKind","TagUtils_TagUtils","convertedTags","localTags","remoteTags","finalTags","categoryArray","checked","category","existingPlayerTags","isTagObjectEmpty","categoriesCopy","markAllTagsAsSpecified","existingTagValue","tag","getCheckedStatusForTagValue","tagValue","ConfigHelper_MAX_CATEGORIES","ConfigHelper_ConfigHelper","downloadServerAppConfig","isValidUuid","serverConfig","getMergedConfig","checkRestrictedOrigin","code","restrictedOriginEnabled","doesCurrentOriginMatchConfigOrigin","configOrigin","Custom","WordPress","configuration","JavaScript","Dashboard","configIntegrationKind","getConfigIntegrationKind","getSubdomainForConfigIntegrationKind","setupBehavior","mergedUserConfig","getUserConfigForConfigIntegrationKind","http_use_onesignal_com","cookieSyncEnabled","features","cookie_sync","enable","restrict_origin","metrics","mixpanelReportingToken","mixpanel_reporting_token","safari_web_id","vapid_public_key","onesignal_vapid_public_key","require_auth","receiveReceiptsEnable","receive_receipts_enable","valueOrDefault","enable_on_session","sessionThreshold","session_threshold","enableSessionDuration","web_on_focus_enabled","kind","initialState","staticPrompts","defaultsFromServer","wholeUserConfig","customlinkUser","customlinkDefaults","promptOptionsConfig","limitCategoriesToMaxCount","getSlidedownPermissionMessageOptions","native","autoRegister","getCustomLinkConfig","getIntegrationCapabilities","autoResubscribe","workerName","updaterWorkerName","registrationScope","subdomainName","siteInfo","proxyOrigin","getPromptOptionsForDashboardConfiguration","disable","bell","hideWhenSubscribed","isPushNotificationsEnabled","position","showCredit","offset","bottom","left","right","colors","circle.background","main","circle.foreground","accent","badge.background","badge.foreground","badge.bordercolor","pulse.color","dialog.button.background.hovering","dialog.button.background.active","dialog.button.background","dialog.button.foreground","tip.state.unsubscribed","tooltip","unsubscribed","tip.state.subscribed","tip.state.blocked","blocked","message.prenotify","message.action.subscribing","subscribing","message.action.subscribed","message.action.resubscribed","message.action.unsubscribed","unsubscribing","dialog.main.title","dialog","dialog.main.button.subscribe","subscribeButton","dialog.main.button.unsubscribe","unsubscribeButton","dialog.blocked.title","dialog.blocked.message","persistNotification","notificationBehavior","display","persist","webhooks","cors","corsEnable","notification.displayed","notificationDisplayedHook","notification.clicked","notificationClickedHook","notification.dismissed","notificationDismissedHook","notificationClickHandlerMatch","click","notificationClickHandlerAction","requiresUserPrivacyConsent","outcomes","notification_attribution","minutes_since_displayed","limit","injectDefaultsIntoPromptOptions","SERVICE_WORKER_PARAM","SERVICE_WORKER_PATH","SERVICE_WORKER_UPDATER_PATH","integrationCapabilities","userValue","serverValue","proxyOriginEnabled","shouldUseServerConfigSubdomain","userProvidedSubdomain","capabilities","g","Function","eval","VERSION","environment","_libraries_sw_Log__WEBPACK_IMPORTED_MODULE_13__","_services_Database__WEBPACK_IMPORTED_MODULE_8__","bowser__WEBPACK_IMPORTED_MODULE_1___default","_libraries_WorkerMessenger__WEBPACK_IMPORTED_MODULE_3__","onPushReceived","onNotificationClosed","waitUntil","onNotificationClicked","onServiceWorkerInstalled","onServiceWorkerActivated","onPushSubscriptionChange","SessionUpsert","debounceRefreshSession","SessionDeactivate","listen","setupMessageListeners","broadcast","Subscribe","appConfigBundle","_models_ContextSW__WEBPACK_IMPORTED_MODULE_5__","SubscribeNew","AmpSubscriptionState","_appConfigBundle","AmpSubscribe","_helpers_ConfigHelper__WEBPACK_IMPORTED_MODULE_14__","_OneSignalApiSW__WEBPACK_IMPORTED_MODULE_7__","AmpUnsubscribe","clientsStatus","receivedResponsesCount","hasAnyActiveSessions","SetLogging","_context_shared_utils_Utils__WEBPACK_IMPORTED_MODULE_16__","parseOrFetchNotifications","notifications","notificationEventPromiseFns","notificationReceivedPromises","rawNotification","buildStructuredNotificationObject","notificationReceived","displayNotification","executeWebhooks","sendConfirmedDelivery","UNSUBSCRIBED_FROM_NOTIFICATIONS","webhookTargetUrl","isServerCorsEnabled","postData","heading","content","fetchOptions","mode","X-OneSignal-Event","Content-Type","rr","player_id","_OneSignalApiBase__WEBPACK_IMPORTED_MODULE_6__","windowClients","activeClients","isSubdomainIframe","frameType","_helpers_ServiceWorkerHelper__WEBPACK_IMPORTED_MODULE_17__","deactivateSession","checkIfAnyClientsFocusedAndUpdateSession","w","updateSessionBasedOnHasActive","osClients","getActiveClients","sessionInfo","sentRequestsCount","getClientStatusesCancelable","_helpers_sw_CancelableTimeout__WEBPACK_IMPORTED_MODULE_18__","cancelableRefreshSession","refreshSession","custom","alert","u","image","badge","vibrate","rawButton","imageUrl","parsedImageUrl","host","ensureImageResourceHttps","overrides","defaultTitle","_getTitle","defaultIcon","ensureNotificationResourcesHttps","notificationOptions","actions","requireInteraction","renotify","fixPlatformSpecificDisplayIssues","showNotification","clone","_utils_OneSignalUtils__WEBPACK_IMPORTED_MODULE_15__","isVersionAtLeast","launchUrl","dbDefaultNotificationUrl","notificationData","matchPreference","actionPreference","getNotificationUrlToOpen","notificationOpensLink","shouldOpenNotificationUrl","_models_DeviceRecord__WEBPACK_IMPORTED_MODULE_19__","saveNotificationClickedPromise","notificationClicked","_models_Session__WEBPACK_IMPORTED_MODULE_12__","convertedAPIRequests","sendConvertedAPIRequests","doNotOpenLink","clientUrl","lastKnownHostUrl","clientOrigin","launchOrigin","WindowClient","focus","navigate","openUrl","onesignalRestPromise","opened","openWindow","skipWaiting","_managers_SdkEnvironment__WEBPACK_IMPORTED_MODULE_4__","claim","deviceIdExists","oldSubscription","getUserIdFromSubscriptionIdentifier","_models_PushDeviceRecord__WEBPACK_IMPORTED_MODULE_11__","providedNewSubscription","newSubscription","_models_RawPushSubscription__WEBPACK_IMPORTED_MODULE_9__","_models_SubscriptionStateKind__WEBPACK_IMPORTED_MODULE_10__","PermissionRevoked","PushSubscriptionRevoked","pageTitle","isValidPushPayload","OneSignalWorker","run","_src_service_worker_ServiceWorker__WEBPACK_IMPORTED_MODULE_0__"],"mappings":"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","file":"OneSignalSDKWorker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 47);\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator];\r\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","export default class Log {\n    static shouldLog() {\n        try {\n            if (typeof window === \"undefined\" ||\n                typeof window.localStorage === \"undefined\") {\n                return false;\n            }\n            const level = window.localStorage.getItem(\"loglevel\");\n            if (level && level.toLowerCase() === \"trace\") {\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n        catch (e) {\n            /* LocalStorage may not be accessible on browser profiles that restrict 3rd party cookies */\n            return false;\n        }\n        ;\n    }\n    static setLevel(level) {\n        if (typeof window === \"undefined\" ||\n            typeof window.localStorage === \"undefined\") {\n            return;\n        }\n        try {\n            window.localStorage.setItem(\"loglevel\", level);\n            Log.proxyMethodsCreated = undefined;\n            Log.createProxyMethods();\n        }\n        catch (e) {\n            /* LocalStorage may not be accessible on browser profiles that restrict 3rd party cookies */\n            return;\n        }\n        ;\n    }\n    static createProxyMethods() {\n        if (typeof Log.proxyMethodsCreated !== \"undefined\") {\n            return;\n        }\n        else {\n            Log.proxyMethodsCreated = true;\n        }\n        const methods = {\n            \"log\": \"debug\",\n            \"trace\": \"trace\",\n            \"info\": \"info\",\n            \"warn\": \"warn\",\n            \"error\": \"error\"\n        };\n        for (const nativeMethod of Object.keys(methods)) {\n            const nativeMethodExists = typeof console[nativeMethod] !== \"undefined\";\n            const methodToMapTo = methods[nativeMethod];\n            const shouldMap = nativeMethodExists &&\n                ((typeof __LOGGING__ !== \"undefined\" && __LOGGING__ === true) ||\n                    (Log.shouldLog()) ||\n                    methodToMapTo === \"error\");\n            if (shouldMap) {\n                Log[methodToMapTo] = console[nativeMethod].bind(console);\n            }\n            else {\n                Log[methodToMapTo] = function () { };\n            }\n        }\n    }\n}\nLog.createProxyMethods();\n//# sourceMappingURL=Log.js.map","import OneSignalError from \"./OneSignalError\";\nexport default class TimeoutError extends OneSignalError {\n    constructor(message = \"The asynchronous operation has timed out.\") {\n        super(message);\n        this.message = message;\n        /**\n         * Important! Required to make sure the correct error type is detected during instanceof checks.\n         * Same applies to all derived classes.\n         * https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n         */\n        Object.setPrototypeOf(this, TimeoutError.prototype);\n    }\n}\n//# sourceMappingURL=TimeoutError.js.map","import TimeoutError from '../../../errors/TimeoutError';\nimport { OneSignalApiErrorKind, OneSignalApiError } from \"../../../errors/OneSignalApiError\";\nexport class Utils {\n    /**\n     * Returns true if match is in string; otherwise, returns false.\n     */\n    static contains(indexOfAble, match) {\n        if (!indexOfAble)\n            return false;\n        return indexOfAble.indexOf(match) !== -1;\n    }\n    static getConsoleStyle(style) {\n        if (style == 'code') {\n            return `padding: 0 1px 1px 5px;border: 1px solid #ddd;border-radius: 3px;font-family: Monaco,\"DejaVu Sans Mono\",\"Courier New\",monospace;color: #444;`;\n        }\n        else if (style == 'bold') {\n            return `font-weight: 600;color: rgb(51, 51, 51);`;\n        }\n        else if (style == 'alert') {\n            return `font-weight: 600;color: red;`;\n        }\n        else if (style == 'event') {\n            return `color: green;`;\n        }\n        else if (style == 'postmessage') {\n            return `color: orange;`;\n        }\n        else if (style == 'serviceworkermessage') {\n            return `color: purple;`;\n        }\n        else {\n            return '';\n        }\n    }\n    /**\n     * Returns the current object without keys that have undefined values.\n     * Regardless of whether the return result is used, the passed-in object is destructively modified.\n     * Only affects keys that the object directly contains (i.e. not those inherited via the object's prototype).\n     * @param object\n     */\n    static trimUndefined(object) {\n        for (var property in object) {\n            if (object.hasOwnProperty(property)) {\n                if (object[property] === undefined) {\n                    delete object[property];\n                }\n            }\n        }\n        return object;\n    }\n    /**\n     * Capitalizes the first letter of the string.\n     * @returns {string} The string with the first letter capitalized.\n     */\n    static capitalize(text) {\n        return text.charAt(0).toUpperCase() + text.slice(1);\n    }\n    static isNullOrUndefined(value) {\n        return typeof value === 'undefined' || value === null;\n    }\n    static valueOrDefault(value, defaultValue) {\n        if (typeof value === \"undefined\" || value === null) {\n            return defaultValue;\n        }\n        return value;\n    }\n    /**\n     * JSON.stringify() but converts functions to \"[Function]\" so they aren't lost.\n     * Helps when logging method calls.\n     */\n    static stringify(obj) {\n        return JSON.stringify(obj, (_, value) => {\n            if (typeof value === 'function') {\n                return \"[Function]\";\n            }\n            else {\n                return value;\n            }\n        }, 4);\n    }\n    static encodeHashAsUriComponent(hash) {\n        let uriComponent = '';\n        const keys = Object.keys(hash);\n        for (var key of keys) {\n            const value = hash[key];\n            uriComponent += `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;\n        }\n        return uriComponent;\n    }\n    static timeoutPromise(promise, milliseconds) {\n        const timeoutPromise = new Promise((_, reject) => {\n            setTimeout(() => {\n                reject(new TimeoutError());\n            }, milliseconds);\n        });\n        return Promise.race([promise, timeoutPromise]);\n    }\n    static getValueOrDefault(value, defaultValue) {\n        if (value !== undefined && value !== null) {\n            return value;\n        }\n        return defaultValue;\n    }\n    /**\n     * This is similar to ECMAScript2107 String.prototype.padStart.\n     * Switch to this after updating TypeScript and can confirm it gets transpiled down to ES6\n     * @param str - String to pad left\n     * @param targetLength - Length to make the string\n     * @param padString - String value of length one to pad with.\n     * @returns {string} - Resulting string padded\n     */\n    static padStart(str, targetLength, padString) {\n        let result = str;\n        while (result.length < targetLength) {\n            result = padString + result;\n        }\n        return result;\n    }\n    /**\n     * Returns trimmed version number\n     * e.g: \"10.01.30\" becomes \"10.01\"\n     * @param version - version number we want to check\n     */\n    static parseVersionString(version) {\n        const osVersionParts = version.toString().split(\".\");\n        const majorVersion = Utils.padStart(osVersionParts[0], 2, \"0\");\n        let minorVersion;\n        if (osVersionParts[1]) {\n            minorVersion = Utils.padStart(osVersionParts[1], 2, \"0\");\n        }\n        else {\n            minorVersion = \"00\";\n        }\n        return Number(`${majorVersion}.${minorVersion}`);\n    }\n    /**\n     * Gives back the last x number of parts providing a string with a delimiter.\n     * Example: lastParts(\"api.staging.onesignal.com\", \".\", 3) will return \"staging.onesignal.com\"\n     */\n    static lastParts(subject, delimiter, maxParts) {\n        const parts = subject.split(delimiter);\n        const skipParts = Math.max(parts.length - maxParts, 0);\n        return parts.slice(skipParts).join(delimiter);\n    }\n    /**\n     * Checks if a version is number is greater than or equal (AKA at least) to a specific compare\n     *   to version.\n     * Limited to only checking for major and minor version values, patch versions are ignored\n     * @param toCheck - Version we want to check\n     * @param compareTo - Version we want to be at or higher\n     * @returns {string} - Returns true if toCheck >= compareTo\n     */\n    static isVersionAtLeast(toCheck, compareTo) {\n        return this.parseVersionString(toCheck) >= compareTo;\n    }\n    static enforceAppId(appId) {\n        if (!appId) {\n            throw new Error(\"App id cannot be empty\");\n        }\n    }\n    static enforcePlayerId(playerId) {\n        if (!playerId) {\n            throw new Error(\"Player id cannot be empty\");\n        }\n    }\n    static async enforceAppIdAndPlayerId(appId, playerId, funcToExecute) {\n        Utils.enforceAppId(appId);\n        Utils.enforcePlayerId(playerId);\n        try {\n            return await funcToExecute();\n        }\n        catch (e) {\n            if (e && Array.isArray(e.errors) && e.errors.length > 0 &&\n                Utils.contains(e.errors[0], \"app_id not found\")) {\n                throw new OneSignalApiError(OneSignalApiErrorKind.MissingAppId);\n            }\n            else\n                throw e;\n        }\n    }\n    static sortArrayOfObjects(arrayToSort, predicateForProperty, descending = false, doItInPlace = true) {\n        const internalArrayToSort = doItInPlace ? arrayToSort : arrayToSort.slice();\n        internalArrayToSort.sort((a, b) => {\n            const propertyA = predicateForProperty(a);\n            const propertyB = predicateForProperty(b);\n            if (propertyA > propertyB) {\n                return !!descending ? -1 : 1;\n            }\n            if (propertyA < propertyB) {\n                return !!descending ? 1 : -1;\n            }\n            return 0;\n        });\n        return internalArrayToSort;\n    }\n}\nexport default Utils;\n//# sourceMappingURL=Utils.js.map","/**\n * Source: https://github.com/pazguille/emitter-es6\n */\n/**\n * Creates a new instance of Emitter.\n * @class\n * @returns {Object} emitter - An instance of Emitter.\n * @example\n * var emitter = new Emitter();\n */\nexport default class Emitter {\n    constructor() {\n        this._events = {};\n    }\n    /**\n     * Adds a listener to the collection for a specified event.\n     */\n    on(event, listener) {\n        this._events[event] = this._events[event] || [];\n        this._events[event].push(listener);\n        return this;\n    }\n    /**\n     * Adds a one time listener to the collection for a specified event. It will\n     * execute only once.\n     */\n    once(event, listener) {\n        const that = this;\n        function fn() {\n            that.off(event, fn);\n            listener.apply(this, arguments);\n        }\n        fn.listener = listener;\n        this.on(event, fn);\n        return this;\n    }\n    /**\n     * Removes a listener from the collection for a specified event.\n     */\n    off(event, listener) {\n        const listeners = this._events[event];\n        if (listeners !== undefined) {\n            for (let j = 0; j < listeners.length; j += 1) {\n                if (listeners[j] === listener || listeners[j].listener === listener) {\n                    listeners.splice(j, 1);\n                    break;\n                }\n            }\n            if (listeners.length === 0)\n                this.removeAllListeners(event);\n        }\n        return this;\n    }\n    /**\n     * Removes all listeners from the collection for a specified event.\n     */\n    removeAllListeners(event) {\n        try {\n            if (event)\n                delete this._events[event];\n            else\n                this._events = {};\n        }\n        catch (e) { }\n        return this;\n    }\n    /**\n     * Returns all listeners from the collection for a specified event.\n     * @public\n     * @function\n     * @name Emitter#listeners\n     * @param {String} event - Event name.\n     * @returns {Array}\n     * @example\n     * me.listeners('ready');\n     */\n    listeners(event) {\n        try {\n            return this._events[event];\n        }\n        catch (e) {\n            return undefined;\n        }\n    }\n    /**\n     * Returns number of listeners from the collection for a specified event.\n     * @public\n     * @function\n     * @name Emitter#numberOfListeners\n     * @param {String} event - Event name.\n     * @returns {number}\n     * @example\n     * me.numberOfListeners('ready');\n     */\n    numberOfListeners(event) {\n        const listeners = this.listeners(event);\n        if (listeners)\n            return listeners.length;\n        return 0;\n    }\n    /**\n     * Execute each item in the listener collection in order with the specified data.\n     * @param event - String of the event name\n     * @param args - Variable number of args to pass to the functions subscribe to the event\n     */\n    async emit(...args) {\n        const event = args.shift();\n        let listeners = this._events[event];\n        if (listeners !== undefined) {\n            listeners = listeners.slice(0);\n            const len = listeners.length;\n            for (let i = 0; i < len; i += 1)\n                await listeners[i].apply(this, args);\n        }\n        return this;\n    }\n}\n//# sourceMappingURL=Emitter.js.map","import Emitter from '../libraries/Emitter';\nimport Log from '../libraries/Log';\nimport Utils from \"../context/shared/utils/Utils\";\nconst DATABASE_VERSION = 3;\nexport default class IndexedDb {\n    constructor(databaseName) {\n        this.databaseName = databaseName;\n        this.emitter = new Emitter();\n    }\n    open(databaseName) {\n        return new Promise(resolve => {\n            let request = undefined;\n            try {\n                // Open algorithm: https://www.w3.org/TR/IndexedDB/#h-opening\n                request = indexedDB.open(databaseName, DATABASE_VERSION);\n            }\n            catch (e) {\n                // Errors should be thrown on the request.onerror event, but just in case Firefox throws additional errors\n                // for profile schema too high\n            }\n            if (!request) {\n                return null;\n            }\n            request.onerror = this.onDatabaseOpenError;\n            request.onblocked = this.onDatabaseOpenBlocked;\n            request.onupgradeneeded = this.onDatabaseUpgradeNeeded;\n            request.onsuccess = () => {\n                this.database = request.result;\n                this.database.onerror = this.onDatabaseError;\n                this.database.onversionchange = this.onDatabaseVersionChange;\n                resolve(this.database);\n            };\n        });\n    }\n    async ensureDatabaseOpen() {\n        if (!this.openLock) {\n            this.openLock = this.open(this.databaseName);\n        }\n        return await this.openLock;\n    }\n    onDatabaseOpenError(event) {\n        // Prevent the error from bubbling: https://bugzilla.mozilla.org/show_bug.cgi?id=1331103#c3\n        /**\n         * To prevent error reporting tools like Sentry.io from picking up errors that\n         * the site owner can't do anything about and use up their quota, hide database open\n         * errors.\n         */\n        event.preventDefault();\n        const error = event.target.error;\n        if (Utils.contains(error.message, 'The operation failed for reasons unrelated to the database itself and not covered by any other error code') ||\n            Utils.contains(error.message, 'A mutation operation was attempted on a database that did not allow mutations')) {\n            Log.warn(\"OneSignal: IndexedDb web storage is not available on this origin since this profile's IndexedDb schema has been upgraded in a newer version of Firefox. See: https://bugzilla.mozilla.org/show_bug.cgi?id=1236557#c6\");\n        }\n        else {\n            Log.warn('OneSignal: Fatal error opening IndexedDb database:', error);\n        }\n    }\n    /**\n     * Error events bubble. Error events are targeted at the request that generated the error, then the event bubbles to\n     * the transaction, and then finally to the database object. If you want to avoid adding error handlers to every\n     * request, you can instead add a single error handler on the database object.\n     */\n    onDatabaseError(event) {\n        Log.debug('IndexedDb: Generic database error', event.target.errorCode);\n    }\n    /**\n     * Occurs when the upgradeneeded should be triggered because of a version change but the database is still in use\n     * (that is, not closed) somewhere, even after the versionchange event was sent.\n     */\n    onDatabaseOpenBlocked() {\n        Log.debug('IndexedDb: Blocked event');\n    }\n    /**\n     * Occurs when a database structure change (IDBOpenDBRequest.onupgradeneeded event or IDBFactory.deleteDatabase) was\n     * requested elsewhere (most probably in another window/tab on the same computer).\n     *\n     * versionchange Algorithm: https://www.w3.org/TR/IndexedDB/#h-versionchange-transaction-steps\n     *\n     * Ref: https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase/onversionchange\n     */\n    onDatabaseVersionChange(_) {\n        Log.debug('IndexedDb: versionchange event');\n    }\n    /**\n     * Occurs when a new version of the database needs to be created, or has not been created before, or a new version\n     * of the database was requested to be opened when calling window.indexedDB.open.\n     *\n     * Ref: https://developer.mozilla.org/en-US/docs/Web/API/IDBOpenDBRequest/onupgradeneeded\n     */\n    onDatabaseUpgradeNeeded(event) {\n        Log.debug('IndexedDb: Database is being rebuilt or upgraded (upgradeneeded event).');\n        const db = event.target.result;\n        if (event.oldVersion < 1) {\n            db.createObjectStore(\"Ids\", { keyPath: \"type\" });\n            db.createObjectStore(\"NotificationOpened\", { keyPath: \"url\" });\n            db.createObjectStore(\"Options\", { keyPath: \"key\" });\n        }\n        if (event.oldVersion < 2) {\n            db.createObjectStore(\"Sessions\", { keyPath: \"sessionKey\" });\n            db.createObjectStore(\"NotificationReceived\", { keyPath: \"notificationId\" });\n            db.createObjectStore(\"NotificationClicked\", { keyPath: \"notificationId\" });\n        }\n        if (event.oldVersion < 3) {\n            db.createObjectStore(\"SentUniqueOutcome\", { keyPath: \"outcomeName\" });\n        }\n        // Wrap in conditional for tests\n        if (typeof OneSignal !== \"undefined\") {\n            OneSignal._isNewVisitor = true;\n        }\n    }\n    /**\n     * Asynchronously retrieves the value of the key at the table (if key is specified), or the entire table (if key is not specified).\n     * @param table The table to retrieve the value from.\n     * @param key The key in the table to retrieve the value of. Leave blank to get the entire table.\n     * @returns {Promise} Returns a promise that fulfills when the value(s) are available.\n     */\n    async get(table, key) {\n        const database = await this.ensureDatabaseOpen();\n        if (key) {\n            // Return a table-key value\n            return await new Promise((resolve, reject) => {\n                const request = database.transaction(table).objectStore(table).get(key);\n                request.onsuccess = () => {\n                    resolve(request.result);\n                };\n                request.onerror = () => {\n                    reject(request.error);\n                };\n            });\n        }\n        else {\n            // Return all values in table\n            return await new Promise((resolve, reject) => {\n                let jsonResult = {};\n                let cursor = database.transaction(table).objectStore(table).openCursor();\n                cursor.onsuccess = (event) => {\n                    const cursorResult = event.target.result;\n                    if (cursorResult) {\n                        let cursorResultKey = cursorResult.key;\n                        jsonResult[cursorResultKey] = cursorResult.value;\n                        cursorResult.continue();\n                    }\n                    else {\n                        resolve(jsonResult);\n                    }\n                };\n                cursor.onerror = () => {\n                    reject(cursor.error);\n                };\n            });\n        }\n    }\n    async getAll(table) {\n        return await new Promise(async (resolve, reject) => {\n            const database = await this.ensureDatabaseOpen();\n            let cursor = database.transaction(table).objectStore(table).openCursor();\n            const result = [];\n            cursor.onsuccess = (event) => {\n                const cursorResult = event.target.result;\n                if (cursorResult) {\n                    result.push(cursorResult.value);\n                    cursorResult.continue();\n                }\n                else {\n                    resolve(result);\n                }\n            };\n            cursor.onerror = () => {\n                reject(cursor.error);\n            };\n        });\n    }\n    /**\n     * Asynchronously puts the specified value in the specified table.\n     */\n    async put(table, key) {\n        await this.ensureDatabaseOpen();\n        return await new Promise((resolve, reject) => {\n            try {\n                let request = this.database.transaction([table], 'readwrite').objectStore(table).put(key);\n                request.onsuccess = () => {\n                    resolve(key);\n                };\n                request.onerror = (e) => {\n                    Log.error('Database PUT Transaction Error:', e);\n                    reject(e);\n                };\n            }\n            catch (e) {\n                Log.error('Database PUT Error:', e);\n                reject(e);\n            }\n        });\n    }\n    /**\n     * Asynchronously removes the specified key from the table, or if the key is not specified, removes all keys in the table.\n     * @returns {Promise} Returns a promise containing a key that is fulfilled when deletion is completed.\n     */\n    async remove(table, key) {\n        const database = await this.ensureDatabaseOpen();\n        return new Promise((resolve, reject) => {\n            try {\n                const store = database.transaction([table], \"readwrite\").objectStore(table);\n                // If key is present remove a single key from a table.\n                // Otherwise wipe the table\n                const request = key ? store.delete(key) : store.clear();\n                request.onsuccess = () => {\n                    resolve(key);\n                };\n                request.onerror = (e) => {\n                    Log.error('Database REMOVE Transaction Error:', e);\n                    reject(e);\n                };\n            }\n            catch (e) {\n                Log.error('Database REMOVE Error:', e);\n                reject(e);\n            }\n        });\n    }\n}\n//# sourceMappingURL=IndexedDb.js.map","class AppState {\n}\nexport { AppState };\n//# sourceMappingURL=AppState.js.map","class ServiceWorkerState {\n}\nexport { ServiceWorkerState };\n//# sourceMappingURL=ServiceWorkerState.js.map","export class Subscription {\n    serialize() {\n        return {\n            deviceId: this.deviceId,\n            subscriptionToken: this.subscriptionToken,\n            optedOut: this.optedOut,\n            createdAt: this.createdAt,\n            expirationTime: this.expirationTime,\n        };\n    }\n    static deserialize(bundle) {\n        const subscription = new Subscription();\n        subscription.deviceId = bundle.deviceId;\n        subscription.subscriptionToken = bundle.subscriptionToken;\n        subscription.optedOut = bundle.optedOut;\n        subscription.createdAt = bundle.createdAt;\n        subscription.expirationTime = bundle.expirationTime;\n        return subscription;\n    }\n}\n//# sourceMappingURL=Subscription.js.map","export class EmailProfile {\n    constructor(emailId, emailAddress, emailAuthHash) {\n        this.emailId = emailId;\n        this.emailAddress = emailAddress;\n        this.emailAuthHash = emailAuthHash;\n    }\n    serialize() {\n        return {\n            emailAddress: this.emailAddress,\n            emailAuthHash: this.emailAuthHash,\n            emailId: this.emailId,\n        };\n    }\n    static deserialize(bundle) {\n        return new EmailProfile(bundle.emailId, bundle.emailAddress, bundle.emailAuthHash);\n    }\n}\n//# sourceMappingURL=EmailProfile.js.map","import Emitter from \"../libraries/Emitter\";\nimport IndexedDb from \"./IndexedDb\";\nimport { AppState } from \"../models/AppState\";\nimport { ServiceWorkerState } from \"../models/ServiceWorkerState\";\nimport { Subscription } from \"../models/Subscription\";\nimport { TestEnvironmentKind } from \"../models/TestEnvironmentKind\";\nimport { WindowEnvironmentKind } from \"../models/WindowEnvironmentKind\";\nimport { EmailProfile } from \"../models/EmailProfile\";\nimport { ONESIGNAL_SESSION_KEY } from \"../models/Session\";\nimport SdkEnvironment from \"../managers/SdkEnvironment\";\nimport OneSignalUtils from \"../utils/OneSignalUtils\";\nimport Utils from \"../context/shared/utils/Utils\";\nimport Log from \"../libraries/Log\";\nvar DatabaseEventName;\n(function (DatabaseEventName) {\n    DatabaseEventName[DatabaseEventName[\"SET\"] = 0] = \"SET\";\n})(DatabaseEventName || (DatabaseEventName = {}));\nexport default class Database {\n    constructor(databaseName) {\n        this.databaseName = databaseName;\n        this.emitter = new Emitter();\n        this.database = new IndexedDb(this.databaseName);\n    }\n    static resetInstance() {\n        Database.databaseInstance = null;\n    }\n    static get singletonInstance() {\n        if (!Database.databaseInstanceName) {\n            Database.databaseInstanceName = \"ONE_SIGNAL_SDK_DB\";\n        }\n        if (!Database.databaseInstance) {\n            Database.databaseInstance = new Database(Database.databaseInstanceName);\n        }\n        return Database.databaseInstance;\n    }\n    static applyDbResultFilter(table, key, result) {\n        switch (table) {\n            case \"Options\":\n                if (result && key)\n                    return result.value;\n                else if (result && !key)\n                    return result;\n                else\n                    return null;\n            case \"Ids\":\n                if (result && key)\n                    return result.id;\n                else if (result && !key)\n                    return result;\n                else\n                    return null;\n            case \"NotificationOpened\":\n                if (result && key)\n                    return { data: result.data, timestamp: result.timestamp };\n                else if (result && !key)\n                    return result;\n                else\n                    return null;\n            default:\n                if (result)\n                    return result;\n                else\n                    return null;\n        }\n    }\n    shouldUsePostmam() {\n        return SdkEnvironment.getWindowEnv() !== WindowEnvironmentKind.ServiceWorker &&\n            OneSignalUtils.isUsingSubscriptionWorkaround() &&\n            SdkEnvironment.getTestEnv() === TestEnvironmentKind.None;\n    }\n    /**\n     * Asynchronously retrieves the value of the key at the table (if key is specified), or the entire table (if key is not specified).\n     * If on an iFrame or popup environment, retrieves from the correct IndexedDB database using cross-domain messaging.\n     * @param table The table to retrieve the value from.\n     * @param key The key in the table to retrieve the value of. Leave blank to get the entire table.\n     * @returns {Promise} Returns a promise that fulfills when the value(s) are available.\n     */\n    async get(table, key) {\n        if (this.shouldUsePostmam()) {\n            return await new Promise(async (resolve) => {\n                OneSignal.proxyFrameHost.message(OneSignal.POSTMAM_COMMANDS.REMOTE_DATABASE_GET, [{\n                        table: table,\n                        key: key\n                    }], (reply) => {\n                    const result = reply.data[0];\n                    resolve(result);\n                });\n            });\n        }\n        else {\n            const result = await this.database.get(table, key);\n            const cleanResult = Database.applyDbResultFilter(table, key, result);\n            return cleanResult;\n        }\n    }\n    async getAll(table) {\n        if (this.shouldUsePostmam()) {\n            return await new Promise(async (resolve) => {\n                OneSignal.proxyFrameHost.message(OneSignal.POSTMAM_COMMANDS.REMOTE_DATABASE_GET_ALL, {\n                    table: table\n                }, (reply) => {\n                    const result = reply.data;\n                    resolve(result);\n                });\n            });\n        }\n        else {\n            const result = await this.database.getAll(table);\n            return result;\n        }\n    }\n    /**\n     * Asynchronously puts the specified value in the specified table.\n     * @param table\n     * @param keypath\n     */\n    async put(table, keypath) {\n        await new Promise(async (resolve, reject) => {\n            if (SdkEnvironment.getWindowEnv() !== WindowEnvironmentKind.ServiceWorker &&\n                OneSignalUtils.isUsingSubscriptionWorkaround() &&\n                SdkEnvironment.getTestEnv() === TestEnvironmentKind.None) {\n                OneSignal.proxyFrameHost.message(OneSignal.POSTMAM_COMMANDS.REMOTE_DATABASE_PUT, [{ table: table, keypath: keypath }], (reply) => {\n                    if (reply.data === OneSignal.POSTMAM_COMMANDS.REMOTE_OPERATION_COMPLETE) {\n                        resolve();\n                    }\n                    else {\n                        reject(`(Database) Attempted remote IndexedDB put(${table}, ${keypath}), but did not get success response.`);\n                    }\n                });\n            }\n            else {\n                await this.database.put(table, keypath);\n                resolve();\n            }\n        });\n        this.emitter.emit(Database.EVENTS.SET, keypath);\n    }\n    /**\n     * Asynchronously removes the specified key from the table, or if the key is not specified, removes all keys in the table.\n     * @returns {Promise} Returns a promise containing a key that is fulfilled when deletion is completed.\n     */\n    remove(table, keypath) {\n        if (SdkEnvironment.getWindowEnv() !== WindowEnvironmentKind.ServiceWorker &&\n            OneSignalUtils.isUsingSubscriptionWorkaround() &&\n            SdkEnvironment.getTestEnv() === TestEnvironmentKind.None) {\n            return new Promise((resolve, reject) => {\n                OneSignal.proxyFrameHost.message(OneSignal.POSTMAM_COMMANDS.REMOTE_DATABASE_REMOVE, [{ table: table, keypath: keypath }], (reply) => {\n                    if (reply.data === OneSignal.POSTMAM_COMMANDS.REMOTE_OPERATION_COMPLETE) {\n                        resolve();\n                    }\n                    else {\n                        reject(`(Database) Attempted remote IndexedDB remove(${table}, ${keypath}), but did not get success response.`);\n                    }\n                });\n            });\n        }\n        else {\n            return this.database.remove(table, keypath);\n        }\n    }\n    async getAppConfig() {\n        const config = {};\n        const appIdStr = await this.get(\"Ids\", \"appId\");\n        config.appId = appIdStr;\n        config.subdomain = await this.get(\"Options\", \"subdomain\");\n        config.vapidPublicKey = await this.get(\"Options\", \"vapidPublicKey\");\n        config.emailAuthRequired = await this.get(\"Options\", \"emailAuthRequired\");\n        return config;\n    }\n    async getExternalUserId() {\n        return await this.get(\"Ids\", \"externalUserId\");\n    }\n    async setExternalUserId(externalUserId) {\n        const emptyString = \"\";\n        const externalIdToSave = Utils.getValueOrDefault(externalUserId, emptyString);\n        if (externalIdToSave === emptyString) {\n            await this.remove(\"Ids\", \"externalUserId\");\n        }\n        else {\n            await this.put(\"Ids\", { type: \"externalUserId\", id: externalIdToSave });\n        }\n    }\n    async setAppConfig(appConfig) {\n        if (appConfig.appId)\n            await this.put(\"Ids\", { type: \"appId\", id: appConfig.appId });\n        if (appConfig.subdomain)\n            await this.put(\"Options\", { key: \"subdomain\", value: appConfig.subdomain });\n        if (appConfig.httpUseOneSignalCom === true)\n            await this.put(\"Options\", { key: \"httpUseOneSignalCom\", value: true });\n        else if (appConfig.httpUseOneSignalCom === false)\n            await this.put(\"Options\", { key: \"httpUseOneSignalCom\", value: false });\n        if (appConfig.emailAuthRequired === true)\n            await this.put(\"Options\", { key: \"emailAuthRequired\", value: true });\n        else if (appConfig.emailAuthRequired === false)\n            await this.put(\"Options\", { key: \"emailAuthRequired\", value: false });\n        if (appConfig.vapidPublicKey)\n            await this.put(\"Options\", { key: \"vapidPublicKey\", value: appConfig.vapidPublicKey });\n    }\n    async getAppState() {\n        const state = new AppState();\n        state.defaultNotificationUrl = await this.get(\"Options\", \"defaultUrl\");\n        state.defaultNotificationTitle = await this.get(\"Options\", \"defaultTitle\");\n        state.lastKnownPushEnabled = await this.get(\"Options\", \"isPushEnabled\");\n        state.clickedNotifications = await this.get(\"NotificationOpened\");\n        return state;\n    }\n    async setAppState(appState) {\n        if (appState.defaultNotificationUrl)\n            await this.put(\"Options\", { key: \"defaultUrl\", value: appState.defaultNotificationUrl });\n        if (appState.defaultNotificationTitle || appState.defaultNotificationTitle === \"\")\n            await this.put(\"Options\", { key: \"defaultTitle\", value: appState.defaultNotificationTitle });\n        if (appState.lastKnownPushEnabled != null)\n            await this.put(\"Options\", { key: \"isPushEnabled\", value: appState.lastKnownPushEnabled });\n        if (appState.clickedNotifications) {\n            const clickedNotificationUrls = Object.keys(appState.clickedNotifications);\n            for (let url of clickedNotificationUrls) {\n                const notificationDetails = appState.clickedNotifications[url];\n                if (notificationDetails) {\n                    await this.put(\"NotificationOpened\", {\n                        url: url,\n                        data: notificationDetails.data,\n                        timestamp: notificationDetails.timestamp\n                    });\n                }\n                else if (notificationDetails === null) {\n                    // If we get an object like:\n                    // { \"http://site.com/page\": null}\n                    // It means we need to remove that entry\n                    await this.remove(\"NotificationOpened\", url);\n                }\n            }\n        }\n    }\n    async getServiceWorkerState() {\n        const state = new ServiceWorkerState();\n        state.workerVersion = await this.get(\"Ids\", \"WORKER1_ONE_SIGNAL_SW_VERSION\");\n        state.updaterWorkerVersion = await this.get(\"Ids\", \"WORKER2_ONE_SIGNAL_SW_VERSION\");\n        return state;\n    }\n    async setServiceWorkerState(state) {\n        if (state.workerVersion)\n            await this.put(\"Ids\", { type: \"WORKER1_ONE_SIGNAL_SW_VERSION\", id: state.workerVersion });\n        if (state.updaterWorkerVersion)\n            await this.put(\"Ids\", { type: \"WORKER2_ONE_SIGNAL_SW_VERSION\", id: state.updaterWorkerVersion });\n    }\n    async getSubscription() {\n        const subscription = new Subscription();\n        subscription.deviceId = await this.get(\"Ids\", \"userId\");\n        subscription.subscriptionToken = await this.get(\"Ids\", \"registrationId\");\n        // The preferred database key to store our subscription\n        const dbOptedOut = await this.get(\"Options\", \"optedOut\");\n        // For backwards compatibility, we need to read from this if the above is not found\n        const dbNotOptedOut = await this.get(\"Options\", \"subscription\");\n        const createdAt = await this.get(\"Options\", \"subscriptionCreatedAt\");\n        const expirationTime = await this.get(\"Options\", \"subscriptionExpirationTime\");\n        if (dbOptedOut != null) {\n            subscription.optedOut = dbOptedOut;\n        }\n        else {\n            if (dbNotOptedOut == null) {\n                subscription.optedOut = false;\n            }\n            else {\n                subscription.optedOut = !dbNotOptedOut;\n            }\n        }\n        subscription.createdAt = createdAt;\n        subscription.expirationTime = expirationTime;\n        return subscription;\n    }\n    async setDeviceId(deviceId) {\n        await this.put(\"Ids\", { type: \"userId\", id: deviceId });\n    }\n    async setSubscription(subscription) {\n        if (subscription.deviceId) {\n            await this.setDeviceId(subscription.deviceId);\n        }\n        if (typeof subscription.subscriptionToken !== \"undefined\") {\n            // Allow null subscriptions to be set\n            await this.put(\"Ids\", { type: \"registrationId\", id: subscription.subscriptionToken });\n        }\n        if (subscription.optedOut != null) { // Checks if null or undefined, allows false\n            await this.put(\"Options\", { key: \"optedOut\", value: subscription.optedOut });\n        }\n        if (subscription.createdAt != null) {\n            await this.put(\"Options\", { key: \"subscriptionCreatedAt\", value: subscription.createdAt });\n        }\n        if (subscription.expirationTime != null) {\n            await this.put(\"Options\", { key: \"subscriptionExpirationTime\", value: subscription.expirationTime });\n        }\n        else {\n            await this.remove(\"Options\", \"subscriptionExpirationTime\");\n        }\n    }\n    async getEmailProfile() {\n        const profileJson = await this.get(\"Ids\", \"emailProfile\");\n        if (profileJson) {\n            return EmailProfile.deserialize(profileJson);\n        }\n        else {\n            return new EmailProfile();\n        }\n    }\n    async setEmailProfile(emailProfile) {\n        if (emailProfile) {\n            await this.put(\"Ids\", { type: \"emailProfile\", id: emailProfile.serialize() });\n        }\n    }\n    async setProvideUserConsent(consent) {\n        await this.put(\"Options\", { key: \"userConsent\", value: consent });\n    }\n    async getProvideUserConsent() {\n        return await this.get(\"Options\", \"userConsent\");\n    }\n    async getSession(sessionKey) {\n        return await this.get(\"Sessions\", sessionKey);\n    }\n    async setSession(session) {\n        await this.put(\"Sessions\", session);\n    }\n    async removeSession(sessionKey) {\n        await this.remove(\"Sessions\", sessionKey);\n    }\n    async getLastNotificationClicked(appId) {\n        let allClickedNotifications = [];\n        try {\n            allClickedNotifications = await this.getAll(\"NotificationClicked\");\n        }\n        catch (e) {\n            Log.error(\"Database.getNotificationClickedByUrl\", e);\n        }\n        const predicate = (notification) => notification.appId === appId;\n        return allClickedNotifications.find(predicate) || null;\n    }\n    async getNotificationClickedByUrl(url, appId) {\n        let allClickedNotifications = [];\n        try {\n            allClickedNotifications = await this.getAll(\"NotificationClicked\");\n        }\n        catch (e) {\n            Log.error(\"Database.getNotificationClickedByUrl\", e);\n        }\n        const predicate = (notification) => {\n            if (notification.appId !== appId) {\n                return false;\n            }\n            return new URL(url).origin === new URL(notification.url).origin;\n        };\n        return allClickedNotifications.find(predicate) || null;\n    }\n    async getNotificationClickedById(notificationId) {\n        return await this.get(\"NotificationClicked\", notificationId);\n    }\n    async getNotificationReceivedById(notificationId) {\n        return await this.get(\"NotificationReceived\", notificationId);\n    }\n    async removeNotificationClickedById(notificationId) {\n        await this.remove(\"NotificationClicked\", notificationId);\n    }\n    async removeAllNotificationClicked() {\n        await this.remove(\"NotificationClicked\");\n    }\n    async resetSentUniqueOutcomes() {\n        const outcomes = await this.getAll(\"SentUniqueOutcome\");\n        const promises = outcomes.map(o => {\n            o.sentDuringSession = null;\n            return Database.put(\"SentUniqueOutcome\", o);\n        });\n        await Promise.all(promises);\n    }\n    /**\n     * Asynchronously removes the Ids, NotificationOpened, and Options tables from the database and recreates them with blank values.\n     * @returns {Promise} Returns a promise that is fulfilled when rebuilding is completed, or rejects with an error.\n     */\n    static async rebuild() {\n        return Promise.all([\n            Database.singletonInstance.remove(\"Ids\"),\n            Database.singletonInstance.remove(\"NotificationOpened\"),\n            Database.singletonInstance.remove(\"Options\"),\n            Database.singletonInstance.remove(\"NotificationReceived\"),\n            Database.singletonInstance.remove(\"NotificationClicked\"),\n            Database.singletonInstance.remove(\"SentUniqueOutcome\")\n        ]);\n    }\n    // START: Static mappings to instance methods\n    static async on(...args) {\n        return Database.singletonInstance.emitter.on.apply(Database.singletonInstance.emitter, args);\n    }\n    static async getCurrentSession() {\n        return await Database.singletonInstance.getSession(ONESIGNAL_SESSION_KEY);\n    }\n    static async upsertSession(session) {\n        await Database.singletonInstance.setSession(session);\n    }\n    static async cleanupCurrentSession() {\n        await Database.singletonInstance.removeSession(ONESIGNAL_SESSION_KEY);\n    }\n    static async setEmailProfile(emailProfile) {\n        return await Database.singletonInstance.setEmailProfile(emailProfile);\n    }\n    static async getEmailProfile() {\n        return await Database.singletonInstance.getEmailProfile();\n    }\n    static async setSubscription(subscription) {\n        return await Database.singletonInstance.setSubscription(subscription);\n    }\n    static async getSubscription() {\n        return await Database.singletonInstance.getSubscription();\n    }\n    static async setProvideUserConsent(consent) {\n        return await Database.singletonInstance.setProvideUserConsent(consent);\n    }\n    static async getProvideUserConsent() {\n        return await Database.singletonInstance.getProvideUserConsent();\n    }\n    static async setServiceWorkerState(workerState) {\n        return await Database.singletonInstance.setServiceWorkerState(workerState);\n    }\n    static async getServiceWorkerState() {\n        return await Database.singletonInstance.getServiceWorkerState();\n    }\n    static async setAppState(appState) {\n        return await Database.singletonInstance.setAppState(appState);\n    }\n    static async getAppState() {\n        return await Database.singletonInstance.getAppState();\n    }\n    static async setAppConfig(appConfig) {\n        return await Database.singletonInstance.setAppConfig(appConfig);\n    }\n    static async getAppConfig() {\n        return await Database.singletonInstance.getAppConfig();\n    }\n    static async getExternalUserId() {\n        return await Database.singletonInstance.getExternalUserId();\n    }\n    static async getLastNotificationClicked(appId) {\n        return await Database.singletonInstance.getLastNotificationClicked(appId);\n    }\n    static async removeNotificationClickedById(notificationId) {\n        return await Database.singletonInstance.removeNotificationClickedById(notificationId);\n    }\n    static async removeAllNotificationClicked() {\n        return await Database.singletonInstance.removeAllNotificationClicked();\n    }\n    static async resetSentUniqueOutcomes() {\n        return await Database.singletonInstance.resetSentUniqueOutcomes();\n    }\n    static async getNotificationClickedByUrl(url, appId) {\n        return await Database.singletonInstance.getNotificationClickedByUrl(url, appId);\n    }\n    static async getNotificationClickedById(notificationId) {\n        return await Database.singletonInstance.getNotificationClickedById(notificationId);\n    }\n    static async getNotificationReceivedById(notificationId) {\n        return await Database.singletonInstance.getNotificationReceivedById(notificationId);\n    }\n    static async setExternalUserId(externalUserId) {\n        await Database.singletonInstance.setExternalUserId(externalUserId);\n    }\n    static async setDeviceId(deviceId) {\n        await Database.singletonInstance.setDeviceId(deviceId);\n    }\n    static async remove(table, keypath) {\n        return await Database.singletonInstance.remove(table, keypath);\n    }\n    static async put(table, keypath) {\n        return await Database.singletonInstance.put(table, keypath);\n    }\n    static async get(table, key) {\n        return await Database.singletonInstance.get(table, key);\n    }\n    static async getAll(table) {\n        return await Database.singletonInstance.getAll(table);\n    }\n}\n/* End Temp Database Proxy */\nDatabase.EVENTS = DatabaseEventName;\n//# sourceMappingURL=Database.js.map","export default class Log {\n    static debug(...args) {\n        if (!!self.shouldLog) {\n            console.debug(...args);\n        }\n    }\n    static trace(...args) {\n        if (!!self.shouldLog) {\n            console.trace(...args);\n        }\n    }\n    static info(...args) {\n        if (!!self.shouldLog) {\n            console.info(...args);\n        }\n    }\n    static warn(...args) {\n        if (!!self.shouldLog) {\n            console.warn(...args);\n        }\n    }\n    static error(...args) {\n        if (!!self.shouldLog) {\n            console.error(...args);\n        }\n    }\n}\n//# sourceMappingURL=Log.js.map","export var WindowEnvironmentKind;\n(function (WindowEnvironmentKind) {\n    /**\n     * A service worker environment.\n     */\n    WindowEnvironmentKind[\"ServiceWorker\"] = \"ServiceWorker\";\n    /**\n     * The top-level frame to the \"main\" client's site.\n     */\n    WindowEnvironmentKind[\"Host\"] = \"Host\";\n    /**\n     * Our subscription popup for alt-origin sites.\n     */\n    WindowEnvironmentKind[\"OneSignalSubscriptionPopup\"] = \"Popup\";\n    /**\n     * Our subscription modal for HTTPS sites, which loads in an iFrame.\n     */\n    WindowEnvironmentKind[\"OneSignalSubscriptionModal\"] = \"Modal\";\n    /**\n     * Our subscription helper iFrame.\n     */\n    WindowEnvironmentKind[\"OneSignalProxyFrame\"] = \"ProxyFrame\";\n    /**\n     * A custom iFrame on the site.\n     */\n    WindowEnvironmentKind[\"CustomIframe\"] = \"CustomFrame\";\n    /**\n     * An unknown window context type not matching any of the above.\n     */\n    WindowEnvironmentKind[\"Unknown\"] = \"Unknown\";\n})(WindowEnvironmentKind || (WindowEnvironmentKind = {}));\n//# sourceMappingURL=WindowEnvironmentKind.js.map","/**\n * Build Environment Kind\n */\nexport var EnvironmentKind;\n(function (EnvironmentKind) {\n    EnvironmentKind[\"Development\"] = \"Development\";\n    EnvironmentKind[\"Staging\"] = \"Staging\";\n    EnvironmentKind[\"Production\"] = \"Production\";\n})(EnvironmentKind || (EnvironmentKind = {}));\n//# sourceMappingURL=EnvironmentKind.js.map","import { EnvironmentKind } from '../models/EnvironmentKind';\nimport { TestEnvironmentKind } from '../models/TestEnvironmentKind';\nimport { WindowEnvironmentKind } from '../models/WindowEnvironmentKind';\nimport { InvalidArgumentError, InvalidArgumentReason } from '../errors/InvalidArgumentError';\nimport { IntegrationKind } from \"../models/IntegrationKind\";\nimport ServiceWorkerHelper from \"../helpers/ServiceWorkerHelper\";\nimport Environment from \"../Environment\";\nimport OneSignalUtils from \"../utils/OneSignalUtils\";\nconst RESOURCE_HTTP_PORT = 4000;\nconst RESOURCE_HTTPS_PORT = 4001;\nconst API_URL_PORT = 3001;\nconst TURBINE_API_URL_PORT = 18080;\nconst TURBINE_ENDPOINTS = [\"outcomes\", \"on_focus\"];\nexport default class SdkEnvironment {\n    /**\n     * Returns development, staging, or production.\n     *\n     * The magic constants used to detect the environment is set or unset when\n     * building the SDK.\n     */\n    static getBuildEnv() {\n        if (typeof __BUILD_TYPE__ === \"undefined\") {\n            return EnvironmentKind.Production;\n        }\n        switch (__BUILD_TYPE__) {\n            case \"development\":\n                return EnvironmentKind.Development;\n            case \"staging\":\n                return EnvironmentKind.Staging;\n            case \"production\":\n                return EnvironmentKind.Production;\n            default:\n                return EnvironmentKind.Production;\n        }\n    }\n    /**\n     * Returns development staging, or production.\n     *\n     * Refers to which API environment should be used. These constants are set when building the SDK\n     */\n    static getApiEnv() {\n        if (typeof __API_TYPE__ === \"undefined\") {\n            return EnvironmentKind.Production;\n        }\n        switch (__API_TYPE__) {\n            case \"development\":\n                return EnvironmentKind.Development;\n            case \"staging\":\n                return EnvironmentKind.Staging;\n            case \"production\":\n                return EnvironmentKind.Production;\n            default:\n                return EnvironmentKind.Production;\n        }\n    }\n    /**\n     * Determines whether the current frame context executing this function is part of a:\n     *\n     *  a) HTTP site using a proxy subscription origin\n     *\n     *  b) or, HTTPS site using a proxy subscription origin\n     *\n     *  c) or, HTTPS site using its own origin for subscribing\n     *\n     * The determination affects permissions and subscription:\n     *\n     *  a) Because the parent (top frame) of the proxy origin frame is HTTP, the entire context is\n     *  insecure. In the proxy origin frame, notification permissions are always \"denied\", access to\n     *  the service worker's registration throws a security error, and no service worker controls the\n     *  proxy origin frame.\n     *\n     *  b) The context is secure. In the proxy origin frame, notification permissions are \"granted\" if\n     *  actually granted otherwise \"denied\" if either unprompted or blocked. The service worker\n     *  controls the proxy origin frame and access to the service worker's registration is allowed.\n     *  Requesting permissions from child frames is not allowed. Subscribing from child frames wasn't\n     *  allowed but is now allowed.\n     *\n     *  c) All features are allowed.\n     *\n     * @param usingProxyOrigin Using a subdomain of os.tc or onesignal.com for subscribing to push.\n     */\n    static async getIntegration(usingProxyOrigin) {\n        if (Environment.isSafari()) {\n            /* HTTP doesn't apply to Safari sites */\n            return IntegrationKind.Secure;\n        }\n        const isTopFrame = (window === window.top);\n        const isHttpsProtocol = window.location.protocol === \"https:\";\n        // For convenience, try to look up usingProxyOrigin instead of requiring it to be passed in\n        if (usingProxyOrigin === undefined) {\n            if (typeof OneSignal !== \"undefined\" && OneSignal.context && OneSignal.context.appConfig) {\n                usingProxyOrigin = !!OneSignal.context.appConfig.subdomain;\n            }\n            else {\n                throw new InvalidArgumentError(\"usingProxyOrigin\", InvalidArgumentReason.Empty);\n            }\n        }\n        /*\n          Executing from the top frame, we can easily determine whether we're HTTPS or HTTP.\n    \n          Executing from a child frame of any depth, we can check the current frame's protocol. If it's\n          HTTP it's definitely insecure. If it's HTTPS, we attempt to call\n          ServiceWorkerContainer.getRegistration and see if the call throws an error or succeeds. If the\n          call throws an error, we can assume some parent frame in the chain above us is insecure.\n         */\n        if (isTopFrame) {\n            if (isHttpsProtocol) {\n                return usingProxyOrigin ?\n                    IntegrationKind.SecureProxy :\n                    IntegrationKind.Secure;\n            }\n            else {\n                // If localhost and allowLocalhostAsSecureOrigin, it's still considered secure\n                if (OneSignalUtils.isLocalhostAllowedAsSecureOrigin() &&\n                    (location.hostname === 'localhost' || location.hostname === '127.0.0.1')) {\n                    return IntegrationKind.Secure;\n                }\n                /* The case of HTTP and not using a proxy origin isn't possible, because the SDK will throw\n                an initialization error stating a proxy origin is required for HTTP sites. */\n                return IntegrationKind.InsecureProxy;\n            }\n        }\n        else {\n            if (isHttpsProtocol) {\n                /* Check whether any parent frames are insecure */\n                const isFrameContextInsecure = await SdkEnvironment.isFrameContextInsecure();\n                if (isFrameContextInsecure) {\n                    return IntegrationKind.InsecureProxy;\n                }\n                else {\n                    return usingProxyOrigin ?\n                        IntegrationKind.SecureProxy :\n                        IntegrationKind.Secure;\n                }\n            }\n            else {\n                /*\n                Because this frame is insecure, the entire chain is insecure.\n        \n                The case of HTTP and not using a proxy origin isn't possible, because the SDK will throw an\n                initialization error stating a proxy origin is required for HTTP sites. */\n                return IntegrationKind.InsecureProxy;\n            }\n        }\n    }\n    /**\n     * From a child frame, returns true if the current frame context is insecure.\n     *\n     * This is used to check if isPushNotificationsEnabled() should grab the service worker\n     * registration. In an HTTPS iframe of an HTTP page, getting the service worker registration would\n     * throw an error.\n     *\n     * This method can trigger console warnings due to using ServiceWorkerContainer.getRegistration in\n     * an insecure frame.\n     */\n    static async isFrameContextInsecure() {\n        // If we are the top frame, or service workers aren't available, don't run this check\n        if (window === window.top ||\n            !('serviceWorker' in navigator) ||\n            typeof navigator.serviceWorker.getRegistration === 'undefined') {\n            return false;\n        }\n        // Will be null if there was an issue retrieving a status\n        const registrationResult = await ServiceWorkerHelper.getRegistration();\n        return !registrationResult;\n    }\n    static isInsecureOrigin() {\n        return window.location.protocol === \"http:\";\n    }\n    static getOrigin() {\n        if (Environment.isBrowser()) {\n            return window.location.origin;\n        }\n        else if (typeof self !== \"undefined\" && typeof ServiceWorkerGlobalScope !== \"undefined\") {\n            return self.registration.scope;\n        }\n        return \"Unknown\";\n    }\n    /**\n     * Describes the current frame context.\n     */\n    static getWindowEnv() {\n        if (typeof window === \"undefined\") {\n            if (typeof self !== \"undefined\" && typeof ServiceWorkerGlobalScope !== \"undefined\") {\n                return WindowEnvironmentKind.ServiceWorker;\n            }\n            else {\n                return WindowEnvironmentKind.Unknown;\n            }\n        }\n        else {\n            // If the window is the root top-most level\n            if (window === window.top) {\n                if (location.href.indexOf(\"initOneSignal\") !== -1 ||\n                    (location.pathname === '/subscribe' &&\n                        location.search === '') &&\n                        (location.hostname.endsWith('.onesignal.com') ||\n                            location.hostname.endsWith('.os.tc') ||\n                            (location.hostname.indexOf('.localhost') !== -1 &&\n                                SdkEnvironment.getBuildEnv() === EnvironmentKind.Development))) {\n                    return WindowEnvironmentKind.OneSignalSubscriptionPopup;\n                }\n                else {\n                    return WindowEnvironmentKind.Host;\n                }\n            }\n            else if (location.pathname === '/webPushIframe') {\n                return WindowEnvironmentKind.OneSignalProxyFrame;\n            }\n            else if (location.pathname === '/webPushModal') {\n                return WindowEnvironmentKind.OneSignalSubscriptionModal;\n            }\n            else {\n                return WindowEnvironmentKind.CustomIframe;\n            }\n        }\n    }\n    /**\n     * Describes whether the SDK is built in tests mode or not.\n     *\n     * This method is overriden when tests are run.\n     */\n    static getTestEnv() {\n        return typeof __TEST__ === \"undefined\" ?\n            TestEnvironmentKind.UnitTesting :\n            TestEnvironmentKind.None;\n    }\n    /**\n     * Returns build-specific prefixes used for operations like registering the\n     * service worker.\n     *\n     * For example, in staging the registered service worker filename is\n     * Staging-OneSignalSDKWorker.js.\n     */\n    static getBuildEnvPrefix(buildEnv = SdkEnvironment.getBuildEnv()) {\n        switch (buildEnv) {\n            case EnvironmentKind.Development:\n                return 'Dev-';\n            case EnvironmentKind.Staging:\n                return 'Staging-';\n            case EnvironmentKind.Production:\n                return '';\n            default:\n                throw new InvalidArgumentError('buildEnv', InvalidArgumentReason.EnumOutOfRange);\n        }\n    }\n    /**\n     * Returns the URL object representing the components of OneSignal's API\n     * endpoint.\n     */\n    static getOneSignalApiUrl(buildEnv = SdkEnvironment.getApiEnv(), action) {\n        const apiOrigin = (typeof __API_ORIGIN__ !== \"undefined\") ? __API_ORIGIN__ || \"localhost\" : \"localhost\";\n        switch (buildEnv) {\n            case EnvironmentKind.Development:\n                if (SdkEnvironment.isTurbineEndpoint(action)) {\n                    return new URL(`https://${apiOrigin}:${TURBINE_API_URL_PORT}/api/v1`);\n                }\n                return new URL(`https://${apiOrigin}:${API_URL_PORT}/api/v1`);\n            case EnvironmentKind.Staging:\n                return new URL(`https://${apiOrigin}/api/v1`);\n            case EnvironmentKind.Production:\n                return new URL('https://onesignal.com/api/v1');\n            default:\n                throw new InvalidArgumentError('buildEnv', InvalidArgumentReason.EnumOutOfRange);\n        }\n    }\n    static getOneSignalResourceUrlPath(buildEnv = SdkEnvironment.getBuildEnv()) {\n        const buildOrigin = (typeof __BUILD_ORIGIN__ !== \"undefined\") ? __BUILD_ORIGIN__ || \"localhost\" : \"localhost\";\n        const isHttps = (typeof __IS_HTTPS__ !== \"undefined\") ? __IS_HTTPS__ : true;\n        let origin;\n        const protocol = isHttps ? \"https\" : \"http\";\n        const port = isHttps ? RESOURCE_HTTPS_PORT : RESOURCE_HTTP_PORT;\n        switch (buildEnv) {\n            case EnvironmentKind.Development:\n                origin = `${protocol}://${buildOrigin}:${port}`;\n                break;\n            case EnvironmentKind.Staging:\n                origin = `https://${buildOrigin}`;\n                break;\n            case EnvironmentKind.Production:\n                origin = \"https://onesignal.com\";\n                break;\n            default:\n                throw new InvalidArgumentError('buildEnv', InvalidArgumentReason.EnumOutOfRange);\n        }\n        return new URL(`${origin}/sdks`);\n    }\n    static getOneSignalCssFileName(buildEnv = SdkEnvironment.getBuildEnv()) {\n        const baseFileName = \"OneSignalSDKStyles.css\";\n        switch (buildEnv) {\n            case EnvironmentKind.Development:\n                return `Dev-${baseFileName}`;\n            case EnvironmentKind.Staging:\n                return `Staging-${baseFileName}`;\n            case EnvironmentKind.Production:\n                return baseFileName;\n            default:\n                throw new InvalidArgumentError('buildEnv', InvalidArgumentReason.EnumOutOfRange);\n        }\n    }\n    static isTurbineEndpoint(action) {\n        if (!action) {\n            return false;\n        }\n        return TURBINE_ENDPOINTS.some(turbine_endpoint => action.indexOf(turbine_endpoint) > -1);\n    }\n}\n//# sourceMappingURL=SdkEnvironment.js.map","import { InvalidArgumentError, InvalidArgumentReason } from '../errors/InvalidArgumentError';\nimport SdkEnvironment from '../managers/SdkEnvironment';\nimport { ServiceWorkerActiveState } from '../helpers/ServiceWorkerHelper';\nimport { WindowEnvironmentKind } from '../models/WindowEnvironmentKind';\nimport Environment from '../Environment';\nimport Log from './Log';\n/**\n * NOTE: This file contains a mix of code that runs in ServiceWorker and Page contexts\n*/\nexport var WorkerMessengerCommand;\n(function (WorkerMessengerCommand) {\n    WorkerMessengerCommand[\"WorkerVersion\"] = \"GetWorkerVersion\";\n    WorkerMessengerCommand[\"Subscribe\"] = \"Subscribe\";\n    WorkerMessengerCommand[\"SubscribeNew\"] = \"SubscribeNew\";\n    WorkerMessengerCommand[\"AmpSubscriptionState\"] = \"amp-web-push-subscription-state\";\n    WorkerMessengerCommand[\"AmpSubscribe\"] = \"amp-web-push-subscribe\";\n    WorkerMessengerCommand[\"AmpUnsubscribe\"] = \"amp-web-push-unsubscribe\";\n    WorkerMessengerCommand[\"NotificationDisplayed\"] = \"notification.displayed\";\n    WorkerMessengerCommand[\"NotificationClicked\"] = \"notification.clicked\";\n    WorkerMessengerCommand[\"NotificationDismissed\"] = \"notification.dismissed\";\n    WorkerMessengerCommand[\"RedirectPage\"] = \"command.redirect\";\n    WorkerMessengerCommand[\"SessionUpsert\"] = \"os.session.upsert\";\n    WorkerMessengerCommand[\"SessionDeactivate\"] = \"os.session.deactivate\";\n    WorkerMessengerCommand[\"AreYouVisible\"] = \"os.page_focused_request\";\n    WorkerMessengerCommand[\"AreYouVisibleResponse\"] = \"os.page_focused_response\";\n    WorkerMessengerCommand[\"SetLogging\"] = \"os.set_sw_logging\";\n})(WorkerMessengerCommand || (WorkerMessengerCommand = {}));\nexport class WorkerMessengerReplyBuffer {\n    constructor() {\n        this.replies = {};\n    }\n    addListener(command, callback, onceListenerOnly) {\n        const record = { callback, onceListenerOnly };\n        const replies = this.replies[command.toString()];\n        if (replies)\n            replies.push(record);\n        else\n            this.replies[command.toString()] = [record];\n    }\n    findListenersForMessage(command) {\n        return this.replies[command.toString()] || [];\n    }\n    deleteListenerRecords(command) {\n        this.replies[command.toString()] = null;\n    }\n    deleteAllListenerRecords() {\n        this.replies = {};\n    }\n    deleteListenerRecord(command, targetRecord) {\n        const listenersForCommand = this.replies[command.toString()];\n        if (listenersForCommand == null)\n            return;\n        for (let listenerRecordIndex = listenersForCommand.length - 1; listenerRecordIndex >= 0; listenerRecordIndex--) {\n            const listenerRecord = listenersForCommand[listenerRecordIndex];\n            if (listenerRecord === targetRecord) {\n                listenersForCommand.splice(listenerRecordIndex, 1);\n            }\n        }\n    }\n}\n/**\n* A Promise-based PostMessage helper to ease back-and-forth replies between\n* service workers and window frames.\n*/\nexport class WorkerMessenger {\n    constructor(context, replies = new WorkerMessengerReplyBuffer()) {\n        this.context = context;\n        this.replies = replies;\n    }\n    /**\n     * Broadcasts a message from a service worker to all clients, including uncontrolled clients.\n     */\n    async broadcast(command, payload) {\n        if (SdkEnvironment.getWindowEnv() !== WindowEnvironmentKind.ServiceWorker)\n            return;\n        const clients = await self.clients.matchAll({ type: 'window', includeUncontrolled: true });\n        for (const client of clients) {\n            Log.debug(`[Worker Messenger] [SW -> Page] Broadcasting '${command.toString()}' to window client ${client.url}.`);\n            client.postMessage({\n                command: command,\n                payload: payload\n            });\n        }\n    }\n    /*\n      For pages:\n  \n        Sends a postMessage() to the service worker controlling the page.\n  \n        Waits until the service worker is controlling the page before sending the\n        message.\n     */\n    async unicast(command, payload, windowClient) {\n        const env = SdkEnvironment.getWindowEnv();\n        if (env === WindowEnvironmentKind.ServiceWorker) {\n            if (!windowClient) {\n                throw new InvalidArgumentError('windowClient', InvalidArgumentReason.Empty);\n            }\n            else {\n                Log.debug(`[Worker Messenger] [SW -> Page] Unicasting '${command.toString()}' to window client ${windowClient.url}.`);\n                windowClient.postMessage({\n                    command: command,\n                    payload: payload\n                });\n            }\n        }\n        else {\n            if (!(await this.isWorkerControllingPage())) {\n                Log.debug(\"[Worker Messenger] The page is not controlled by the service worker yet. Waiting...\", self.registration);\n            }\n            await this.waitUntilWorkerControlsPage();\n            Log.debug(`[Worker Messenger] [Page -> SW] Unicasting '${command.toString()}' to service worker.`);\n            this.directPostMessageToSW(command, payload);\n        }\n    }\n    directPostMessageToSW(command, payload) {\n        Log.debug(`[Worker Messenger] [Page -> SW] Direct command '${command.toString()}' to service worker.`);\n        navigator.serviceWorker.controller.postMessage({\n            command: command,\n            payload: payload\n        });\n    }\n    /**\n     * Due to https://github.com/w3c/ServiceWorker/issues/1156, listen() must\n     * synchronously add self.addEventListener('message') if we are running in the\n     * service worker.\n     *\n     * @param listenIfPageUncontrolled If true, begins listening for service\n     * worker messages even if the service worker does not control this page. This\n     * parameter is set to true on HTTPS iframes expecting service worker messages\n     * that live under an HTTP page.\n     */\n    async listen(listenIfPageUncontrolled) {\n        if (!Environment.supportsServiceWorkers())\n            return;\n        const env = SdkEnvironment.getWindowEnv();\n        if (env === WindowEnvironmentKind.ServiceWorker) {\n            self.addEventListener('message', this.onWorkerMessageReceivedFromPage.bind(this));\n            Log.debug('[Worker Messenger] Service worker is now listening for messages.');\n        }\n        else\n            await this.listenForPage(listenIfPageUncontrolled);\n    }\n    /**\n     * Listens for messages for the service worker.\n     *\n     * Waits until the service worker is controlling the page before listening for\n     * messages.\n     */\n    async listenForPage(listenIfPageUncontrolled) {\n        if (!listenIfPageUncontrolled) {\n            if (!(await this.isWorkerControllingPage())) {\n                Log.debug(`(${location.origin}) [Worker Messenger] The page is not controlled by the service worker yet. Waiting...`, self.registration);\n            }\n            await this.waitUntilWorkerControlsPage();\n            Log.debug(`(${location.origin}) [Worker Messenger] The page is now controlled by the service worker.`);\n        }\n        navigator.serviceWorker.addEventListener('message', this.onPageMessageReceivedFromServiceWorker.bind(this));\n        Log.debug(`(${location.origin}) [Worker Messenger] Page is now listening for messages.`);\n    }\n    onWorkerMessageReceivedFromPage(event) {\n        const data = event.data;\n        /* If this message doesn't contain our expected fields, discard the message */\n        /* The payload may be null. AMP web push sends commands to our service worker in the format:\n    \n           { command: \"amp-web-push-subscription-state\", payload: null }\n           { command: \"amp-web-push-unsubscribe\", payload: null }\n           { command: \"amp-web-push-subscribe\", payload: null }\n    \n        */\n        if (!data || !data.command) {\n            return;\n        }\n        const listenerRecords = this.replies.findListenersForMessage(data.command);\n        const listenersToRemove = [];\n        const listenersToCall = [];\n        Log.debug(`[Worker Messenger] Service worker received message:`, event.data);\n        for (let listenerRecord of listenerRecords) {\n            if (listenerRecord.onceListenerOnly) {\n                listenersToRemove.push(listenerRecord);\n            }\n            listenersToCall.push(listenerRecord);\n        }\n        for (let i = listenersToRemove.length - 1; i >= 0; i--) {\n            const listenerRecord = listenersToRemove[i];\n            this.replies.deleteListenerRecord(data.command, listenerRecord);\n        }\n        for (let listenerRecord of listenersToCall) {\n            listenerRecord.callback.apply(null, [data.payload]);\n        }\n    }\n    /*\n    Occurs when the page receives a message from the service worker.\n  \n    A map of callbacks is checked to see if anyone is listening to the specific\n    message topic. If no one is listening to the message, it is discarded;\n    otherwise, the listener callback is executed.\n    */\n    onPageMessageReceivedFromServiceWorker(event) {\n        const data = event.data;\n        /* If this message doesn't contain our expected fields, discard the message */\n        if (!data || !data.command) {\n            return;\n        }\n        const listenerRecords = this.replies.findListenersForMessage(data.command);\n        const listenersToRemove = [];\n        const listenersToCall = [];\n        Log.debug(`[Worker Messenger] Page received message:`, event.data);\n        for (let listenerRecord of listenerRecords) {\n            if (listenerRecord.onceListenerOnly) {\n                listenersToRemove.push(listenerRecord);\n            }\n            listenersToCall.push(listenerRecord);\n        }\n        for (let i = listenersToRemove.length - 1; i >= 0; i--) {\n            const listenerRecord = listenersToRemove[i];\n            this.replies.deleteListenerRecord(data.command, listenerRecord);\n        }\n        for (let listenerRecord of listenersToCall) {\n            listenerRecord.callback.apply(null, [data.payload]);\n        }\n    }\n    /*\n      Subscribes a callback to be notified every time a service worker sends a\n      message to the window frame with the specific command.\n     */\n    on(command, callback) {\n        this.replies.addListener(command, callback, false);\n    }\n    /*\n    Subscribes a callback to be notified the next time a service worker sends a\n    message to the window frame with the specific command.\n  \n    The callback is executed once at most.\n    */\n    once(command, callback) {\n        this.replies.addListener(command, callback, true);\n    }\n    /**\n      Unsubscribe a callback from being notified about service worker messages\n      with the specified command.\n     */\n    off(command) {\n        if (command) {\n            this.replies.deleteListenerRecords(command);\n        }\n        else {\n            this.replies.deleteAllListenerRecords();\n        }\n    }\n    /*\n      Service worker postMessage() communication relies on the property\n      navigator.serviceWorker.controller to be non-null. The controller property\n      references the active service worker controlling the page. Without this\n      property, there is no service worker to message.\n  \n      The controller property is set when a service worker has successfully\n      registered, installed, and activated a worker, and when a page isn't loaded\n      in a hard refresh mode bypassing the cache.\n  \n      It's possible for a service worker to take a second page load to be fully\n      activated.\n     */\n    async isWorkerControllingPage() {\n        const env = SdkEnvironment.getWindowEnv();\n        if (env === WindowEnvironmentKind.ServiceWorker)\n            return !!self.registration.active;\n        else {\n            const workerState = await this.context.serviceWorkerManager.getActiveState();\n            return workerState === ServiceWorkerActiveState.WorkerA ||\n                workerState === ServiceWorkerActiveState.WorkerB;\n        }\n    }\n    /**\n     * For pages, waits until one of our workers is activated.\n     *\n     * For service workers, waits until the registration is active.\n     */\n    async waitUntilWorkerControlsPage() {\n        return new Promise(async (resolve) => {\n            if (await this.isWorkerControllingPage())\n                resolve();\n            else {\n                const env = SdkEnvironment.getWindowEnv();\n                if (env === WindowEnvironmentKind.ServiceWorker) {\n                    self.addEventListener('activate', async (_e) => {\n                        if (await this.isWorkerControllingPage())\n                            resolve();\n                    });\n                }\n                else {\n                    navigator.serviceWorker.addEventListener('controllerchange', async (_e) => {\n                        if (await this.isWorkerControllingPage())\n                            resolve();\n                    });\n                }\n            }\n        });\n    }\n}\n//# sourceMappingURL=WorkerMessenger.js.map","import bowser from \"bowser\";\nimport SdkEnvironment from \"../managers/SdkEnvironment\";\nimport Environment from \"../Environment\";\nimport { WindowEnvironmentKind } from \"../models/WindowEnvironmentKind\";\nimport Log from \"../libraries/Log\";\nimport { Utils } from \"../context/shared/utils/Utils\";\nexport class OneSignalUtils {\n    static getBaseUrl() {\n        return location.origin;\n    }\n    static isLocalhostAllowedAsSecureOrigin() {\n        return (OneSignal.config &&\n            OneSignal.config.userConfig &&\n            OneSignal.config.userConfig.allowLocalhostAsSecureOrigin === true);\n    }\n    /**\n     * Returns true if web push subscription occurs on a subdomain of OneSignal.\n     * If true, our main IndexedDB is stored on the subdomain of onesignal.com, and not the user\"s site.\n     * @remarks\n     *   This method returns true if:\n     *     - The browser is not Safari\n     *         - Safari uses a different method of subscription and does not require our workaround\n     *     - The init parameters contain a subdomain (even if the protocol is HTTPS)\n     *         - HTTPS users using our subdomain workaround still have the main IndexedDB stored on our subdomain\n     *        - The protocol of the current webpage is http:\n     *   Exceptions are:\n     *     - Safe hostnames like localhost and 127.0.0.1\n     *          - Because we don\"t want users to get the wrong idea when testing on localhost that direct permission is supported on HTTP, we\"ll ignore these exceptions. HTTPS will always be required for direct permission\n     *        - We are already in popup or iFrame mode, or this is called from the service worker\n     */\n    static isUsingSubscriptionWorkaround() {\n        const windowEnv = SdkEnvironment.getWindowEnv();\n        if (!OneSignal.config) {\n            throw new Error(`(${windowEnv.toString()}) isUsingSubscriptionWorkaround() cannot be called until OneSignal.config exists.`);\n        }\n        if (bowser.safari) {\n            return false;\n        }\n        const allowLocalhostAsSecureOrigin = this.isLocalhostAllowedAsSecureOrigin();\n        return OneSignalUtils.internalIsUsingSubscriptionWorkaround(OneSignal.config.subdomain, allowLocalhostAsSecureOrigin);\n    }\n    static internalIsUsingSubscriptionWorkaround(subdomain, allowLocalhostAsSecureOrigin) {\n        if (bowser.safari) {\n            return false;\n        }\n        if (allowLocalhostAsSecureOrigin === true &&\n            (location.hostname === \"localhost\" || location.hostname === \"127.0.0.1\")) {\n            return false;\n        }\n        const windowEnv = SdkEnvironment.getWindowEnv();\n        return ((windowEnv === WindowEnvironmentKind.Host || windowEnv === WindowEnvironmentKind.CustomIframe) &&\n            (!!subdomain || location.protocol === \"http:\"));\n    }\n    static redetectBrowserUserAgent() {\n        // During testing, the browser object may be initialized before the userAgent is injected\n        if (bowser.name === \"\" && bowser.version === \"\") {\n            return bowser._detect(navigator.userAgent);\n        }\n        return bowser;\n    }\n    /**\n     * Returns true if the UUID is a string of 36 characters;\n     * @param uuid\n     * @returns {*|boolean}\n     */\n    static isValidUuid(uuid) {\n        return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/.test(uuid);\n    }\n    static getRandomUuid() {\n        let uuidStr = '';\n        const crypto = typeof window === 'undefined' ? global.crypto : window.crypto || window.msCrypto;\n        if (crypto) {\n            uuidStr = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n                var r = (crypto.getRandomValues(new Uint8Array(1))[0] % 16) | 0, v = c == 'x' ? r : (r & 0x3) | 0x8;\n                return v.toString(16);\n            });\n        }\n        else {\n            uuidStr = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n                var r = (Math.random() * 16) | 0, v = c == 'x' ? r : (r & 0x3) | 0x8;\n                return v.toString(16);\n            });\n        }\n        return uuidStr;\n    }\n    static logMethodCall(methodName, ...args) {\n        return Log.debug(`Called %c${methodName}(${args.map(Utils.stringify).join(', ')})`, Utils.getConsoleStyle('code'), '.');\n    }\n    static isHttps() {\n        if (OneSignalUtils.isSafari()) {\n            return window.location.protocol === \"https:\";\n        }\n        return !OneSignalUtils.isUsingSubscriptionWorkaround();\n    }\n    static isSafari() {\n        return Environment.isBrowser() && typeof window.safari !== \"undefined\";\n    }\n}\nexport default OneSignalUtils;\n//# sourceMappingURL=OneSignalUtils.js.map","import { OutcomeAttributionType } from '../../models/Outcomes';\nimport Database from \"../../services/Database\";\nimport Log from \"../../libraries/Log\";\nimport { Utils } from \"../../context/shared/utils/Utils\";\nimport { logMethodCall, awaitOneSignalInitAndSupported } from '../../utils';\nconst SEND_OUTCOME = \"sendOutcome\";\nconst SEND_UNIQUE_OUTCOME = \"sendUniqueOutcome\";\nexport default class OutcomesHelper {\n    /**\n     * @param  {string} appId\n     * @param  {OutcomesConfig} config - refers specifically to outcomes config\n     * @param  {boolean} isUnique\n     * @param  {string} outcomeName\n     */\n    constructor(appId, config, outcomeName, isUnique) {\n        this.outcomeName = outcomeName;\n        this.config = config;\n        this.appId = appId;\n        this.isUnique = isUnique;\n    }\n    /**\n     * Returns `OutcomeAttribution` object which includes\n     *    1) attribution type\n     *    2) notification ids\n     *\n     * Note: this just looks at notifications that fall within the attribution window and\n     *       does not check if they have been previously attributed (used in both sendOutcome & sendUniqueOutcome)\n     * @returns Promise\n     */\n    async getAttribution() {\n        return await OutcomesHelper.getAttribution(this.config);\n    }\n    /**\n     * Performs logging of method call and returns whether Outcomes are supported\n     * @param  {boolean} isUnique\n     * @returns Promise\n     */\n    async beforeOutcomeSend() {\n        const outcomeMethodString = this.isUnique ? SEND_UNIQUE_OUTCOME : SEND_OUTCOME;\n        logMethodCall(outcomeMethodString, this.outcomeName);\n        if (!this.config) {\n            Log.debug(\"Outcomes feature not supported by main application yet.\");\n            return false;\n        }\n        if (!this.outcomeName) {\n            Log.error(\"Outcome name is required\");\n            return false;\n        }\n        await awaitOneSignalInitAndSupported();\n        const isSubscribed = await OneSignal.privateIsPushNotificationsEnabled();\n        if (!isSubscribed) {\n            Log.warn(\"Reporting outcomes is supported only for subscribed users.\");\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Returns array of notification ids outcome is currently attributed with\n     * @param  {string} outcomeName\n     * @returns Promise\n     */\n    async getAttributedNotifsByUniqueOutcomeName() {\n        const sentOutcomes = await Database.getAll(\"SentUniqueOutcome\");\n        return sentOutcomes\n            .filter(o => o.outcomeName === this.outcomeName)\n            .reduce((acc, curr) => {\n            const notificationIds = curr.notificationIds || [];\n            return [...acc, ...notificationIds];\n        }, []);\n    }\n    /**\n     * Returns array of new notifications that have never been attributed to the outcome\n     * @param  {string} outcomeName\n     * @param  {string[]} notificationIds\n     */\n    async getNotifsToAttributeWithUniqueOutcome(notificationIds) {\n        const previouslyAttributedArr = await this.getAttributedNotifsByUniqueOutcomeName();\n        return notificationIds.filter(id => (previouslyAttributedArr.indexOf(id) === -1));\n    }\n    shouldSendUnique(outcomeAttribution, notifArr) {\n        // we should only send if type is unattributed OR there are notifs to attribute\n        if (outcomeAttribution.type === OutcomeAttributionType.Unattributed) {\n            return true;\n        }\n        return notifArr.length > 0;\n    }\n    async saveSentUniqueOutcome(newNotificationIds) {\n        const outcomeName = this.outcomeName;\n        const existingSentOutcome = await Database.get(\"SentUniqueOutcome\", outcomeName);\n        const currentSession = await Database.getCurrentSession();\n        const existingNotificationIds = !!existingSentOutcome ? existingSentOutcome.notificationIds : [];\n        const notificationIds = [...existingNotificationIds, ...newNotificationIds];\n        const timestamp = currentSession ? currentSession.startTimestamp : null;\n        await Database.put(\"SentUniqueOutcome\", {\n            outcomeName,\n            notificationIds,\n            sentDuringSession: timestamp\n        });\n    }\n    async wasSentDuringSession() {\n        const sentOutcome = await Database.get(\"SentUniqueOutcome\", this.outcomeName);\n        if (!sentOutcome) {\n            return false;\n        }\n        const session = await Database.getCurrentSession();\n        const sessionExistsAndWasPreviouslySent = session && sentOutcome.sentDuringSession === session.startTimestamp;\n        const sessionWasClearedButWasPreviouslySent = !session && !!sentOutcome.sentDuringSession;\n        return sessionExistsAndWasPreviouslySent || sessionWasClearedButWasPreviouslySent;\n    }\n    async send(outcomeProps) {\n        const { type, notificationIds, weight } = outcomeProps;\n        switch (type) {\n            case OutcomeAttributionType.Direct:\n                if (this.isUnique) {\n                    await this.saveSentUniqueOutcome(notificationIds);\n                }\n                await OneSignal.context.updateManager.sendOutcomeDirect(this.appId, notificationIds, this.outcomeName, weight);\n                return;\n            case OutcomeAttributionType.Indirect:\n                if (this.isUnique) {\n                    await this.saveSentUniqueOutcome(notificationIds);\n                }\n                await OneSignal.context.updateManager.sendOutcomeInfluenced(this.appId, notificationIds, this.outcomeName, weight);\n                return;\n            case OutcomeAttributionType.Unattributed:\n                if (this.isUnique) {\n                    if (await this.wasSentDuringSession()) {\n                        Log.warn(`(Unattributed) unique outcome was already sent during this session`);\n                        return;\n                    }\n                    await this.saveSentUniqueOutcome([]);\n                }\n                await OneSignal.context.updateManager.sendOutcomeUnattributed(this.appId, this.outcomeName, weight);\n                return;\n            default:\n                Log.warn(\"You are on a free plan. Please upgrade to use this functionality.\");\n                return;\n        }\n    }\n    // statics\n    /**\n     * Static method: returns `OutcomeAttribution` object which includes\n     *    1) attribution type\n     *    2) notification ids\n     *\n     * Note: this just looks at notifications that fall within the attribution window and\n     *       does not check if they have been previously attributed (used in both sendOutcome & sendUniqueOutcome)\n     * @param  {OutcomesConfig} config\n     * @returns Promise\n     */\n    static async getAttribution(config) {\n        /**\n         * Flow:\n         * 1. check if the url was opened as a result of a notif;\n         * 2. if so, send an api call reporting direct notification outcome\n         *    (currently takes into account the match strategy selected in the app's settings);\n         * 3. else check all received notifs within timeframe from config;\n         * 4. send an api call reporting an influenced outcome for each matching notification\n         *    respecting the limit from config too;\n         * 5. if no influencing notification found, report unattributed outcome to the api.\n         */\n        /* direct notifications */\n        if (config.direct && config.direct.enabled) {\n            const clickedNotifications = await Database.getAll(\"NotificationClicked\");\n            if (clickedNotifications.length > 0) {\n                return {\n                    type: OutcomeAttributionType.Direct,\n                    notificationIds: [clickedNotifications[0].notificationId]\n                };\n            }\n        }\n        /* influencing notifications */\n        if (config.indirect && config.indirect.enabled) {\n            const timeframeMs = config.indirect.influencedTimePeriodMin * 60 * 1000;\n            const beginningOfTimeframe = new Date(new Date().getTime() - timeframeMs);\n            const maxTimestamp = beginningOfTimeframe.getTime();\n            const allReceivedNotification = await Database.getAll(\"NotificationReceived\");\n            Log.debug(`\\tFound total of ${allReceivedNotification.length} received notifications`);\n            if (allReceivedNotification.length > 0) {\n                const max = config.indirect.influencedNotificationsLimit;\n                /**\n                 * To handle correctly the case when user got subscribed to a new app id\n                 * we check the appId on notifications to match the current app.\n                 */\n                const allReceivedNotificationSorted = Utils.sortArrayOfObjects(allReceivedNotification, (notif) => notif.timestamp, true, false);\n                const matchingNotificationIds = allReceivedNotificationSorted\n                    .filter(notif => notif.timestamp >= maxTimestamp)\n                    .slice(0, max)\n                    .map(notif => notif.notificationId);\n                Log.debug(`\\tTotal of ${matchingNotificationIds.length} received notifications are within reporting window.`);\n                // Deleting all unmatched received notifications\n                const notificationIdsToDelete = allReceivedNotificationSorted\n                    .filter(notif => matchingNotificationIds.indexOf(notif.notificationId) === -1)\n                    .map(notif => notif.notificationId);\n                notificationIdsToDelete.forEach(id => Database.remove(\"NotificationReceived\", id));\n                Log.debug(`\\t${notificationIdsToDelete.length} received notifications will be deleted.`);\n                if (matchingNotificationIds.length > 0) {\n                    return {\n                        type: OutcomeAttributionType.Indirect,\n                        notificationIds: matchingNotificationIds,\n                    };\n                }\n            }\n        }\n        /* unattributed outcome report */\n        if (config.unattributed && config.unattributed.enabled) {\n            return {\n                type: OutcomeAttributionType.Unattributed,\n                notificationIds: []\n            };\n        }\n        return {\n            type: OutcomeAttributionType.NotSupported,\n            notificationIds: [],\n        };\n    }\n}\n//# sourceMappingURL=OutcomesHelper.js.map","import { OneSignalApiSW } from \"../OneSignalApiSW\";\nimport Log from \"../libraries/sw/Log\";\nimport { initializeNewSession, SessionOrigin, SessionStatus } from \"../models/Session\";\nimport { InvalidStateError, InvalidStateReason } from \"../errors/InvalidStateError\";\nimport { OneSignalUtils } from \"../utils/OneSignalUtils\";\nimport Database from \"../services/Database\";\nimport { PushDeviceRecord } from \"../models/PushDeviceRecord\";\nimport { RawPushSubscription } from '../models/RawPushSubscription';\nimport PageServiceWorkerHelper from \"./page/ServiceWorkerHelper\";\nimport OutcomesHelper from './shared/OutcomesHelper';\nimport { cancelableTimeout } from './sw/CancelableTimeout';\nexport default class ServiceWorkerHelper {\n    static async getRegistration() {\n        return await PageServiceWorkerHelper.getRegistration();\n    }\n    static getServiceWorkerHref(workerState, config) {\n        let workerFullPath = \"\";\n        // Determine which worker to install\n        if (workerState === ServiceWorkerActiveState.WorkerA)\n            workerFullPath = config.workerBPath.getFullPath();\n        else if (workerState === ServiceWorkerActiveState.WorkerB ||\n            workerState === ServiceWorkerActiveState.ThirdParty ||\n            workerState === ServiceWorkerActiveState.None)\n            workerFullPath = config.workerAPath.getFullPath();\n        else if (workerState === ServiceWorkerActiveState.Bypassed) {\n            /*\n              if the page is hard refreshed bypassing the cache, no service worker\n              will control the page.\n      \n              It doesn't matter if we try to reinstall an existing worker; still no\n              service worker will control the page after installation.\n             */\n            throw new InvalidStateError(InvalidStateReason.UnsupportedEnvironment);\n        }\n        return new URL(workerFullPath, OneSignalUtils.getBaseUrl()).href;\n    }\n    static async upsertSession(sessionThresholdInSeconds, sendOnFocusEnabled, deviceRecord, deviceId, sessionOrigin, outcomesConfig) {\n        if (!deviceId) {\n            Log.error(\"No deviceId provided for new session.\");\n            return;\n        }\n        if (!deviceRecord.app_id) {\n            Log.error(\"No appId provided for new session.\");\n            return;\n        }\n        const existingSession = await Database.getCurrentSession();\n        if (!existingSession) {\n            const appId = deviceRecord.app_id;\n            const session = initializeNewSession({ deviceId, appId, deviceType: deviceRecord.device_type });\n            // if there is a record about a clicked notification in our database, attribute session to it.\n            const clickedNotification = await Database.getLastNotificationClicked(appId);\n            if (clickedNotification) {\n                session.notificationId = clickedNotification.notificationId;\n            }\n            await Database.upsertSession(session);\n            await ServiceWorkerHelper.sendOnSessionCallIfNecessary(sessionOrigin, deviceRecord, deviceId, session);\n            return;\n        }\n        if (existingSession.status === SessionStatus.Active) {\n            Log.debug(\"Session already active\", existingSession);\n            return;\n        }\n        if (!existingSession.lastDeactivatedTimestamp) {\n            Log.debug(\"Session is in invalid state\", existingSession);\n            // TODO: possibly recover by re-starting session if deviceId is present?\n            return;\n        }\n        const currentTimestamp = new Date().getTime();\n        const timeSinceLastDeactivatedInSeconds = ServiceWorkerHelper.timeInSecondsBetweenTimestamps(currentTimestamp, existingSession.lastDeactivatedTimestamp);\n        if (timeSinceLastDeactivatedInSeconds <= sessionThresholdInSeconds) {\n            existingSession.status = SessionStatus.Active;\n            existingSession.lastActivatedTimestamp = currentTimestamp;\n            existingSession.lastDeactivatedTimestamp = null;\n            await Database.upsertSession(existingSession);\n            return;\n        }\n        // If failed to report/clean-up last time, we can attempt to try again here.\n        // TODO: Possibly check that it's not unreasonably long.\n        // TODO: Or couple with periodic ping for better results.\n        await ServiceWorkerHelper.finalizeSession(existingSession, sendOnFocusEnabled, outcomesConfig);\n        const session = initializeNewSession({ deviceId, appId: deviceRecord.app_id, deviceType: deviceRecord.device_type });\n        await Database.upsertSession(session);\n        await ServiceWorkerHelper.sendOnSessionCallIfNecessary(sessionOrigin, deviceRecord, deviceId, session);\n    }\n    static async deactivateSession(thresholdInSeconds, sendOnFocusEnabled, outcomesConfig) {\n        const existingSession = await Database.getCurrentSession();\n        if (!existingSession) {\n            Log.debug(\"No active session found. Cannot deactivate.\");\n            return undefined;\n        }\n        /**\n         * For 2 subsequent deactivate requests we need to make sure there is an active finalization timeout.\n         * Timer gets cleaned up before figuring out it's activate or deactivate.\n         * No update needed for the session, early return.\n         */\n        if (existingSession.status === SessionStatus.Inactive) {\n            return cancelableTimeout(() => ServiceWorkerHelper.finalizeSession(existingSession, sendOnFocusEnabled, outcomesConfig), thresholdInSeconds);\n        }\n        /**\n         * Can only be active or expired at this point, but more statuses may come in in the future.\n         * For anything but active, logging a warning and doing early return.\n         */\n        if (existingSession.status !== SessionStatus.Active) {\n            Log.warn(`Session in invalid state ${existingSession.status}. Cannot deactivate.`);\n            return undefined;\n        }\n        const currentTimestamp = new Date().getTime();\n        const timeSinceLastActivatedInSeconds = ServiceWorkerHelper.timeInSecondsBetweenTimestamps(currentTimestamp, existingSession.lastActivatedTimestamp);\n        existingSession.lastDeactivatedTimestamp = currentTimestamp;\n        existingSession.accumulatedDuration += timeSinceLastActivatedInSeconds;\n        existingSession.status = SessionStatus.Inactive;\n        const cancelableFinalize = cancelableTimeout(() => ServiceWorkerHelper.finalizeSession(existingSession, sendOnFocusEnabled, outcomesConfig), thresholdInSeconds);\n        await Database.upsertSession(existingSession);\n        return cancelableFinalize;\n    }\n    /**\n     * Sends on_session call on each new session initialization except the case\n     * when player create call occurs, e.g. first subscribed or re-subscribed cases after clearing cookies,\n     * since player#create call updates last_session field on player.\n     */\n    static async sendOnSessionCallIfNecessary(sessionOrigin, deviceRecord, deviceId, session) {\n        if (sessionOrigin === SessionOrigin.PlayerCreate) {\n            return;\n        }\n        if (!deviceRecord.identifier) {\n            const subscription = await self.registration.pushManager.getSubscription();\n            if (subscription) {\n                const rawPushSubscription = RawPushSubscription.setFromW3cSubscription(subscription);\n                const fullDeviceRecord = new PushDeviceRecord(rawPushSubscription).serialize();\n                deviceRecord.identifier = fullDeviceRecord.identifier;\n            }\n        }\n        const newPlayerId = await OneSignalApiSW.updateUserSession(deviceId, deviceRecord);\n        // If the returned player id is different, save the new id to indexed db and update session\n        if (newPlayerId !== deviceId) {\n            session.deviceId = newPlayerId;\n            await Promise.all([\n                Database.setDeviceId(newPlayerId),\n                Database.upsertSession(session),\n                Database.resetSentUniqueOutcomes()\n            ]);\n        }\n    }\n    static async finalizeSession(session, sendOnFocusEnabled, outcomesConfig) {\n        Log.debug(\"Finalize session\", `started: ${new Date(session.startTimestamp)}`, `duration: ${session.accumulatedDuration}s`);\n        if (sendOnFocusEnabled) {\n            Log.debug(`send on_focus reporting session duration -> ${session.accumulatedDuration}s`);\n            const attribution = await OutcomesHelper.getAttribution(outcomesConfig);\n            Log.debug(\"send on_focus with attribution\", attribution);\n            await OneSignalApiSW.sendSessionDuration(session.appId, session.deviceId, session.accumulatedDuration, session.deviceType, attribution);\n        }\n        await Promise.all([\n            Database.cleanupCurrentSession(),\n            Database.removeAllNotificationClicked()\n        ]);\n        Log.debug(\"Finalize session finished\", `started: ${new Date(session.startTimestamp)}`);\n    }\n    static timeInSecondsBetweenTimestamps(timestamp1, timestamp2) {\n        if (timestamp1 <= timestamp2) {\n            return 0;\n        }\n        return Math.floor((timestamp1 - timestamp2) / 1000);\n    }\n}\nexport var ServiceWorkerActiveState;\n(function (ServiceWorkerActiveState) {\n    /**\n     * OneSignalSDKWorker.js, or the equivalent custom file name, is active.\n     */\n    ServiceWorkerActiveState[\"WorkerA\"] = \"Worker A (Main)\";\n    /**\n     * OneSignalSDKUpdaterWorker.js, or the equivalent custom file name, is\n     * active.\n     *\n     * We no longer need to use this filename. We can update Worker A by appending\n     * a random query parameter to A.\n     */\n    ServiceWorkerActiveState[\"WorkerB\"] = \"Worker B (Updater)\";\n    /**\n     * A service worker is active, but it is neither OneSignalSDKWorker.js nor\n     * OneSignalSDKUpdaterWorker.js (or the equivalent custom file names as\n     * provided by user config).\n     */\n    ServiceWorkerActiveState[\"ThirdParty\"] = \"3rd Party\";\n    /**\n     * A service worker is currently installing and we can't determine its final state yet. Wait until\n     * the service worker is finished installing by checking for a controllerchange property..\n     */\n    ServiceWorkerActiveState[\"Installing\"] = \"Installing\";\n    /**\n     * No service worker is installed.\n     */\n    ServiceWorkerActiveState[\"None\"] = \"None\";\n    /**\n     * A service worker is active but not controlling the page. This can occur if\n     * the page is hard-refreshed bypassing the cache, which also bypasses service\n     * workers.\n     */\n    ServiceWorkerActiveState[\"Bypassed\"] = \"Bypassed\";\n    /**\n     * Service workers are not supported in this environment. This status is used\n     * on HTTP pages where it isn't possible to know whether a service worker is\n     * installed or not or in any of the other states.\n     */\n    ServiceWorkerActiveState[\"Indeterminate\"] = \"Indeterminate\";\n})(ServiceWorkerActiveState || (ServiceWorkerActiveState = {}));\n//# sourceMappingURL=ServiceWorkerHelper.js.map","import SdkEnvironment from './managers/SdkEnvironment';\nimport { WindowEnvironmentKind } from './models/WindowEnvironmentKind';\nimport bowser from 'bowser';\nexport default class Environment {\n    /**\n     * True if not in a service worker environment.\n     */\n    static isBrowser() {\n        return typeof window !== 'undefined';\n    }\n    static isSafari() {\n        return Environment.isBrowser() && bowser.safari;\n    }\n    static version() {\n        return (typeof __VERSION__ === \"undefined\" ? 1 : Number(__VERSION__));\n    }\n    static get TRADITIONAL_CHINESE_LANGUAGE_TAG() {\n        return ['tw', 'hant'];\n    }\n    static get SIMPLIFIED_CHINESE_LANGUAGE_TAG() {\n        return ['cn', 'hans'];\n    }\n    /* Specifications: https://tools.ietf.org/html/bcp47 */\n    static getLanguage() {\n        let languageTag = navigator.language;\n        if (languageTag) {\n            languageTag = languageTag.toLowerCase();\n            let languageSubtags = languageTag.split('-');\n            if (languageSubtags[0] == 'zh') {\n                // The language is zh-?\n                // We must categorize the language as either zh-Hans (simplified) or zh-Hant (traditional); OneSignal only supports these two Chinese variants\n                for (let traditionalSubtag of Environment.TRADITIONAL_CHINESE_LANGUAGE_TAG) {\n                    if (languageSubtags.indexOf(traditionalSubtag) !== -1) {\n                        return 'zh-Hant';\n                    }\n                }\n                for (let simpleSubtag of Environment.SIMPLIFIED_CHINESE_LANGUAGE_TAG) {\n                    if (languageSubtags.indexOf(simpleSubtag) !== -1) {\n                        return 'zh-Hans';\n                    }\n                }\n                return 'zh-Hant'; // Return Chinese traditional by default\n            }\n            else {\n                // Return the language subtag (it can be three characters, so truncate it down to 2 just to be sure)\n                return languageSubtags[0].substring(0, 2);\n            }\n        }\n        else {\n            return 'en';\n        }\n    }\n    static supportsServiceWorkers() {\n        const env = SdkEnvironment.getWindowEnv();\n        switch (env) {\n            case WindowEnvironmentKind.ServiceWorker:\n                return true;\n            default:\n                return typeof navigator !== \"undefined\" &&\n                    'serviceWorker' in navigator;\n        }\n    }\n    /*\n      Returns the MD5 hash of all stylesheets within the src/stylesheets\n      directory.\n     */\n    static getSdkStylesVersionHash() {\n        return (typeof __SRC_STYLESHEETS_MD5_HASH__ === \"undefined\" ? '2' : __SRC_STYLESHEETS_MD5_HASH__);\n    }\n}\n//# sourceMappingURL=Environment.js.map","export const SERVER_CONFIG_DEFAULTS_SESSION = {\n    reportingThreshold: 30,\n    enableOnSessionForUnsubcribed: false,\n    enableOnFocus: true,\n};\nexport const SERVER_CONFIG_DEFAULTS_PROMPT_DELAYS = {\n    pageViews: 1,\n    timeDelay: 0\n};\nexport const SERVER_CONFIG_DEFAULTS_SLIDEDOWN = {\n    actionMessage: \"We'd like to show you notifications for the latest news and updates.\",\n    acceptButton: \"Allow\",\n    cancelButton: \"Cancel\",\n    categoryDefaults: {\n        updateMessage: \"Update your push notification subscription preferences.\",\n        positiveUpdateButton: \"Save Preferences\",\n        negativeUpdateButton: \"Cancel\"\n    },\n    savingText: \"Saving...\",\n};\n//# sourceMappingURL=index.js.map","import SdkEnvironment from './managers/SdkEnvironment';\nimport { WindowEnvironmentKind } from './models/WindowEnvironmentKind';\nimport Database from './services/Database';\nimport Log from './libraries/Log';\nimport { OneSignalUtils } from './utils/OneSignalUtils';\nimport { PermissionUtils } from './utils/PermissionUtils';\nimport { BrowserUtils } from './utils/BrowserUtils';\nimport { Utils } from \"./context/shared/utils/Utils\";\nimport bowser from 'bowser';\nexport function isArray(variable) {\n    return Object.prototype.toString.call(variable) === '[object Array]';\n}\nexport function decodeHtmlEntities(text) {\n    return BrowserUtils.decodeHtmlEntities(text);\n}\nexport function removeDomElement(selector) {\n    var els = document.querySelectorAll(selector);\n    if (els.length > 0) {\n        for (let i = 0; i < els.length; i++) {\n            const parentNode = els[i].parentNode;\n            if (parentNode) {\n                parentNode.removeChild(els[i]);\n            }\n        }\n    }\n}\n/**\n * Helper method for public APIs that waits until OneSignal is initialized, rejects if push notifications are\n * not supported, and wraps these tasks in a Promise.\n */\nexport async function awaitOneSignalInitAndSupported() {\n    return new Promise(resolve => {\n        if (!OneSignal.initialized)\n            OneSignal.emitter.once(OneSignal.EVENTS.SDK_INITIALIZED, resolve);\n        else\n            resolve();\n    });\n}\n/**\n * Returns true if web push subscription occurs on a subdomain of OneSignal.\n * If true, our main IndexedDB is stored on the subdomain of onesignal.com, and not the user's site.\n * @remarks\n *   This method returns true if:\n *     - The browser is not Safari\n *         - Safari uses a different method of subscription and does not require our workaround\n *     - The init parameters contain a subdomain (even if the protocol is HTTPS)\n *         - HTTPS users using our subdomain workaround still have the main IndexedDB stored on our subdomain\n *        - The protocol of the current webpage is http:\n *   Exceptions are:\n *     - Safe hostnames like localhost and 127.0.0.1\n *          - Because we don't want users to get the wrong idea when testing on localhost that direct permission is supported on HTTP, we'll ignore these exceptions. HTTPS will always be required for direct permission\n *        - We are already in popup or iFrame mode, or this is called from the service worker\n */\nexport function isUsingSubscriptionWorkaround() {\n    return OneSignalUtils.isUsingSubscriptionWorkaround();\n}\nexport async function triggerNotificationPermissionChanged(updateIfIdentical = false) {\n    return PermissionUtils.triggerNotificationPermissionChanged(updateIfIdentical);\n}\n/**\n * JSON.stringify() but converts functions to \"[Function]\" so they aren't lost.\n * Helps when logging method calls.\n */\nexport function stringify(obj) {\n    return Utils.stringify(obj);\n}\nexport function executeCallback(callback, ...args) {\n    if (callback) {\n        return callback.apply(null, args);\n    }\n}\nexport function logMethodCall(methodName, ...args) {\n    return OneSignalUtils.logMethodCall(methodName, ...args);\n}\nexport function isValidEmail(email) {\n    return !!email &&\n        !!email.match(/(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])/);\n}\nexport function addDomElement(targetSelectorOrElement, addOrder, elementHtml) {\n    let targetElement;\n    if (typeof targetSelectorOrElement === 'string') {\n        targetElement = document.querySelector(targetSelectorOrElement);\n    }\n    else {\n        targetElement = targetSelectorOrElement;\n    }\n    if (targetElement) {\n        targetElement.insertAdjacentHTML(addOrder, elementHtml);\n        return;\n    }\n    throw new Error(`${targetSelectorOrElement} must be a CSS selector string or DOM Element object.`);\n}\nexport function clearDomElementChildren(targetSelectorOrElement) {\n    if (typeof targetSelectorOrElement === 'string') {\n        const element = document.querySelector(targetSelectorOrElement);\n        if (element === null) {\n            throw new Error(`Cannot find element with selector \"${targetSelectorOrElement}\"`);\n        }\n        while (element.firstChild) {\n            element.removeChild(element.firstChild);\n        }\n    }\n    else if (typeof targetSelectorOrElement === 'object') {\n        while (targetSelectorOrElement.firstChild) {\n            targetSelectorOrElement.removeChild(targetSelectorOrElement.firstChild);\n        }\n    }\n    else\n        throw new Error(`${targetSelectorOrElement} must be a CSS selector string or DOM Element object.`);\n}\nexport function addCssClass(targetSelectorOrElement, cssClass) {\n    if (typeof targetSelectorOrElement === 'string') {\n        const element = document.querySelector(targetSelectorOrElement);\n        if (element === null) {\n            throw new Error(`Cannot find element with selector \"${targetSelectorOrElement}\"`);\n        }\n        element.classList.add(cssClass);\n    }\n    else if (typeof targetSelectorOrElement === 'object') {\n        targetSelectorOrElement.classList.add(cssClass);\n    }\n    else {\n        throw new Error(`${targetSelectorOrElement} must be a CSS selector string or DOM Element object.`);\n    }\n}\nexport function removeCssClass(targetSelectorOrElement, cssClass) {\n    if (typeof targetSelectorOrElement === 'string') {\n        const element = document.querySelector(targetSelectorOrElement);\n        if (element === null) {\n            throw new Error(`Cannot find element with selector \"${targetSelectorOrElement}\"`);\n        }\n        element.classList.remove(cssClass);\n    }\n    else if (typeof targetSelectorOrElement === 'object') {\n        targetSelectorOrElement.classList.remove(cssClass);\n    }\n    else {\n        throw new Error(`${targetSelectorOrElement} must be a CSS selector string or DOM Element object.`);\n    }\n}\nexport function hasCssClass(targetSelectorOrElement, cssClass) {\n    if (typeof targetSelectorOrElement === 'string') {\n        const element = document.querySelector(targetSelectorOrElement);\n        if (element === null) {\n            throw new Error(`Cannot find element with selector \"${targetSelectorOrElement}\"`);\n        }\n        return element.classList.contains(cssClass);\n    }\n    else if (typeof targetSelectorOrElement === 'object') {\n        return targetSelectorOrElement.classList.contains(cssClass);\n    }\n    else {\n        throw new Error(`${targetSelectorOrElement} must be a CSS selector string or DOM Element object.`);\n    }\n}\n/**\n * var DEVICE_TYPES = {\n *  CHROME: 5,\n *  SAFARI: 7,\n *  FIREFOX: 8,\n *  EDGE: 12,\n *  UNKNOWN: -99\n * };\n */\nexport function getConsoleStyle(style) {\n    return Utils.getConsoleStyle(style);\n}\n/**\n * Returns a promise for the setTimeout() method.\n * @param durationMs\n * @returns {Promise} Returns a promise that resolves when the timeout is complete.\n */\nexport function delay(durationMs) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, durationMs);\n    });\n}\nexport function nothing() {\n    return Promise.resolve();\n}\nexport function timeoutPromise(promise, milliseconds) {\n    return Utils.timeoutPromise(promise, milliseconds);\n}\nexport function when(condition, promiseIfTrue, promiseIfFalse) {\n    if (promiseIfTrue === undefined)\n        promiseIfTrue = nothing();\n    if (promiseIfFalse === undefined)\n        promiseIfFalse = nothing();\n    return (condition ? promiseIfTrue : promiseIfFalse);\n}\n/**\n * Returns true if match is in string; otherwise, returns false.\n */\nexport function contains(indexOfAble, match) {\n    return Utils.contains(indexOfAble, match);\n}\n/**\n * Returns the current object without keys that have undefined values.\n * Regardless of whether the return result is used, the passed-in object is destructively modified.\n * Only affects keys that the object directly contains (i.e. not those inherited via the object's prototype).\n * @param object\n */\nexport function trimUndefined(object) {\n    return Utils.trimUndefined(object);\n}\nexport function getRandomUuid() {\n    return OneSignalUtils.getRandomUuid();\n}\n/**\n * Returns true if the UUID is a string of 36 characters;\n * @param uuid\n * @returns {*|boolean}\n */\nexport function isValidUuid(uuid) {\n    return OneSignalUtils.isValidUuid(uuid);\n}\nexport function getUrlQueryParam(name) {\n    let url = window.location.href;\n    url = url.toLowerCase(); // This is just to avoid case sensitiveness\n    name = name.replace(/[\\[\\]]/g, \"\\\\$&\").toLowerCase(); // This is just to avoid case sensitiveness for query parameter name\n    var regex = new RegExp(\"[?&]\" + name + \"(=([^&#]*)|&|#|$)\"), results = regex.exec(url);\n    if (!results)\n        return null;\n    if (!results[2])\n        return '';\n    return decodeURIComponent(results[2].replace(/\\+/g, \" \"));\n}\n/**\n * Wipe OneSignal-related IndexedDB data on the \"correct\" computed origin, but OneSignal must be initialized first to use.\n */\nexport function wipeIndexedDb() {\n    Log.warn('OneSignal: Wiping IndexedDB data.');\n    return Promise.all([\n        Database.remove('Ids'),\n        Database.remove('NotificationOpened'),\n        Database.remove('Options')\n    ]);\n}\n/**\n * Capitalizes the first letter of the string.\n * @returns {string} The string with the first letter capitalized.\n */\nexport function capitalize(text) {\n    return Utils.capitalize(text);\n}\n/**\n * Unsubscribe from push notifications without removing the active service worker.\n */\nexport function unsubscribeFromPush() {\n    Log.warn('OneSignal: Unsubscribing from push.');\n    if (SdkEnvironment.getWindowEnv() !== WindowEnvironmentKind.ServiceWorker) {\n        return self.registration.pushManager.getSubscription()\n            .then((subscription) => {\n            if (subscription) {\n                return subscription.unsubscribe();\n            }\n            else\n                throw new Error('Cannot unsubscribe because not subscribed.');\n        });\n    }\n    else {\n        if (isUsingSubscriptionWorkaround()) {\n            return new Promise((resolve, reject) => {\n                Log.debug(\"Unsubscribe from push got called, and we're going to remotely execute it in HTTPS iFrame.\");\n                OneSignal.proxyFrameHost.message(OneSignal.POSTMAM_COMMANDS.UNSUBSCRIBE_FROM_PUSH, null, (reply) => {\n                    Log.debug(\"Unsubscribe from push succesfully remotely executed.\");\n                    if (reply.data === OneSignal.POSTMAM_COMMANDS.REMOTE_OPERATION_COMPLETE) {\n                        resolve();\n                    }\n                    else {\n                        reject('Failed to remotely unsubscribe from push.');\n                    }\n                });\n            });\n        }\n        else {\n            if (!navigator.serviceWorker || !navigator.serviceWorker.controller)\n                return Promise.resolve();\n            return navigator.serviceWorker.ready\n                .then(registration => registration.pushManager)\n                .then(pushManager => pushManager.getSubscription())\n                .then((subscription) => {\n                if (subscription) {\n                    return subscription.unsubscribe();\n                }\n                else {\n                    return Promise.resolve();\n                }\n            });\n        }\n    }\n}\nexport function wait(milliseconds) {\n    return new Promise(resolve => setTimeout(resolve, milliseconds));\n}\n/**\n * Returns the part of the string after the first occurence of the specified search.\n * @param string The entire string.\n * @param search The text returned will be everything *after* search.\n * e.g. substringAfter('A white fox', 'white') => ' fox'\n */\nexport function substringAfter(string, search) {\n    return string.substr(string.indexOf(search) + search.length);\n}\nexport function once(targetSelectorOrElement, event, task, manualDestroy = false) {\n    if (!event) {\n        Log.error('Cannot call on() with no event: ', event);\n    }\n    if (!task) {\n        Log.error('Cannot call on() with no task: ', task);\n    }\n    if (typeof targetSelectorOrElement === 'string') {\n        let els = document.querySelectorAll(targetSelectorOrElement);\n        if (els.length > 0) {\n            for (let i = 0; i < els.length; i++)\n                once(els[i], event, task);\n        }\n    }\n    else if (isArray(targetSelectorOrElement)) {\n        for (let i = 0; i < targetSelectorOrElement.length; i++)\n            once(targetSelectorOrElement[i], event, task);\n    }\n    else if (typeof targetSelectorOrElement === 'object') {\n        var taskWrapper = (function () {\n            var internalTaskFunction = function (e) {\n                var destroyEventListener = function () {\n                    targetSelectorOrElement.removeEventListener(e.type, taskWrapper);\n                };\n                if (!manualDestroy) {\n                    destroyEventListener();\n                }\n                task(e, destroyEventListener);\n            };\n            return internalTaskFunction;\n        })();\n        targetSelectorOrElement.addEventListener(event, taskWrapper);\n    }\n    else\n        throw new Error(`${targetSelectorOrElement} must be a CSS selector string or DOM Element object.`);\n}\n/**\n * Returns the number of times the SDK has been loaded into the browser.\n * Expects a browser environment, otherwise this call will fail.\n */\nexport function getSdkLoadCount() {\n    return window.__oneSignalSdkLoadCount || 0;\n}\nexport async function awaitSdkEvent(eventName, predicate) {\n    return await new Promise(resolve => {\n        OneSignal.emitter.once(eventName, (event) => {\n            if (predicate) {\n                const predicateResult = predicate(event);\n                if (predicateResult)\n                    resolve(event);\n            }\n            else\n                resolve(event);\n        });\n    });\n}\n/**\n * Increments the counter describing the number of times the SDK has been loaded into the browser.\n * Expects a browser environment, otherwise this call will fail.\n */\nexport function incrementSdkLoadCount() {\n    window.__oneSignalSdkLoadCount = getSdkLoadCount() + 1;\n}\nexport function getPlatformNotificationIcon(notificationIcons) {\n    if (!notificationIcons)\n        return 'default-icon';\n    if (bowser.safari && notificationIcons.safari)\n        return notificationIcons.safari;\n    else if (bowser.firefox && notificationIcons.firefox)\n        return notificationIcons.firefox;\n    return notificationIcons.chrome ||\n        notificationIcons.firefox ||\n        notificationIcons.safari ||\n        'default-icon';\n}\nexport function getDomElementOrStub(selector) {\n    const foundElement = document.querySelector(selector);\n    if (!foundElement) {\n        Log.debug(`No instance of ${selector} found. Returning stub.`);\n        return document.createElement('div');\n    }\n    return foundElement;\n}\nexport function deepCopy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\n//# sourceMappingURL=utils.js.map","/*!\n * Bowser - a browser detector\n * https://github.com/ded/bowser\n * MIT License | (c) Dustin Diaz 2015\n */\n\n!function (root, name, definition) {\n  if (typeof module != 'undefined' && module.exports) module.exports = definition()\n  else if (typeof define == 'function' && define.amd) define(name, definition)\n  else root[name] = definition()\n}(this, 'bowser', function () {\n  /**\n    * See useragents.js for examples of navigator.userAgent\n    */\n\n  var t = true\n\n  function detect(ua) {\n\n    function getFirstMatch(regex) {\n      var match = ua.match(regex);\n      return (match && match.length > 1 && match[1]) || '';\n    }\n\n    function getSecondMatch(regex) {\n      var match = ua.match(regex);\n      return (match && match.length > 1 && match[2]) || '';\n    }\n\n    var iosdevice = getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase()\n      , likeAndroid = /like android/i.test(ua)\n      , android = !likeAndroid && /android/i.test(ua)\n      , nexusMobile = /nexus\\s*[0-6]\\s*/i.test(ua)\n      , nexusTablet = !nexusMobile && /nexus\\s*[0-9]+/i.test(ua)\n      , chromeos = /CrOS/.test(ua)\n      , silk = /silk/i.test(ua)\n      , sailfish = /sailfish/i.test(ua)\n      , tizen = /tizen/i.test(ua)\n      , webos = /(web|hpw)os/i.test(ua)\n      , windowsphone = /windows phone/i.test(ua)\n      , samsungBrowser = /SamsungBrowser/i.test(ua)\n      , windows = !windowsphone && /windows/i.test(ua)\n      , mac = !iosdevice && !silk && /macintosh/i.test(ua)\n      , linux = !android && !sailfish && !tizen && !webos && /linux/i.test(ua)\n      , edgeVersion = getFirstMatch(/edge\\/(\\d+(\\.\\d+)?)/i)\n      , versionIdentifier = getFirstMatch(/version\\/(\\d+(\\.\\d+)?)/i)\n      , tablet = /tablet/i.test(ua) && !/tablet pc/i.test(ua)\n      , mobile = !tablet && /[^-]mobi/i.test(ua)\n      , xbox = /xbox/i.test(ua)\n      , result\n\n    if (/opera/i.test(ua)) {\n      //  an old Opera\n      result = {\n        name: 'Opera'\n      , opera: t\n      , version: versionIdentifier || getFirstMatch(/(?:opera|opr|opios)[\\s\\/](\\d+(\\.\\d+)?)/i)\n      }\n    } else if (/opr\\/|opios/i.test(ua)) {\n      // a new Opera\n      result = {\n        name: 'Opera'\n        , opera: t\n        , version: getFirstMatch(/(?:opr|opios)[\\s\\/](\\d+(\\.\\d+)?)/i) || versionIdentifier\n      }\n    }\n    else if (/SamsungBrowser/i.test(ua)) {\n      result = {\n        name: 'Samsung Internet for Android'\n        , samsungBrowser: t\n        , version: versionIdentifier || getFirstMatch(/(?:SamsungBrowser)[\\s\\/](\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/coast/i.test(ua)) {\n      result = {\n        name: 'Opera Coast'\n        , coast: t\n        , version: versionIdentifier || getFirstMatch(/(?:coast)[\\s\\/](\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/yabrowser/i.test(ua)) {\n      result = {\n        name: 'Yandex Browser'\n      , yandexbrowser: t\n      , version: versionIdentifier || getFirstMatch(/(?:yabrowser)[\\s\\/](\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/ucbrowser/i.test(ua)) {\n      result = {\n          name: 'UC Browser'\n        , ucbrowser: t\n        , version: getFirstMatch(/(?:ucbrowser)[\\s\\/](\\d+(?:\\.\\d+)+)/i)\n      }\n    }\n    else if (/mxios/i.test(ua)) {\n      result = {\n        name: 'Maxthon'\n        , maxthon: t\n        , version: getFirstMatch(/(?:mxios)[\\s\\/](\\d+(?:\\.\\d+)+)/i)\n      }\n    }\n    else if (/epiphany/i.test(ua)) {\n      result = {\n        name: 'Epiphany'\n        , epiphany: t\n        , version: getFirstMatch(/(?:epiphany)[\\s\\/](\\d+(?:\\.\\d+)+)/i)\n      }\n    }\n    else if (/puffin/i.test(ua)) {\n      result = {\n        name: 'Puffin'\n        , puffin: t\n        , version: getFirstMatch(/(?:puffin)[\\s\\/](\\d+(?:\\.\\d+)?)/i)\n      }\n    }\n    else if (/sleipnir/i.test(ua)) {\n      result = {\n        name: 'Sleipnir'\n        , sleipnir: t\n        , version: getFirstMatch(/(?:sleipnir)[\\s\\/](\\d+(?:\\.\\d+)+)/i)\n      }\n    }\n    else if (/k-meleon/i.test(ua)) {\n      result = {\n        name: 'K-Meleon'\n        , kMeleon: t\n        , version: getFirstMatch(/(?:k-meleon)[\\s\\/](\\d+(?:\\.\\d+)+)/i)\n      }\n    }\n    else if (windowsphone) {\n      result = {\n        name: 'Windows Phone'\n      , windowsphone: t\n      }\n      if (edgeVersion) {\n        result.msedge = t\n        result.version = edgeVersion\n      }\n      else {\n        result.msie = t\n        result.version = getFirstMatch(/iemobile\\/(\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/msie|trident/i.test(ua)) {\n      result = {\n        name: 'Internet Explorer'\n      , msie: t\n      , version: getFirstMatch(/(?:msie |rv:)(\\d+(\\.\\d+)?)/i)\n      }\n    } else if (chromeos) {\n      result = {\n        name: 'Chrome'\n      , chromeos: t\n      , chromeBook: t\n      , chrome: t\n      , version: getFirstMatch(/(?:chrome|crios|crmo)\\/(\\d+(\\.\\d+)?)/i)\n      }\n    } else if (/chrome.+? edge/i.test(ua)) {\n      result = {\n        name: 'Microsoft Edge'\n      , msedge: t\n      , version: edgeVersion\n      }\n    }\n    else if (/vivaldi/i.test(ua)) {\n      result = {\n        name: 'Vivaldi'\n        , vivaldi: t\n        , version: getFirstMatch(/vivaldi\\/(\\d+(\\.\\d+)?)/i) || versionIdentifier\n      }\n    }\n    else if (sailfish) {\n      result = {\n        name: 'Sailfish'\n      , sailfish: t\n      , version: getFirstMatch(/sailfish\\s?browser\\/(\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/seamonkey\\//i.test(ua)) {\n      result = {\n        name: 'SeaMonkey'\n      , seamonkey: t\n      , version: getFirstMatch(/seamonkey\\/(\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/firefox|iceweasel|fxios/i.test(ua)) {\n      result = {\n        name: 'Firefox'\n      , firefox: t\n      , version: getFirstMatch(/(?:firefox|iceweasel|fxios)[ \\/](\\d+(\\.\\d+)?)/i)\n      }\n      if (/\\((mobile|tablet);[^\\)]*rv:[\\d\\.]+\\)/i.test(ua)) {\n        result.firefoxos = t\n      }\n    }\n    else if (silk) {\n      result =  {\n        name: 'Amazon Silk'\n      , silk: t\n      , version : getFirstMatch(/silk\\/(\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/phantom/i.test(ua)) {\n      result = {\n        name: 'PhantomJS'\n      , phantom: t\n      , version: getFirstMatch(/phantomjs\\/(\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/slimerjs/i.test(ua)) {\n      result = {\n        name: 'SlimerJS'\n        , slimer: t\n        , version: getFirstMatch(/slimerjs\\/(\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/blackberry|\\bbb\\d+/i.test(ua) || /rim\\stablet/i.test(ua)) {\n      result = {\n        name: 'BlackBerry'\n      , blackberry: t\n      , version: versionIdentifier || getFirstMatch(/blackberry[\\d]+\\/(\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (webos) {\n      result = {\n        name: 'WebOS'\n      , webos: t\n      , version: versionIdentifier || getFirstMatch(/w(?:eb)?osbrowser\\/(\\d+(\\.\\d+)?)/i)\n      };\n      /touchpad\\//i.test(ua) && (result.touchpad = t)\n    }\n    else if (/bada/i.test(ua)) {\n      result = {\n        name: 'Bada'\n      , bada: t\n      , version: getFirstMatch(/dolfin\\/(\\d+(\\.\\d+)?)/i)\n      };\n    }\n    else if (tizen) {\n      result = {\n        name: 'Tizen'\n      , tizen: t\n      , version: getFirstMatch(/(?:tizen\\s?)?browser\\/(\\d+(\\.\\d+)?)/i) || versionIdentifier\n      };\n    }\n    else if (/qupzilla/i.test(ua)) {\n      result = {\n        name: 'QupZilla'\n        , qupzilla: t\n        , version: getFirstMatch(/(?:qupzilla)[\\s\\/](\\d+(?:\\.\\d+)+)/i) || versionIdentifier\n      }\n    }\n    else if (/chromium/i.test(ua)) {\n      result = {\n        name: 'Chromium'\n        , chromium: t\n        , version: getFirstMatch(/(?:chromium)[\\s\\/](\\d+(?:\\.\\d+)?)/i) || versionIdentifier\n      }\n    }\n    else if (/chrome|crios|crmo/i.test(ua)) {\n      result = {\n        name: 'Chrome'\n        , chrome: t\n        , version: getFirstMatch(/(?:chrome|crios|crmo)\\/(\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (android) {\n      result = {\n        name: 'Android'\n        , version: versionIdentifier\n      }\n    }\n    else if (/safari|applewebkit/i.test(ua)) {\n      result = {\n        name: 'Safari'\n      , safari: t\n      }\n      if (versionIdentifier) {\n        result.version = versionIdentifier\n      }\n    }\n    else if (iosdevice) {\n      result = {\n        name : iosdevice == 'iphone' ? 'iPhone' : iosdevice == 'ipad' ? 'iPad' : 'iPod'\n      }\n      // WTF: version is not part of user agent in web apps\n      if (versionIdentifier) {\n        result.version = versionIdentifier\n      }\n    }\n    else if(/googlebot/i.test(ua)) {\n      result = {\n        name: 'Googlebot'\n      , googlebot: t\n      , version: getFirstMatch(/googlebot\\/(\\d+(\\.\\d+))/i) || versionIdentifier\n      }\n    }\n    else {\n      result = {\n        name: getFirstMatch(/^(.*)\\/(.*) /),\n        version: getSecondMatch(/^(.*)\\/(.*) /)\n     };\n   }\n\n    // set webkit or gecko flag for browsers based on these engines\n    if (!result.msedge && /(apple)?webkit/i.test(ua)) {\n      if (/(apple)?webkit\\/537\\.36/i.test(ua)) {\n        result.name = result.name || \"Blink\"\n        result.blink = t\n      } else {\n        result.name = result.name || \"Webkit\"\n        result.webkit = t\n      }\n      if (!result.version && versionIdentifier) {\n        result.version = versionIdentifier\n      }\n    } else if (!result.opera && /gecko\\//i.test(ua)) {\n      result.name = result.name || \"Gecko\"\n      result.gecko = t\n      result.version = result.version || getFirstMatch(/gecko\\/(\\d+(\\.\\d+)?)/i)\n    }\n\n    // set OS flags for platforms that have multiple browsers\n    if (!result.windowsphone && !result.msedge && (android || result.silk)) {\n      result.android = t\n    } else if (!result.windowsphone && !result.msedge && iosdevice) {\n      result[iosdevice] = t\n      result.ios = t\n    } else if (mac) {\n      result.mac = t\n    } else if (xbox) {\n      result.xbox = t\n    } else if (windows) {\n      result.windows = t\n    } else if (linux) {\n      result.linux = t\n    }\n\n    function getWindowsVersion (s) {\n      switch (s) {\n        case 'NT': return 'NT'\n        case 'XP': return 'XP'\n        case 'NT 5.0': return '2000'\n        case 'NT 5.1': return 'XP'\n        case 'NT 5.2': return '2003'\n        case 'NT 6.0': return 'Vista'\n        case 'NT 6.1': return '7'\n        case 'NT 6.2': return '8'\n        case 'NT 6.3': return '8.1'\n        case 'NT 10.0': return '10'\n        default: return undefined\n      }\n    }\n\n    // OS version extraction\n    var osVersion = '';\n    if (result.windows) {\n      osVersion = getWindowsVersion(getFirstMatch(/Windows ((NT|XP)( \\d\\d?.\\d)?)/i))\n    } else if (result.windowsphone) {\n      osVersion = getFirstMatch(/windows phone (?:os)?\\s?(\\d+(\\.\\d+)*)/i);\n    } else if (result.mac) {\n      osVersion = getFirstMatch(/Mac OS X (\\d+([_\\.\\s]\\d+)*)/i);\n      osVersion = osVersion.replace(/[_\\s]/g, '.');\n    } else if (iosdevice) {\n      osVersion = getFirstMatch(/os (\\d+([_\\s]\\d+)*) like mac os x/i);\n      osVersion = osVersion.replace(/[_\\s]/g, '.');\n    } else if (android) {\n      osVersion = getFirstMatch(/android[ \\/-](\\d+(\\.\\d+)*)/i);\n    } else if (result.webos) {\n      osVersion = getFirstMatch(/(?:web|hpw)os\\/(\\d+(\\.\\d+)*)/i);\n    } else if (result.blackberry) {\n      osVersion = getFirstMatch(/rim\\stablet\\sos\\s(\\d+(\\.\\d+)*)/i);\n    } else if (result.bada) {\n      osVersion = getFirstMatch(/bada\\/(\\d+(\\.\\d+)*)/i);\n    } else if (result.tizen) {\n      osVersion = getFirstMatch(/tizen[\\/\\s](\\d+(\\.\\d+)*)/i);\n    }\n    if (osVersion) {\n      result.osversion = osVersion;\n    }\n\n    // device type extraction\n    var osMajorVersion = !result.windows && osVersion.split('.')[0];\n    if (\n         tablet\n      || nexusTablet\n      || iosdevice == 'ipad'\n      || (android && (osMajorVersion == 3 || (osMajorVersion >= 4 && !mobile)))\n      || result.silk\n    ) {\n      result.tablet = t\n    } else if (\n         mobile\n      || iosdevice == 'iphone'\n      || iosdevice == 'ipod'\n      || android\n      || nexusMobile\n      || result.blackberry\n      || result.webos\n      || result.bada\n    ) {\n      result.mobile = t\n    }\n\n    // Graded Browser Support\n    // http://developer.yahoo.com/yui/articles/gbs\n    if (result.msedge ||\n        (result.msie && result.version >= 10) ||\n        (result.yandexbrowser && result.version >= 15) ||\n\t\t    (result.vivaldi && result.version >= 1.0) ||\n        (result.chrome && result.version >= 20) ||\n        (result.samsungBrowser && result.version >= 4) ||\n        (result.firefox && result.version >= 20.0) ||\n        (result.safari && result.version >= 6) ||\n        (result.opera && result.version >= 10.0) ||\n        (result.ios && result.osversion && result.osversion.split(\".\")[0] >= 6) ||\n        (result.blackberry && result.version >= 10.1)\n        || (result.chromium && result.version >= 20)\n        ) {\n      result.a = t;\n    }\n    else if ((result.msie && result.version < 10) ||\n        (result.chrome && result.version < 20) ||\n        (result.firefox && result.version < 20.0) ||\n        (result.safari && result.version < 6) ||\n        (result.opera && result.version < 10.0) ||\n        (result.ios && result.osversion && result.osversion.split(\".\")[0] < 6)\n        || (result.chromium && result.version < 20)\n        ) {\n      result.c = t\n    } else result.x = t\n\n    return result\n  }\n\n  var bowser = detect(typeof navigator !== 'undefined' ? navigator.userAgent || '' : '')\n\n  bowser.test = function (browserList) {\n    for (var i = 0; i < browserList.length; ++i) {\n      var browserItem = browserList[i];\n      if (typeof browserItem=== 'string') {\n        if (browserItem in bowser) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Get version precisions count\n   *\n   * @example\n   *   getVersionPrecision(\"1.10.3\") // 3\n   *\n   * @param  {string} version\n   * @return {number}\n   */\n  function getVersionPrecision(version) {\n    return version.split(\".\").length;\n  }\n\n  /**\n   * Array::map polyfill\n   *\n   * @param  {Array} arr\n   * @param  {Function} iterator\n   * @return {Array}\n   */\n  function map(arr, iterator) {\n    var result = [], i;\n    if (Array.prototype.map) {\n      return Array.prototype.map.call(arr, iterator);\n    }\n    for (i = 0; i < arr.length; i++) {\n      result.push(iterator(arr[i]));\n    }\n    return result;\n  }\n\n  /**\n   * Calculate browser version weight\n   *\n   * @example\n   *   compareVersions(['1.10.2.1',  '1.8.2.1.90'])    // 1\n   *   compareVersions(['1.010.2.1', '1.09.2.1.90']);  // 1\n   *   compareVersions(['1.10.2.1',  '1.10.2.1']);     // 0\n   *   compareVersions(['1.10.2.1',  '1.0800.2']);     // -1\n   *\n   * @param  {Array<String>} versions versions to compare\n   * @return {Number} comparison result\n   */\n  function compareVersions(versions) {\n    // 1) get common precision for both versions, for example for \"10.0\" and \"9\" it should be 2\n    var precision = Math.max(getVersionPrecision(versions[0]), getVersionPrecision(versions[1]));\n    var chunks = map(versions, function (version) {\n      var delta = precision - getVersionPrecision(version);\n\n      // 2) \"9\" -> \"9.0\" (for precision = 2)\n      version = version + new Array(delta + 1).join(\".0\");\n\n      // 3) \"9.0\" -> [\"000000000\"\", \"000000009\"]\n      return map(version.split(\".\"), function (chunk) {\n        return new Array(20 - chunk.length).join(\"0\") + chunk;\n      }).reverse();\n    });\n\n    // iterate in reverse order by reversed chunks array\n    while (--precision >= 0) {\n      // 4) compare: \"000000009\" > \"000000010\" = false (but \"9\" > \"10\" = true)\n      if (chunks[0][precision] > chunks[1][precision]) {\n        return 1;\n      }\n      else if (chunks[0][precision] === chunks[1][precision]) {\n        if (precision === 0) {\n          // all version chunks are same\n          return 0;\n        }\n      }\n      else {\n        return -1;\n      }\n    }\n  }\n\n  /**\n   * Check if browser is unsupported\n   *\n   * @example\n   *   bowser.isUnsupportedBrowser({\n   *     msie: \"10\",\n   *     firefox: \"23\",\n   *     chrome: \"29\",\n   *     safari: \"5.1\",\n   *     opera: \"16\",\n   *     phantom: \"534\"\n   *   });\n   *\n   * @param  {Object}  minVersions map of minimal version to browser\n   * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map\n   * @param  {String}  [ua] user agent string\n   * @return {Boolean}\n   */\n  function isUnsupportedBrowser(minVersions, strictMode, ua) {\n    var _bowser = bowser;\n\n    // make strictMode param optional with ua param usage\n    if (typeof strictMode === 'string') {\n      ua = strictMode;\n      strictMode = void(0);\n    }\n\n    if (strictMode === void(0)) {\n      strictMode = false;\n    }\n    if (ua) {\n      _bowser = detect(ua);\n    }\n\n    var version = \"\" + _bowser.version;\n    for (var browser in minVersions) {\n      if (minVersions.hasOwnProperty(browser)) {\n        if (_bowser[browser]) {\n          if (typeof minVersions[browser] !== 'string') {\n            throw new Error('Browser version in the minVersion map should be a string: ' + browser + ': ' + String(minVersions));\n          }\n\n          // browser version and min supported version.\n          return compareVersions([version, minVersions[browser]]) < 0;\n        }\n      }\n    }\n\n    return strictMode; // not found\n  }\n\n  /**\n   * Check if browser is supported\n   *\n   * @param  {Object} minVersions map of minimal version to browser\n   * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map\n   * @param  {String}  [ua] user agent string\n   * @return {Boolean}\n   */\n  function check(minVersions, strictMode, ua) {\n    return !isUnsupportedBrowser(minVersions, strictMode, ua);\n  }\n\n  bowser.isUnsupportedBrowser = isUnsupportedBrowser;\n  bowser.compareVersions = compareVersions;\n  bowser.check = check;\n\n  /*\n   * Set our detect method to the main bowser object so we can\n   * reuse it to test other user agents.\n   * This is needed to implement future tests.\n   */\n  bowser._detect = detect;\n\n  return bowser\n});\n","export var SubscriptionStateKind;\n(function (SubscriptionStateKind) {\n    SubscriptionStateKind[SubscriptionStateKind[\"Default\"] = 0] = \"Default\";\n    SubscriptionStateKind[SubscriptionStateKind[\"Subscribed\"] = 1] = \"Subscribed\";\n    SubscriptionStateKind[SubscriptionStateKind[\"MutedByApi\"] = -2] = \"MutedByApi\";\n    SubscriptionStateKind[SubscriptionStateKind[\"NotSubscribed\"] = -10] = \"NotSubscribed\";\n    SubscriptionStateKind[SubscriptionStateKind[\"TemporaryWebRecord\"] = -20] = \"TemporaryWebRecord\";\n    SubscriptionStateKind[SubscriptionStateKind[\"PermissionRevoked\"] = -21] = \"PermissionRevoked\";\n    SubscriptionStateKind[SubscriptionStateKind[\"PushSubscriptionRevoked\"] = -22] = \"PushSubscriptionRevoked\";\n    SubscriptionStateKind[SubscriptionStateKind[\"ServiceWorkerStatus403\"] = -23] = \"ServiceWorkerStatus403\";\n    SubscriptionStateKind[SubscriptionStateKind[\"ServiceWorkerStatus404\"] = -24] = \"ServiceWorkerStatus404\";\n})(SubscriptionStateKind || (SubscriptionStateKind = {}));\n//# sourceMappingURL=SubscriptionStateKind.js.map","export var NotificationPermission;\n(function (NotificationPermission) {\n    /**\n     * The user has not granted notification permissions and may have just dismissed the notification permission prompt.\n     */\n    NotificationPermission[\"Default\"] = \"default\";\n    /**\n     * The user has granted notification permissions.\n     */\n    NotificationPermission[\"Granted\"] = \"granted\";\n    /**\n     * The user has blocked notifications.\n     */\n    NotificationPermission[\"Denied\"] = \"denied\";\n})(NotificationPermission || (NotificationPermission = {}));\n//# sourceMappingURL=NotificationPermission.js.map","export default class OneSignalError extends Error {\n    constructor(message = '') {\n        super(message);\n        // extending Error is weird and does not propagate `message`\n        Object.defineProperty(this, 'message', {\n            configurable: true,\n            enumerable: false,\n            value: message,\n            writable: true,\n        });\n        Object.defineProperty(this, 'name', {\n            configurable: true,\n            enumerable: false,\n            value: this.constructor.name,\n            writable: true,\n        });\n        if (Error.hasOwnProperty('captureStackTrace')) {\n            Error.captureStackTrace(this, this.constructor);\n            return;\n        }\n        Object.defineProperty(this, 'stack', {\n            configurable: true,\n            enumerable: false,\n            value: (new Error(message)).stack,\n            writable: true,\n        });\n        /**\n         * Important! Required to make sure the correct error type is detected during instanceof checks.\n         * Same applies to all derived classes.\n         * https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n         */\n        Object.setPrototypeOf(this, OneSignalError.prototype);\n    }\n}\n//# sourceMappingURL=OneSignalError.js.map","export var PermissionPromptType;\n(function (PermissionPromptType) {\n    /**\n     * The \"main\" browser native permission request dialog when prompting for local or push notification permissions.\n     */\n    PermissionPromptType[PermissionPromptType[\"HttpsPermissionRequest\"] = 'HTTPS permission request'] = \"HttpsPermissionRequest\";\n    /**\n     * The \"popup\" to subdomain.onesignal.com.\n     */\n    PermissionPromptType[PermissionPromptType[\"FullscreenHttpPermissionMessage\"] = 'fullscreen HTTP permission message'] = \"FullscreenHttpPermissionMessage\";\n    /**\n     * The full-screen HTTPS modal with a dimmed backdrop.\n     */\n    PermissionPromptType[PermissionPromptType[\"FullscreenHttpsPermissionMessage\"] = 'fullscreen HTTPS permission message'] = \"FullscreenHttpsPermissionMessage\";\n    /**\n     * The \"sliding down\" prompt.\n     */\n    PermissionPromptType[PermissionPromptType[\"SlidedownPermissionMessage\"] = 'slidedown permission message'] = \"SlidedownPermissionMessage\";\n    /**\n     * The \"notify button\".\n     */\n    PermissionPromptType[PermissionPromptType[\"SubscriptionBell\"] = 'subscription bell'] = \"SubscriptionBell\";\n})(PermissionPromptType || (PermissionPromptType = {}));\n//# sourceMappingURL=PermissionPromptType.js.map","import OneSignalError from \"./OneSignalError\";\nimport { PermissionPromptType } from \"../models/PermissionPromptType\";\nexport var InvalidStateReason;\n(function (InvalidStateReason) {\n    InvalidStateReason[InvalidStateReason[\"MissingAppId\"] = 0] = \"MissingAppId\";\n    InvalidStateReason[InvalidStateReason[\"RedundantPermissionMessage\"] = 1] = \"RedundantPermissionMessage\";\n    InvalidStateReason[InvalidStateReason[\"PushPermissionAlreadyGranted\"] = 2] = \"PushPermissionAlreadyGranted\";\n    InvalidStateReason[InvalidStateReason[\"UnsupportedEnvironment\"] = 3] = \"UnsupportedEnvironment\";\n    InvalidStateReason[InvalidStateReason[\"MissingDomElement\"] = 4] = \"MissingDomElement\";\n    InvalidStateReason[InvalidStateReason[\"ServiceWorkerNotActivated\"] = 5] = \"ServiceWorkerNotActivated\";\n    InvalidStateReason[InvalidStateReason[\"NoProxyFrame\"] = 6] = \"NoProxyFrame\";\n})(InvalidStateReason || (InvalidStateReason = {}));\nexport class InvalidStateError extends OneSignalError {\n    constructor(reason, extra) {\n        switch (reason) {\n            case InvalidStateReason.MissingAppId:\n                super(`Missing required app ID.`);\n                break;\n            case InvalidStateReason.RedundantPermissionMessage:\n                let extraInfo = '';\n                if (extra && extra.permissionPromptType)\n                    extraInfo = `(${PermissionPromptType[extra.permissionPromptType]})`;\n                super(`Another permission message ${extraInfo} is being displayed.`);\n                break;\n            case InvalidStateReason.PushPermissionAlreadyGranted:\n                super(`Push permission has already been granted.`);\n                break;\n            case InvalidStateReason.UnsupportedEnvironment:\n                super(`The current environment does not support this operation.`);\n                break;\n            case InvalidStateReason.ServiceWorkerNotActivated:\n                super(`The service worker must be activated first.`);\n                break;\n            case InvalidStateReason.NoProxyFrame:\n                super(`No proxy frame.`);\n                break;\n        }\n        this.description = InvalidStateReason[reason];\n        this.reason = reason;\n        /**\n         * Important! Required to make sure the correct error type is detected during instanceof checks.\n         * Same applies to all derived classes.\n         * https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n         */\n        Object.setPrototypeOf(this, InvalidStateError.prototype);\n    }\n}\n//# sourceMappingURL=InvalidStateError.js.map","import OneSignalError from \"./OneSignalError\";\nexport var InvalidArgumentReason;\n(function (InvalidArgumentReason) {\n    InvalidArgumentReason[InvalidArgumentReason[\"Empty\"] = 0] = \"Empty\";\n    InvalidArgumentReason[InvalidArgumentReason[\"Malformed\"] = 1] = \"Malformed\";\n    InvalidArgumentReason[InvalidArgumentReason[\"EnumOutOfRange\"] = 2] = \"EnumOutOfRange\";\n})(InvalidArgumentReason || (InvalidArgumentReason = {}));\nexport class InvalidArgumentError extends OneSignalError {\n    constructor(argName, reason) {\n        switch (reason) {\n            case InvalidArgumentReason.Empty:\n                super(`Supply a non-empty value to '${argName}'.`);\n                break;\n            case InvalidArgumentReason.Malformed:\n                super(`The value for '${argName}' was malformed.`);\n                break;\n            case InvalidArgumentReason.EnumOutOfRange:\n                super(`The value for '${argName}' was out of range of the expected input enum.`);\n                break;\n        }\n        this.argument = argName;\n        this.reason = InvalidArgumentReason[reason];\n        /**\n         * Important! Required to make sure the correct error type is detected during instanceof checks.\n         * Same applies to all derived classes.\n         * https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n         */\n        Object.setPrototypeOf(this, InvalidArgumentError.prototype);\n    }\n}\n//# sourceMappingURL=InvalidArgumentError.js.map","export var IntegrationKind;\n(function (IntegrationKind) {\n    /**\n     * An secure HTTPS site using its own origin for subscribing.\n     */\n    IntegrationKind[\"Secure\"] = \"Secure\";\n    /**\n     * A secure HTTPS site using a proxy subscription origin (e.g. subdomain.os.tc or\n     * subdomain.onesignal.com).\n     */\n    IntegrationKind[\"SecureProxy\"] = \"Secure Proxy\";\n    /**\n     * An insecure HTTP site using a proxy subscription origin (e.g. subdomain.os.tc or\n     * subdomain.onesignal.com).\n     */\n    IntegrationKind[\"InsecureProxy\"] = \"Insecure Proxy\";\n})(IntegrationKind || (IntegrationKind = {}));\n//# sourceMappingURL=IntegrationKind.js.map","export var SessionStatus;\n(function (SessionStatus) {\n    SessionStatus[\"Active\"] = \"active\";\n    SessionStatus[\"Inactive\"] = \"inactive\";\n    SessionStatus[\"Expired\"] = \"expired\";\n})(SessionStatus || (SessionStatus = {}));\nexport var SessionOrigin;\n(function (SessionOrigin) {\n    SessionOrigin[SessionOrigin[\"PlayerCreate\"] = 1] = \"PlayerCreate\";\n    SessionOrigin[SessionOrigin[\"PlayerOnSession\"] = 2] = \"PlayerOnSession\";\n    SessionOrigin[SessionOrigin[\"VisibilityVisible\"] = 3] = \"VisibilityVisible\";\n    SessionOrigin[SessionOrigin[\"VisibilityHidden\"] = 4] = \"VisibilityHidden\";\n    SessionOrigin[SessionOrigin[\"BeforeUnload\"] = 5] = \"BeforeUnload\";\n    SessionOrigin[SessionOrigin[\"PageRefresh\"] = 6] = \"PageRefresh\";\n    SessionOrigin[SessionOrigin[\"Focus\"] = 7] = \"Focus\";\n    SessionOrigin[SessionOrigin[\"Blur\"] = 8] = \"Blur\";\n})(SessionOrigin || (SessionOrigin = {}));\nexport const ONESIGNAL_SESSION_KEY = \"oneSignalSession\";\nexport function initializeNewSession(options) {\n    const currentTimestamp = new Date().getTime();\n    const sessionKey = options && options.sessionKey || ONESIGNAL_SESSION_KEY;\n    const notificationId = (options && options.notificationId) || null;\n    return {\n        sessionKey,\n        appId: options.appId,\n        deviceId: options.deviceId,\n        deviceType: options.deviceType,\n        startTimestamp: currentTimestamp,\n        accumulatedDuration: 0,\n        notificationId,\n        status: SessionStatus.Active,\n        lastDeactivatedTimestamp: null,\n        lastActivatedTimestamp: currentTimestamp,\n    };\n}\n//# sourceMappingURL=Session.js.map","import Environment from './Environment';\nimport SdkEnvironment from './managers/SdkEnvironment';\nimport { Utils } from \"./context/shared/utils/Utils\";\nimport { OneSignalApiError, OneSignalApiErrorKind } from './errors/OneSignalApiError';\nimport Log from \"./libraries/Log\";\nexport class OneSignalApiBase {\n    static get(action, data, headers) {\n        return OneSignalApiBase.call('GET', action, data, headers);\n    }\n    static post(action, data, headers) {\n        return OneSignalApiBase.call('POST', action, data, headers);\n    }\n    static put(action, data, headers) {\n        return OneSignalApiBase.call('PUT', action, data, headers);\n    }\n    static delete(action, data, headers) {\n        return OneSignalApiBase.call('DELETE', action, data, headers);\n    }\n    static call(method, action, data, headers) {\n        if (method === \"GET\") {\n            if (action.indexOf(\"players\") > -1 && action.indexOf(\"app_id=\") === -1) {\n                console.error(\"Calls to player api are not permitted without app_id\");\n                return Promise.reject(new OneSignalApiError(OneSignalApiErrorKind.MissingAppId));\n            }\n        }\n        else {\n            if (action.indexOf(\"players\") > -1 && (!data || !data[\"app_id\"])) {\n                console.error(\"Calls to player api are not permitted without app_id\");\n                return Promise.reject(new OneSignalApiError(OneSignalApiErrorKind.MissingAppId));\n            }\n        }\n        let callHeaders = new Headers();\n        callHeaders.append(\"Origin\", SdkEnvironment.getOrigin());\n        callHeaders.append('SDK-Version', `onesignal/web/${Environment.version()}`);\n        callHeaders.append('Content-Type', 'application/json;charset=UTF-8');\n        if (headers) {\n            for (let key of Object.keys(headers)) {\n                callHeaders.append(key, headers[key]);\n            }\n        }\n        const contents = {\n            method: method || 'NO_METHOD_SPECIFIED',\n            headers: callHeaders,\n            cache: 'no-cache'\n        };\n        if (data)\n            contents.body = JSON.stringify(data);\n        let status;\n        return fetch(SdkEnvironment.getOneSignalApiUrl(undefined, action).toString() + '/' + action, contents)\n            .then(response => {\n            status = response.status;\n            return response.json();\n        })\n            .then(json => {\n            if (status >= 200 && status < 300)\n                return json;\n            else {\n                let error = OneSignalApiBase.identifyError(json);\n                if (error === 'no-user-id-error') {\n                    // TODO: This returns undefined\n                }\n                else {\n                    return Promise.reject(json);\n                }\n            }\n        })\n            .catch(err => {\n            Log.warn(`Could not complete request to /${action}`, err);\n            return Promise.reject(err);\n        });\n    }\n    static identifyError(error) {\n        if (!error || !error.errors) {\n            return 'no-error';\n        }\n        let errors = error.errors;\n        if (Utils.contains(errors, 'No user with this id found') ||\n            Utils.contains(errors, 'Could not find app_id for given player id.')) {\n            return 'no-user-id-error';\n        }\n        return 'unknown-error';\n    }\n}\nexport default OneSignalApiBase;\n//# sourceMappingURL=OneSignalApiBase.js.map","import OneSignalError from \"./OneSignalError\";\nexport var PushPermissionNotGrantedErrorReason;\n(function (PushPermissionNotGrantedErrorReason) {\n    PushPermissionNotGrantedErrorReason[PushPermissionNotGrantedErrorReason[\"Blocked\"] = 0] = \"Blocked\";\n    PushPermissionNotGrantedErrorReason[PushPermissionNotGrantedErrorReason[\"Dismissed\"] = 1] = \"Dismissed\";\n    PushPermissionNotGrantedErrorReason[PushPermissionNotGrantedErrorReason[\"Default\"] = 2] = \"Default\";\n})(PushPermissionNotGrantedErrorReason || (PushPermissionNotGrantedErrorReason = {}));\nexport default class PushPermissionNotGrantedError extends OneSignalError {\n    constructor(reason) {\n        switch (reason) {\n            case PushPermissionNotGrantedErrorReason.Dismissed:\n                super('The user dismissed the permission prompt.');\n                break;\n            case PushPermissionNotGrantedErrorReason.Blocked:\n                super('Notification permissions are blocked.');\n                break;\n            case PushPermissionNotGrantedErrorReason.Default:\n                super('Notification permissions have not been granted yet.');\n                break;\n        }\n        this.reason = reason;\n        /**\n         * Important! Required to make sure the correct error type is detected during instanceof checks.\n         * Same applies to all derived classes.\n         * https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n         */\n        Object.setPrototypeOf(this, PushPermissionNotGrantedError.prototype);\n    }\n}\n//# sourceMappingURL=PushPermissionNotGrantedError.js.map","import Environment from './Environment';\nimport SdkEnvironment from './managers/SdkEnvironment';\nimport { WindowEnvironmentKind } from './models/WindowEnvironmentKind';\nimport Log from './libraries/Log';\nimport Utils from \"./context/shared/utils/Utils\";\nconst SILENT_EVENTS = [\n    'notifyButtonHovering',\n    'notifyButtonHover',\n    'notifyButtonButtonClick',\n    'notifyButtonLauncherClick',\n    'animatedElementHiding',\n    'animatedElementHidden',\n    'animatedElementShowing',\n    'animatedElementShown',\n    'activeAnimatedElementActivating',\n    'activeAnimatedElementActive',\n    'activeAnimatedElementInactivating',\n    'activeAnimatedElementInactive',\n    'dbRetrieved',\n    'dbSet',\n    'testEvent'\n];\nconst RETRIGGER_REMOTE_EVENTS = [\n    'onesignal.prompt.custom.clicked',\n    'onesignal.prompt.native.permissionchanged',\n    'onesignal.subscription.changed',\n    'onesignal.internal.subscriptionset',\n    'dbRebuilt',\n    'initialize',\n    'subscriptionSet',\n    'sendWelcomeNotification',\n    'subscriptionChange',\n    'notificationPermissionChange',\n    'dbSet',\n    'register',\n    'notificationDisplay',\n    'notificationDismiss',\n    'notificationClick',\n    'permissionPromptDisplay',\n    'testWouldDisplay',\n    'testInitOptionDisabled',\n    'popupWindowTimeout'\n];\nconst LEGACY_EVENT_MAP = {\n    'notificationPermissionChange': 'onesignal.prompt.native.permissionchanged',\n    'subscriptionChange': 'onesignal.subscription.changed',\n    'customPromptClick': 'onesignal.prompt.custom.clicked',\n};\nexport default class Event {\n    /**\n     * Triggers the specified event with optional custom data.\n     * @param eventName The string event name to be emitted.\n     * @param data Any JavaScript variable to be passed with the event.\n     * @param remoteTriggerEnv If this method is being called in a different environment (e.g. was triggered in iFrame but now retriggered on main host), this is the string of the original environment for logging purposes.\n     */\n    static async trigger(eventName, data, remoteTriggerEnv = null) {\n        if (!Utils.contains(SILENT_EVENTS, eventName)) {\n            let displayData = data;\n            let env = Utils.capitalize(SdkEnvironment.getWindowEnv().toString());\n            if (remoteTriggerEnv) {\n                env = `${env}  ${Utils.capitalize(remoteTriggerEnv)}`;\n            }\n            if (displayData || displayData === false) {\n                Log.debug(`(${env})  %c${eventName}:`, Utils.getConsoleStyle('event'), displayData);\n            }\n            else {\n                Log.debug(`(${env})  %c${eventName}`, Utils.getConsoleStyle('event'));\n            }\n        }\n        // Actually fire the event that can be listened to via OneSignal.on()\n        if (Environment.isBrowser()) {\n            if (eventName === OneSignal.EVENTS.SDK_INITIALIZED) {\n                if (OneSignal.initialized)\n                    return;\n                else\n                    OneSignal.initialized = true;\n            }\n            await OneSignal.emitter.emit(eventName, data);\n        }\n        if (LEGACY_EVENT_MAP.hasOwnProperty(eventName)) {\n            let legacyEventName = LEGACY_EVENT_MAP[eventName];\n            Event._triggerLegacy(legacyEventName, data);\n        }\n        // If this event was triggered in an iFrame or Popup environment, also trigger it on the host page\n        if (Environment.isBrowser() &&\n            (SdkEnvironment.getWindowEnv() === WindowEnvironmentKind.OneSignalSubscriptionPopup ||\n                SdkEnvironment.getWindowEnv() === WindowEnvironmentKind.OneSignalProxyFrame)) {\n            const creator = opener || parent;\n            if (!creator) {\n                Log.error(`Could not send event '${eventName}' back to host page because no creator (opener or parent) found!`);\n            }\n            else {\n                // But only if the event matches certain events\n                if (Utils.contains(RETRIGGER_REMOTE_EVENTS, eventName)) {\n                    if (SdkEnvironment.getWindowEnv() === WindowEnvironmentKind.OneSignalSubscriptionPopup) {\n                        OneSignal.subscriptionPopup.message(OneSignal.POSTMAM_COMMANDS.REMOTE_RETRIGGER_EVENT, { eventName: eventName, eventData: data });\n                    }\n                    else {\n                        OneSignal.proxyFrame.retriggerRemoteEvent(eventName, data);\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Fires the event to be listened to via window.addEventListener().\n     * @param eventName The string event name.\n     * @param data Any JavaScript variable to be passed with the event.\n     * @private\n     */\n    static _triggerLegacy(eventName, data) {\n        const event = new CustomEvent(eventName, {\n            bubbles: true, cancelable: true, detail: data\n        });\n        // Fire the event that listeners can listen to via 'window.addEventListener()'\n        window.dispatchEvent(event);\n    }\n}\n//# sourceMappingURL=Event.js.map","export class RawPushSubscription {\n    /**\n     * Returns true if an existing recorded W3C or Safari subscription is\n     * identical to the current subscription.\n     */\n    isNewSubscription() {\n        if (this.existingW3cPushSubscription) {\n            if (!!this.existingW3cPushSubscription.w3cEndpoint !== !!this.w3cEndpoint) {\n                return true;\n            }\n            if (!!this.existingW3cPushSubscription.w3cEndpoint && !!this.w3cEndpoint &&\n                this.existingW3cPushSubscription.w3cEndpoint.toString() !== this.w3cEndpoint.toString()) {\n                return true;\n            }\n            if (this.existingW3cPushSubscription.w3cP256dh !== this.w3cP256dh) {\n                return true;\n            }\n            if (this.existingW3cPushSubscription.w3cAuth !== this.w3cAuth) {\n                return true;\n            }\n            return false;\n        }\n        else if (this.existingSafariDeviceToken) {\n            return this.existingSafariDeviceToken !== this.safariDeviceToken;\n        }\n        return true;\n    }\n    /**\n     * Given a native W3C browser push subscription, takes the endpoint, p256dh,\n     * and auth.\n     *\n     * @param pushSubscription A native browser W3C push subscription.\n     */\n    static setFromW3cSubscription(pushSubscription) {\n        const rawPushSubscription = new RawPushSubscription();\n        if (pushSubscription) {\n            rawPushSubscription.w3cEndpoint = new URL(pushSubscription.endpoint);\n            // Retrieve p256dh and auth for encrypted web push protocol\n            if (pushSubscription.getKey) {\n                // p256dh and auth are both ArrayBuffer\n                let p256dh = null;\n                try {\n                    p256dh = pushSubscription.getKey('p256dh');\n                }\n                catch (e) {\n                    // User is most likely running < Chrome < 50\n                }\n                let auth = null;\n                try {\n                    auth = pushSubscription.getKey('auth');\n                }\n                catch (e) {\n                    // User is most likely running < Firefox 45\n                }\n                if (p256dh) {\n                    // Base64 encode the ArrayBuffer (not URL-Safe, using standard Base64)\n                    let p256dh_base64encoded = btoa(String.fromCharCode.apply(null, new Uint8Array(p256dh)));\n                    rawPushSubscription.w3cP256dh = p256dh_base64encoded;\n                }\n                if (auth) {\n                    // Base64 encode the ArrayBuffer (not URL-Safe, using standard Base64)\n                    let auth_base64encoded = btoa(String.fromCharCode.apply(null, new Uint8Array(auth)));\n                    rawPushSubscription.w3cAuth = auth_base64encoded;\n                }\n            }\n        }\n        return rawPushSubscription;\n    }\n    /**\n     * Given a native browser Safari push subscription, sets the device token\n     * property.\n     *\n     * @param safariDeviceToken A native browser Safari push subscription.\n     */\n    setFromSafariSubscription(safariDeviceToken) {\n        this.safariDeviceToken = safariDeviceToken;\n    }\n    serialize() {\n        const serializedBundle = {\n            /* Old Parameters */\n            w3cEndpoint: this.w3cEndpoint ? this.w3cEndpoint.toString() : null,\n            w3cP256dh: this.w3cP256dh,\n            w3cAuth: this.w3cAuth,\n            safariDeviceToken: this.safariDeviceToken,\n            existingPushSubscription: this.existingW3cPushSubscription ? this.existingW3cPushSubscription.serialize() : null,\n            existingSafariDeviceToken: this.existingSafariDeviceToken\n        };\n        return serializedBundle;\n    }\n    // TODO: had a hard to debug bug here due to \"any\" type bypassing typescript validation.\n    // Check the usage and maybe change with strict type\n    static deserialize(bundle) {\n        const subscription = new RawPushSubscription();\n        if (!bundle) {\n            return subscription;\n        }\n        try {\n            subscription.w3cEndpoint = new URL(bundle.w3cEndpoint);\n        }\n        catch (e) {\n            // w3cEndpoint will be null for Safari\n        }\n        subscription.w3cP256dh = bundle.w3cP256dh;\n        subscription.w3cAuth = bundle.w3cAuth;\n        subscription.existingW3cPushSubscription = undefined;\n        if (bundle.existingW3cPushSubscription) {\n            subscription.existingW3cPushSubscription = RawPushSubscription.deserialize(bundle.existingW3cPushSubscription);\n        }\n        else if (bundle.existingPushSubscription) {\n            subscription.existingW3cPushSubscription = RawPushSubscription.deserialize(bundle.existingPushSubscription);\n        }\n        subscription.safariDeviceToken = bundle.safariDeviceToken;\n        subscription.existingSafariDeviceToken = bundle.existingSafariDeviceToken;\n        return subscription;\n    }\n}\n//# sourceMappingURL=RawPushSubscription.js.map","import OneSignalError from \"./OneSignalError\";\nexport default class NotImplementedError extends OneSignalError {\n    constructor() {\n        super('This code is not implemented yet.');\n        /**\n         * Important! Required to make sure the correct error type is detected during instanceof checks.\n         * Same applies to all derived classes.\n         * https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n         */\n        Object.setPrototypeOf(this, NotImplementedError.prototype);\n    }\n}\n//# sourceMappingURL=NotImplementedError.js.map","import NotImplementedError from '../errors/NotImplementedError';\nimport { DeliveryPlatformKind } from './DeliveryPlatformKind';\nimport { DeviceRecord } from './DeviceRecord';\n/**\n * Describes an email device record.\n */\nexport class EmailDeviceRecord extends DeviceRecord {\n    /**\n     * @param email Omitting this parameter does not void the record's identifier.\n     */\n    constructor(email, emailAuthHash, pushDeviceRecordId) {\n        super();\n        this.email = email;\n        this.emailAuthHash = emailAuthHash;\n        this.pushDeviceRecordId = pushDeviceRecordId;\n        this.deliveryPlatform = DeliveryPlatformKind.Email;\n    }\n    serialize() {\n        const serializedBundle = super.serialize();\n        if (this.email) {\n            serializedBundle.identifier = this.email;\n        }\n        if (this.emailAuthHash) {\n            serializedBundle.email_auth_hash = this.emailAuthHash;\n        }\n        if (this.pushDeviceRecordId) {\n            serializedBundle.device_player_id = this.pushDeviceRecordId;\n        }\n        return serializedBundle;\n    }\n    deserialize(_) { throw new NotImplementedError(); }\n}\n//# sourceMappingURL=EmailDeviceRecord.js.map","import { OneSignalApiErrorKind, OneSignalApiError } from './errors/OneSignalApiError';\nimport { EmailDeviceRecord } from './models/EmailDeviceRecord';\nimport OneSignalApiBase from \"./OneSignalApiBase\";\nimport Utils from \"./context/shared/utils/Utils\";\nimport Log from \"./libraries/Log\";\nexport default class OneSignalApiShared {\n    static getPlayer(appId, playerId) {\n        Utils.enforceAppId(appId);\n        Utils.enforcePlayerId(playerId);\n        return OneSignalApiBase.get(`players/${playerId}?app_id=${appId}`);\n    }\n    static updatePlayer(appId, playerId, options) {\n        Utils.enforceAppId(appId);\n        Utils.enforcePlayerId(playerId);\n        return OneSignalApiBase.put(`players/${playerId}`, Object.assign({ app_id: appId }, options));\n    }\n    static sendNotification(appId, playerIds, titles, contents, url, icon, data, buttons) {\n        var params = {\n            app_id: appId,\n            contents: contents,\n            include_player_ids: playerIds,\n            isAnyWeb: true,\n            data: data,\n            web_buttons: buttons\n        };\n        if (titles) {\n            params.headings = titles;\n        }\n        if (url) {\n            params.url = url;\n        }\n        if (icon) {\n            params.chrome_web_icon = icon;\n            params.firefox_icon = icon;\n        }\n        Utils.trimUndefined(params);\n        return OneSignalApiBase.post('notifications', params);\n    }\n    static async createUser(deviceRecord) {\n        const serializedDeviceRecord = deviceRecord.serialize();\n        Utils.enforceAppId(serializedDeviceRecord.app_id);\n        const response = await OneSignalApiBase.post(`players`, serializedDeviceRecord);\n        if (response && response.success)\n            return response.id;\n        return null;\n    }\n    static async createEmailRecord(appConfig, emailProfile, pushDeviceRecordId) {\n        Utils.enforceAppId(appConfig.appId);\n        const emailRecord = new EmailDeviceRecord(emailProfile.emailAddress, emailProfile.emailAuthHash, pushDeviceRecordId);\n        emailRecord.appId = appConfig.appId;\n        const response = await OneSignalApiBase.post(`players`, emailRecord.serialize());\n        if (response && response.success) {\n            return response.id;\n        }\n        else {\n            return null;\n        }\n    }\n    static async updateEmailRecord(appConfig, emailProfile, pushDeviceRecordId) {\n        Utils.enforceAppId(appConfig.appId);\n        Utils.enforcePlayerId(emailProfile.emailId);\n        const emailRecord = new EmailDeviceRecord(emailProfile.emailAddress, emailProfile.emailAuthHash, pushDeviceRecordId);\n        emailRecord.appId = appConfig.appId;\n        const response = await OneSignalApiBase.put(`players/${emailProfile.emailId}`, emailRecord.serialize());\n        if (response && response.success) {\n            return response.id;\n        }\n        else {\n            return null;\n        }\n    }\n    static async logoutEmail(appConfig, emailProfile, deviceId) {\n        Utils.enforceAppId(appConfig.appId);\n        Utils.enforcePlayerId(deviceId);\n        const response = await OneSignalApiBase.post(`players/${deviceId}/email_logout`, {\n            app_id: appConfig.appId,\n            parent_player_id: emailProfile.emailId,\n            email_auth_hash: emailProfile.emailAuthHash ? emailProfile.emailAuthHash : undefined\n        });\n        if (response && response.success) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    static async updateUserSession(userId, deviceRecord) {\n        try {\n            const serializedDeviceRecord = deviceRecord.serialize();\n            Utils.enforceAppId(serializedDeviceRecord.app_id);\n            Utils.enforcePlayerId(userId);\n            const response = await OneSignalApiBase.post(`players/${userId}/on_session`, serializedDeviceRecord);\n            if (response.id) {\n                // A new user ID can be returned\n                return response.id;\n            }\n            else {\n                return userId;\n            }\n        }\n        catch (e) {\n            if (e && Array.isArray(e.errors) && e.errors.length > 0 &&\n                Utils.contains(e.errors[0], 'app_id not found')) {\n                throw new OneSignalApiError(OneSignalApiErrorKind.MissingAppId);\n            }\n            else\n                throw e;\n        }\n    }\n    static async sendOutcome(data) {\n        Log.info(\"Outcome payload:\", data);\n        try {\n            await OneSignalApiBase.post(\"outcomes/measure\", data);\n        }\n        catch (e) {\n            Log.error(\"sendOutcome\", e);\n        }\n    }\n}\n//# sourceMappingURL=OneSignalApiShared.js.map","import OneSignalError from \"./OneSignalError\";\nexport var SdkInitErrorKind;\n(function (SdkInitErrorKind) {\n    SdkInitErrorKind[SdkInitErrorKind[\"InvalidAppId\"] = 0] = \"InvalidAppId\";\n    SdkInitErrorKind[SdkInitErrorKind[\"AppNotConfiguredForWebPush\"] = 1] = \"AppNotConfiguredForWebPush\";\n    SdkInitErrorKind[SdkInitErrorKind[\"MissingSubdomain\"] = 2] = \"MissingSubdomain\";\n    SdkInitErrorKind[SdkInitErrorKind[\"WrongSiteUrl\"] = 3] = \"WrongSiteUrl\";\n    SdkInitErrorKind[SdkInitErrorKind[\"MultipleInitialization\"] = 4] = \"MultipleInitialization\";\n    SdkInitErrorKind[SdkInitErrorKind[\"MissingSafariWebId\"] = 5] = \"MissingSafariWebId\";\n    SdkInitErrorKind[SdkInitErrorKind[\"Unknown\"] = 6] = \"Unknown\";\n})(SdkInitErrorKind || (SdkInitErrorKind = {}));\nexport class SdkInitError extends OneSignalError {\n    constructor(reason, extra) {\n        switch (reason) {\n            case SdkInitErrorKind.InvalidAppId:\n                super('OneSignal: This app ID does not match any existing app. Double check your app ID.');\n                break;\n            case SdkInitErrorKind.AppNotConfiguredForWebPush:\n                super('OneSignal: This app ID does not have any web platforms enabled. Double check your app ID, or see step 1 on our setup guide (https://goo.gl/01h7fZ).');\n                break;\n            case SdkInitErrorKind.MissingSubdomain:\n                super('OneSignal: Non-HTTPS pages require a subdomain of OneSignal to be chosen on your dashboard. See step 1.4 on our setup guide (https://goo.gl/xip6JB).');\n                break;\n            case SdkInitErrorKind.WrongSiteUrl:\n                if (extra && extra.siteUrl) {\n                    super(`OneSignal: This web push config can only be used on ${new URL(extra.siteUrl).origin}. Your current origin is ${location.origin}.`);\n                }\n                else {\n                    super('OneSignal: This web push config can not be used on the current site.');\n                }\n                break;\n            case SdkInitErrorKind.MultipleInitialization:\n                super('OneSignal: The OneSignal web SDK can only be initialized once. Extra initializations are ignored. Please remove calls initializing the SDK more than once.');\n                break;\n            case SdkInitErrorKind.MissingSafariWebId:\n                super('OneSignal: Safari browser support on Mac OS X requires the Safari web platform to be enabled. Please see the Safari Support steps in our web setup guide.');\n                break;\n            case SdkInitErrorKind.Unknown:\n                super('OneSignal: An unknown initialization error occurred.');\n                break;\n        }\n        this.reason = SdkInitErrorKind[reason];\n        /**\n         * Important! Required to make sure the correct error type is detected during instanceof checks.\n         * Same applies to all derived classes.\n         * https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n         */\n        Object.setPrototypeOf(this, SdkInitError.prototype);\n    }\n}\n//# sourceMappingURL=SdkInitError.js.map","export var OutcomeAttributionType;\n(function (OutcomeAttributionType) {\n    OutcomeAttributionType[OutcomeAttributionType[\"Direct\"] = 1] = \"Direct\";\n    OutcomeAttributionType[OutcomeAttributionType[\"Indirect\"] = 2] = \"Indirect\";\n    OutcomeAttributionType[OutcomeAttributionType[\"Unattributed\"] = 3] = \"Unattributed\";\n    OutcomeAttributionType[OutcomeAttributionType[\"NotSupported\"] = 4] = \"NotSupported\";\n})(OutcomeAttributionType || (OutcomeAttributionType = {}));\n//# sourceMappingURL=Outcomes.js.map","import OneSignalError from \"./OneSignalError\";\nexport var OneSignalApiErrorKind;\n(function (OneSignalApiErrorKind) {\n    OneSignalApiErrorKind[OneSignalApiErrorKind[\"MissingAppId\"] = 0] = \"MissingAppId\";\n})(OneSignalApiErrorKind || (OneSignalApiErrorKind = {}));\nexport class OneSignalApiError extends OneSignalError {\n    constructor(reason) {\n        switch (reason) {\n            case OneSignalApiErrorKind.MissingAppId:\n                super('The API call is missing an app ID.');\n                break;\n        }\n        /**\n         * Important! Required to make sure the correct error type is detected during instanceof checks.\n         * Same applies to all derived classes.\n         * https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n         */\n        Object.setPrototypeOf(this, OneSignalApiError.prototype);\n    }\n}\n//# sourceMappingURL=OneSignalApiError.js.map","import { NotificationPermission } from '../models/NotificationPermission';\nimport PermissionManager from '../managers/PermissionManager';\nconst IS_OPTED_OUT = \"isOptedOut\";\nconst IS_PUSH_NOTIFICATIONS_ENABLED = \"isPushNotificationsEnabled\";\nconst PAGE_VIEWS = \"os_pageViews\";\nexport default class LocalStorage {\n    static getIsOptedOut() {\n        return localStorage.getItem(IS_OPTED_OUT) === \"true\";\n    }\n    static getIsPushNotificationsEnabled() {\n        return localStorage.getItem(IS_PUSH_NOTIFICATIONS_ENABLED) === \"true\";\n    }\n    static setIsOptedOut(value) {\n        localStorage.setItem(IS_OPTED_OUT, value.toString());\n    }\n    static setIsPushNotificationsEnabled(value) {\n        localStorage.setItem(IS_PUSH_NOTIFICATIONS_ENABLED, value.toString());\n    }\n    static setStoredPermission(value) {\n        localStorage.setItem(PermissionManager.STORED_PERMISSION_KEY, value);\n    }\n    static getStoredPermission() {\n        var permission = localStorage.getItem(PermissionManager.STORED_PERMISSION_KEY) || \"default\";\n        switch (permission) {\n            case \"granted\":\n                return NotificationPermission.Granted;\n            case \"denied\":\n                return NotificationPermission.Denied;\n            default:\n                return NotificationPermission.Default;\n        }\n    }\n    static setLocalPageViewCount(count) {\n        localStorage.setItem(PAGE_VIEWS, count.toString());\n    }\n    static getLocalPageViewCount() {\n        return Number(localStorage.getItem(PAGE_VIEWS));\n    }\n}\n//# sourceMappingURL=LocalStorage.js.map","import Database from \"../services/Database\";\nimport Event from '../Event';\nexport class PermissionUtils {\n    static async triggerNotificationPermissionChanged(updateIfIdentical = false) {\n        const newPermission = await OneSignal.privateGetNotificationPermission();\n        const previousPermission = await Database.get('Options', 'notificationPermission');\n        const shouldBeUpdated = newPermission !== previousPermission || updateIfIdentical;\n        if (!shouldBeUpdated) {\n            return;\n        }\n        await Database.put('Options', { key: 'notificationPermission', value: newPermission });\n        Event.trigger(OneSignal.EVENTS.NATIVE_PROMPT_PERMISSIONCHANGED, { to: newPermission });\n    }\n}\n//# sourceMappingURL=PermissionUtils.js.map","import bowser from 'bowser';\nimport NotImplementedError from '../errors/NotImplementedError';\nimport { SubscriptionStateKind } from './SubscriptionStateKind';\nimport { DeviceRecord } from './DeviceRecord';\n/**\n * Describes a push notification device record.\n */\nexport class PushDeviceRecord extends DeviceRecord {\n    /**\n     * @param subscription Omitting this parameter does not void the record's identifier.\n     */\n    constructor(subscription) {\n        super();\n        this.subscription = subscription;\n    }\n    serialize() {\n        const serializedBundle = super.serialize();\n        if (this.subscription) {\n            serializedBundle.identifier = bowser.safari ?\n                this.subscription.safariDeviceToken :\n                this.subscription.w3cEndpoint ? this.subscription.w3cEndpoint.toString() : null;\n            serializedBundle.web_auth = this.subscription.w3cAuth;\n            serializedBundle.web_p256 = this.subscription.w3cP256dh;\n        }\n        return serializedBundle;\n    }\n    static createFromPushSubscription(appId, rawPushSubscription, subscriptionState) {\n        const pushRegistration = new PushDeviceRecord(rawPushSubscription);\n        pushRegistration.appId = appId;\n        pushRegistration.subscriptionState = rawPushSubscription ?\n            SubscriptionStateKind.Subscribed :\n            SubscriptionStateKind.NotSubscribed;\n        if (subscriptionState) {\n            pushRegistration.subscriptionState = subscriptionState;\n        }\n        return pushRegistration;\n    }\n    deserialize(_) { throw new NotImplementedError(); }\n}\n//# sourceMappingURL=PushDeviceRecord.js.map","import { OneSignalApiBase } from \"./OneSignalApiBase\";\nimport { SubscriptionStateKind } from \"./models/SubscriptionStateKind\";\nimport Log from \"./libraries/Log\";\nimport { Utils } from \"./context/shared/utils/Utils\";\nimport { OutcomeAttributionType } from \"./models/Outcomes\";\nexport class OneSignalApiSW {\n    static async downloadServerAppConfig(appId) {\n        Utils.enforceAppId(appId);\n        return await new Promise((resolve, _reject) => {\n            resolve(OneSignalApiBase.get(`sync/${appId}/web`, null));\n        });\n    }\n    /**\n     * Given a GCM or Firefox subscription endpoint or Safari device token, returns the user ID from OneSignal's server.\n     * Used if the user clears his or her IndexedDB database and we need the user ID again.\n     */\n    static getUserIdFromSubscriptionIdentifier(appId, deviceType, identifier) {\n        // Calling POST /players with an existing identifier returns us that player ID\n        Utils.enforceAppId(appId);\n        return OneSignalApiBase.post(\"players\", {\n            app_id: appId,\n            device_type: deviceType,\n            identifier: identifier,\n            notification_types: SubscriptionStateKind.TemporaryWebRecord,\n        }).then((response) => {\n            if (response && response.id) {\n                return response.id;\n            }\n            else {\n                return null;\n            }\n        }).catch(e => {\n            Log.debug(\"Error getting user ID from subscription identifier:\", e);\n            return null;\n        });\n    }\n    static async updatePlayer(appId, playerId, options) {\n        const funcToExecute = async () => {\n            await OneSignalApiBase.put(`players/${playerId}`, Object.assign({ app_id: appId }, options));\n        };\n        return await Utils.enforceAppIdAndPlayerId(appId, playerId, funcToExecute);\n    }\n    static async updateUserSession(userId, serializedDeviceRecord) {\n        const funcToExecute = async () => {\n            const response = await OneSignalApiBase.post(`players/${userId}/on_session`, serializedDeviceRecord);\n            if (response.id) {\n                // A new user ID can be returned\n                return response.id;\n            }\n            else {\n                return userId;\n            }\n        };\n        return await Utils.enforceAppIdAndPlayerId(serializedDeviceRecord.app_id, userId, funcToExecute);\n    }\n    ;\n    static async sendSessionDuration(appId, deviceId, sessionDuration, deviceType, attribution) {\n        const funcToExecute = async () => {\n            const payload = {\n                app_id: appId,\n                type: 1,\n                state: \"ping\",\n                active_time: sessionDuration,\n                device_type: deviceType,\n            };\n            switch (attribution.type) {\n                case OutcomeAttributionType.Direct:\n                    payload.direct = true;\n                    payload.notification_ids = attribution.notificationIds;\n                    break;\n                case OutcomeAttributionType.Indirect:\n                    payload.direct = false;\n                    payload.notification_ids = attribution.notificationIds;\n                    break;\n                default:\n                    break;\n            }\n            await OneSignalApiBase.post(`players/${deviceId}/on_focus`, payload);\n        };\n        Utils.enforceAppIdAndPlayerId(appId, deviceId, funcToExecute);\n    }\n}\nexport default OneSignalApiSW;\n//# sourceMappingURL=OneSignalApiSW.js.map","export var DeliveryPlatformKind;\n(function (DeliveryPlatformKind) {\n    DeliveryPlatformKind[DeliveryPlatformKind[\"ChromeLike\"] = 5] = \"ChromeLike\";\n    DeliveryPlatformKind[DeliveryPlatformKind[\"Safari\"] = 7] = \"Safari\";\n    DeliveryPlatformKind[DeliveryPlatformKind[\"Firefox\"] = 8] = \"Firefox\";\n    DeliveryPlatformKind[DeliveryPlatformKind[\"Edge\"] = 12] = \"Edge\";\n    DeliveryPlatformKind[DeliveryPlatformKind[\"Email\"] = 11] = \"Email\";\n})(DeliveryPlatformKind || (DeliveryPlatformKind = {}));\n//# sourceMappingURL=DeliveryPlatformKind.js.map","import bowser from 'bowser';\nimport Environment from '../Environment';\nimport NotImplementedError from '../errors/NotImplementedError';\nimport { DeliveryPlatformKind } from './DeliveryPlatformKind';\nimport { OneSignalUtils } from \"../utils/OneSignalUtils\";\n/**\n * Describes the fields of a OneSignal \"player\" device record.\n *\n * This is used when creating or modifying push and email records.\n */\nexport class DeviceRecord {\n    constructor() {\n        // TODO: Possible implementation for appId initialization\n        // this.appId = OneSignal.context.appConfig.appId;\n        this.language = Environment.getLanguage();\n        this.timezone = new Date().getTimezoneOffset() * -60;\n        const browserVersion = parseInt(String(bowser.version), 10);\n        this.browserVersion = isNaN(browserVersion) ? -1 : browserVersion;\n        this.deviceModel = navigator.platform;\n        this.sdkVersion = Environment.version().toString();\n        this.deliveryPlatform = this.getDeliveryPlatform();\n        // Unimplemented properties are appId, subscriptionState, and subscription\n    }\n    isSafari() {\n        return bowser.safari && window.safari !== undefined && window.safari.pushNotification !== undefined;\n    }\n    getDeliveryPlatform() {\n        // For testing purposes, allows changing the browser user agent\n        const browser = OneSignalUtils.redetectBrowserUserAgent();\n        if (this.isSafari()) {\n            return DeliveryPlatformKind.Safari;\n        }\n        else if (browser.firefox) {\n            return DeliveryPlatformKind.Firefox;\n        }\n        else if (browser.msedge) {\n            return DeliveryPlatformKind.Edge;\n        }\n        else {\n            return DeliveryPlatformKind.ChromeLike;\n        }\n    }\n    serialize() {\n        const serializedBundle = {\n            device_type: this.deliveryPlatform,\n            language: this.language,\n            timezone: this.timezone,\n            device_os: this.browserVersion,\n            device_model: this.deviceModel,\n            sdk: this.sdkVersion,\n            notification_types: this.subscriptionState,\n        };\n        if (this.appId) {\n            serializedBundle.app_id = this.appId;\n        }\n        return serializedBundle;\n    }\n    deserialize(_) { throw new NotImplementedError(); }\n}\n//# sourceMappingURL=DeviceRecord.js.map","import Log from \"../../libraries/sw/Log\";\nconst doNothing = () => {\n    Log.debug(\"Do nothing\");\n};\nexport function cancelableTimeout(callback, delayInSeconds) {\n    const delayInMilliseconds = delayInSeconds * 1000;\n    let timerId;\n    let clearTimeoutHandle = undefined;\n    const promise = new Promise((resolve, reject) => {\n        let startedExecution = false;\n        timerId = self.setTimeout(async () => {\n            startedExecution = true;\n            try {\n                await callback();\n                resolve();\n            }\n            catch (e) {\n                Log.error(\"Failed to execute callback\", e);\n                reject();\n            }\n        }, delayInMilliseconds);\n        clearTimeoutHandle = () => {\n            Log.debug(\"Cancel called\");\n            self.clearTimeout(timerId);\n            if (!startedExecution) {\n                resolve();\n            }\n        };\n    });\n    if (!clearTimeoutHandle) {\n        Log.warn(\"clearTimeoutHandle was not assigned.\");\n        return {\n            promise,\n            cancel: doNothing,\n        };\n    }\n    return {\n        promise,\n        cancel: clearTimeoutHandle,\n    };\n}\n//# sourceMappingURL=CancelableTimeout.js.map","export var TestEnvironmentKind;\n(function (TestEnvironmentKind) {\n    TestEnvironmentKind[\"None\"] = \"None\";\n    TestEnvironmentKind[\"UnitTesting\"] = \"Unit Testing\";\n})(TestEnvironmentKind || (TestEnvironmentKind = {}));\n//# sourceMappingURL=TestEnvironmentKind.js.map","import SdkEnvironment from \"../managers/SdkEnvironment\";\nimport { WindowEnvironmentKind } from \"../models/WindowEnvironmentKind\";\nimport Log from \"../libraries/Log\";\nimport LocalStorage from '../utils/LocalStorage';\nexport class PageViewManager {\n    constructor() {\n        this.incrementedPageViewCount = false;\n    }\n    getPageViewCount() {\n        try {\n            /*\n              sessionStorage may be supported by the browser but may not be available\n              as an API in incognito mode and in cases where the user disables\n              third-party cookies on some browsers.\n             */\n            const pageViewCountStr = sessionStorage.getItem(PageViewManager.SESSION_STORAGE_KEY_NAME);\n            const pageViewCount = pageViewCountStr ? parseInt(pageViewCountStr) : 0;\n            if (isNaN(pageViewCount)) {\n                return 0;\n            }\n            else {\n                return pageViewCount;\n            }\n        }\n        catch (e) {\n            /*\n              If we're in incognito mode or sessionStorage is otherwise unsupported,\n              pretend we're starting our first session.\n             */\n            return 0;\n        }\n    }\n    setPageViewCount(sessionCount) {\n        try {\n            sessionStorage.setItem(PageViewManager.SESSION_STORAGE_KEY_NAME, sessionCount.toString());\n            if (SdkEnvironment.getWindowEnv() === WindowEnvironmentKind.OneSignalSubscriptionPopup) {\n                // If we're setting sessionStorage and we're in an Popup, we need to also set sessionStorage on the\n                // main page\n                if (OneSignal.subscriptionPopup) {\n                    OneSignal.subscriptionPopup.message(OneSignal.POSTMAM_COMMANDS.SET_SESSION_COUNT);\n                }\n            }\n        }\n        catch (e) {\n            /*\n              If sessionStorage isn't available, don't error.\n             */\n        }\n    }\n    /**\n     * Increments:\n     *    - session pageView count AND\n     *    - total pageView count\n     *\n     * at most once for the current page view.\n     *\n     * A flag is set to prevent incrementing the session count more than once for\n     * the current page view. If the page is refreshed, this in-memory variable\n     * will be automatically reset. Because of this, regardless of the number of\n     * times this method is called on the current page view, the page view count\n     * will only be incremented once.\n     *\n     * LocalStorage pageView count added for use in Delayed Prompts feature. This\n     * pageView count persists even past sessions since it is saved to local stor-\n     * age (as opposed to Session Storage which persists only for that tab)\n     */\n    incrementPageViewCount() {\n        if (this.incrementedPageViewCount) {\n            // For this method, we don't want to increment the session count more than\n            // once per pageview\n            return;\n        }\n        const newCountSingleTab = this.getPageViewCount() + 1;\n        const newCountAcrossTabs = this.getLocalPageViewCount() + 1;\n        this.setPageViewCount(newCountSingleTab);\n        this.setLocalPageViewCount(newCountAcrossTabs);\n        this.incrementedPageViewCount = true;\n        Log.debug(`Incremented page view count: newCountSingleTab: ${newCountSingleTab},\n      newCountAccrossTabs: ${newCountAcrossTabs}.`);\n    }\n    simulatePageNavigationOrRefresh() {\n        this.incrementedPageViewCount = false;\n    }\n    /**\n     * Returns true if this page is running OneSignal for the first time and has\n     * not been navigated or refreshed.\n     */\n    isFirstPageView() {\n        return this.getPageViewCount() === 1;\n    }\n    /**\n     * Returns Page Views saved to Local Storage (Persists Longer than Single Session)\n     */\n    getLocalPageViewCount() {\n        return LocalStorage.getLocalPageViewCount();\n    }\n    /**\n     * Sets Page Views to Local Storage\n     */\n    setLocalPageViewCount(count) {\n        LocalStorage.setLocalPageViewCount(count);\n    }\n}\nPageViewManager.SESSION_STORAGE_KEY_NAME = \"onesignal-pageview-count\";\n//# sourceMappingURL=PageViewManager.js.map","import { InvalidArgumentError, InvalidArgumentReason } from '../errors/InvalidArgumentError';\n/**\n * Represents a normalized path.\n *\n * Paths spaces are trimmed.\n * Paths without file names will never contain trailing slashes, except for empty paths.\n */\nexport default class Path {\n    constructor(path) {\n        if (!path)\n            throw new InvalidArgumentError('path', InvalidArgumentReason.Empty);\n        this.path = path.trim();\n    }\n    getQueryString() {\n        // If there are no ? characters, return null\n        // If there are multiple ?, return the substring starting after the first ? all the way to the end\n        const indexOfDelimiter = this.path.indexOf('?');\n        if (indexOfDelimiter === -1) {\n            return null;\n        }\n        if (this.path.length > indexOfDelimiter) {\n            // Return the substring *after the first ? to the end\n            return this.path.substring(indexOfDelimiter + 1);\n        }\n        else {\n            // The last character is ?\n            return null;\n        }\n    }\n    getWithoutQueryString() {\n        return this.path.split(Path.QUERY_STRING)[0];\n    }\n    getFileName() {\n        return this.getWithoutQueryString().split('\\\\').pop().split('/').pop();\n    }\n    getFileNameWithQuery() {\n        return this.path.split('\\\\').pop().split('/').pop();\n    }\n    getFullPath() {\n        return this.path;\n    }\n    getPathWithoutFileName() {\n        const newPath = this.getWithoutQueryString();\n        const fileNameIndex = newPath.lastIndexOf(this.getFileName());\n        let pathWithoutFileName = newPath.substring(0, fileNameIndex);\n        pathWithoutFileName = pathWithoutFileName.replace(/[\\\\\\/]$/, '');\n        return pathWithoutFileName;\n    }\n}\nPath.QUERY_STRING = '?';\n//# sourceMappingURL=Path.js.map","import OneSignalError from './OneSignalError';\nexport class ServiceWorkerRegistrationError extends OneSignalError {\n    constructor(status, statusText) {\n        super(`Registration of a Service Worker failed.`);\n        this.status = status;\n        this.statusText = statusText;\n        /**\n         * Important! Required to make sure the correct error type is detected during instanceof checks.\n         * Same applies to all derived classes.\n         * https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n         */\n        Object.setPrototypeOf(this, ServiceWorkerRegistrationError.prototype);\n    }\n}\nexport default ServiceWorkerRegistrationError;\n//# sourceMappingURL=ServiceWorkerRegistrationError.js.map","import Environment from '../Environment';\nimport { WorkerMessengerCommand } from '../libraries/WorkerMessenger';\nimport Path from '../models/Path';\nimport SdkEnvironment from '../managers/SdkEnvironment';\nimport Database from '../services/Database';\nimport { IntegrationKind } from '../models/IntegrationKind';\nimport { WindowEnvironmentKind } from '../models/WindowEnvironmentKind';\nimport NotImplementedError from '../errors/NotImplementedError';\nimport Log from '../libraries/Log';\nimport Event from '../Event';\nimport ServiceWorkerRegistrationError from \"../errors/ServiceWorkerRegistrationError\";\nimport OneSignalUtils from \"../utils/OneSignalUtils\";\nimport ServiceWorkerHelper, { ServiceWorkerActiveState } from \"../helpers/ServiceWorkerHelper\";\nimport { Utils } from \"../context/shared/utils/Utils\";\nexport class ServiceWorkerManager {\n    constructor(context, config) {\n        this.context = context;\n        this.config = config;\n    }\n    // Gets details on the service-worker (if any) that controls the current page\n    static async getRegistration() {\n        return await ServiceWorkerHelper.getRegistration();\n    }\n    async getActiveState() {\n        /*\n          Note: This method can only be called on a secure origin. On an insecure\n          origin, it'll throw on getRegistration().\n        */\n        /*\n          We want to find out if the *current* page is currently controlled by an\n          active service worker.\n    \n          There are three ways (sort of) to do this:\n            - getRegistration()\n            - getRegistrations()\n            - navigator.serviceWorker.ready\n    \n          We want to use getRegistration(), since it will not return a value if the\n          page is not currently controlled by an active service worker.\n    \n          getRegistrations() returns all service worker registrations under the\n          origin (i.e. registrations in nested folders).\n    \n          navigator.serviceWorker.ready will hang indefinitely and never resolve if\n          no registration is active.\n        */\n        const integration = await SdkEnvironment.getIntegration();\n        if (integration === IntegrationKind.InsecureProxy) {\n            /* Service workers are not accessible on insecure origins */\n            return ServiceWorkerActiveState.Indeterminate;\n        }\n        else if (integration === IntegrationKind.SecureProxy) {\n            /* If the site setup is secure proxy, we're either on the top frame without access to the\n            registration, or the child proxy frame that does have access to the registration. */\n            const env = SdkEnvironment.getWindowEnv();\n            switch (env) {\n                case WindowEnvironmentKind.Host:\n                case WindowEnvironmentKind.CustomIframe:\n                    /* Both these top-ish frames will need to ask the proxy frame to access the service worker\n                    registration */\n                    const proxyFrameHost = OneSignal.proxyFrameHost;\n                    if (!proxyFrameHost) {\n                        /* On init, this function may be called. Return a null state for now */\n                        return ServiceWorkerActiveState.Indeterminate;\n                    }\n                    else {\n                        return await proxyFrameHost.runCommand(OneSignal.POSTMAM_COMMANDS.SERVICE_WORKER_STATE);\n                    }\n                case WindowEnvironmentKind.OneSignalSubscriptionPopup:\n                    /* This is a top-level frame, so it can access the service worker registration */\n                    break;\n                case WindowEnvironmentKind.OneSignalSubscriptionModal:\n                    throw new NotImplementedError();\n            }\n        }\n        const workerRegistration = await ServiceWorkerManager.getRegistration();\n        if (!workerRegistration) {\n            /*\n              A site may have a service worker nested at /folder1/folder2/folder3, while the user is\n              currently on /folder1. The nested service worker does not control /folder1 though. Although\n              the nested service worker can receive push notifications without issue, it cannot perform\n              other SDK operations like checking whether existing tabs are optn eo the site on /folder1\n              (used to prevent opening unnecessary new tabs on notification click.)\n      \n              Because we rely on being able to communicate with the service worker for SDK operations, we\n              only say we're active if the service worker directly controls this page.\n             */\n            return ServiceWorkerActiveState.None;\n        }\n        else if (workerRegistration.installing) {\n            /*\n              Workers that are installing block for a while, since we can't use them until they're done\n              installing.\n             */\n            return ServiceWorkerActiveState.Installing;\n        }\n        else if (!workerRegistration.active) {\n            /*\n              Workers that are waiting won't be our service workers, since we use clients.claim() and\n              skipWaiting() to bypass the install and waiting stages.\n             */\n            return ServiceWorkerActiveState.ThirdParty;\n        }\n        // At this point, there is an active service worker registration controlling this page.\n        // We are now; 1. Getting the filename of the SW; 2. Checking if it is ours or a 3rd parties.\n        const swFileName = ServiceWorkerManager.activeSwFileName(workerRegistration);\n        const workerState = this.swActiveStateByFileName(swFileName);\n        /*\n          Our service worker registration can be both active and in the controlling scope of the current\n          page, but if the page was hard refreshed to bypass the cache (e.g. Ctrl + Shift + R), a\n          service worker will not control the page.\n    \n          For a third-party service worker, if it does not call clients.claim(), even if its\n          registration is both active and in the controlling scope of the current page,\n          navigator.serviceWorker.controller will still be null on the first page visit. So we only\n          check if the controller is null for our worker, which we know uses clients.claim().\n         */\n        if (!navigator.serviceWorker.controller && (workerState === ServiceWorkerActiveState.WorkerA ||\n            workerState === ServiceWorkerActiveState.WorkerB))\n            return ServiceWorkerActiveState.Bypassed;\n        return workerState;\n    }\n    // Get the file name of the active ServiceWorker\n    static activeSwFileName(workerRegistration) {\n        if (!workerRegistration.active)\n            return null;\n        const workerScriptPath = new URL(workerRegistration.active.scriptURL).pathname;\n        const swFileName = new Path(workerScriptPath).getFileName();\n        // If the current service worker is Akamai's\n        if (swFileName == \"akam-sw.js\") {\n            // Check if its importing a ServiceWorker under it's \"othersw\" query param\n            const searchParams = new URLSearchParams(new URL(workerRegistration.active.scriptURL).search);\n            const importedSw = searchParams.get(\"othersw\");\n            if (importedSw) {\n                Log.debug(\"Found a ServiceWorker under Akamai's akam-sw.js?othersw=\", importedSw);\n                return new Path(new URL(importedSw).pathname).getFileName();\n            }\n        }\n        return swFileName;\n    }\n    // Check if the ServiceWorker file name is ours or a third party's\n    swActiveStateByFileName(fileName) {\n        if (!fileName)\n            return ServiceWorkerActiveState.None;\n        if (fileName == this.config.workerAPath.getFileName())\n            return ServiceWorkerActiveState.WorkerA;\n        if (fileName == this.config.workerBPath.getFileName())\n            return ServiceWorkerActiveState.WorkerB;\n        return ServiceWorkerActiveState.ThirdParty;\n    }\n    async getWorkerVersion() {\n        return new Promise(async (resolve) => {\n            if (OneSignalUtils.isUsingSubscriptionWorkaround()) {\n                const proxyFrameHost = OneSignal.proxyFrameHost;\n                if (!proxyFrameHost) {\n                    /* On init, this function may be called. Return a null state for now */\n                    resolve(NaN);\n                }\n                else {\n                    const proxyWorkerVersion = await proxyFrameHost.runCommand(OneSignal.POSTMAM_COMMANDS.GET_WORKER_VERSION);\n                    resolve(proxyWorkerVersion);\n                }\n            }\n            else {\n                this.context.workerMessenger.once(WorkerMessengerCommand.WorkerVersion, workerVersion => {\n                    resolve(workerVersion);\n                });\n                this.context.workerMessenger.unicast(WorkerMessengerCommand.WorkerVersion);\n            }\n        });\n    }\n    async shouldInstallWorker() {\n        if (!Environment.supportsServiceWorkers())\n            return false;\n        if (!OneSignal.config)\n            return false;\n        if (OneSignal.config.subdomain) {\n            // No, if configured to use our subdomain (AKA HTTP setup) AND this is on their page (HTTP or HTTPS).\n            // But since safari does not need subscription workaround, installing SW for session tracking.\n            if (OneSignal.environmentInfo.browserType !== \"safari\" &&\n                SdkEnvironment.getWindowEnv() === WindowEnvironmentKind.Host) {\n                return false;\n            }\n        }\n        const workerState = await this.getActiveState();\n        // If there isn't a SW or it isn't OneSignal's only install our SW if notification permissions are enabled\n        // This prevents an unnessary install which saves bandwidth\n        if (workerState === ServiceWorkerActiveState.None || workerState === ServiceWorkerActiveState.ThirdParty) {\n            const permission = await OneSignal.context.permissionManager.getNotificationPermission(OneSignal.config.safariWebId);\n            return permission === \"granted\";\n        }\n        return this.workerNeedsUpdate();\n    }\n    /**\n     * Performs a service worker update by swapping out the current service worker\n     * with a content-identical but differently named alternate service worker\n     * file.\n     */\n    async workerNeedsUpdate() {\n        Log.info(\"[Service Worker Update] Checking service worker version...\");\n        let workerVersion;\n        try {\n            workerVersion = await Utils.timeoutPromise(this.getWorkerVersion(), 2000);\n        }\n        catch (e) {\n            Log.info(\"[Service Worker Update] Worker did not reply to version query; assuming older version and updating.\");\n            return true;\n        }\n        if (workerVersion !== Environment.version()) {\n            Log.info(`[Service Worker Update] Updating service worker from ${workerVersion} --> ${Environment.version()}.`);\n            return true;\n        }\n        Log.info(`[Service Worker Update] Service worker version is current at ${workerVersion} (no update required).`);\n        return false;\n    }\n    /**\n     * Installs a newer version of the OneSignal service worker.\n     *\n     * We have a couple different models of installing service workers:\n     *\n     * a) Originally, we provided users with two worker files:\n     * OneSignalSDKWorker.js and OneSignalSDKUpdaterWorker.js. Two workers were\n     * provided so each could be swapped with the other when the worker needed to\n     * update. The contents of both workers were identical; only the filenames\n     * were different, which is enough to update the worker.\n     *\n     * b) With AMP web push, users are to specify only the first worker file\n     * OneSignalSDKWorker.js, with an app ID parameter ?appId=12345. AMP web push\n     * is vendor agnostic and doesn't know about OneSignal, so all relevant\n     * information has to be passed to the service worker, which is the only\n     * vendor-specific file. So the service worker being installed is always\n     * OneSignalSDKWorker.js?appId=12345 and never OneSignalSDKUpdaterWorker.js.\n     * If AMP web push sees another worker like OneSignalSDKUpdaterWorker.js, or\n     * even the same OneSignalSDKWorker.js without the app ID query parameter, the\n     * user is considered unsubscribed.\n     *\n     * c) Due to b's restriction, we must always install\n     * OneSignalSDKWorker.js?appId=xxx. We also have to appropriately handle\n     * legacy cases:\n     *\n     *    c-1) Where developers have OneSignalSDKWorker.js or\n     *    OneSignalSDKUpdaterWorker.js alternatingly installed\n     *\n     *    c-2) Where developers running progressive web apps force-register\n     *    OneSignalSDKWorker.js\n     *\n     * Actually, users can customize the file names of Worker A / Worker B, but\n     * it's up to them to be consistent with their naming. For AMP web push, users\n     * can specify the full string to expect for the service worker. They can add\n     * additional query parameters, but this must then stay consistent.\n     *\n     * Installation Procedure\n     * ----------------------\n     *\n     * Worker A is always installed. If Worker A is already installed, Worker B is\n     * installed first, and then Worker A is installed again. This is necessary\n     * because AMP web push requires Worker A to be installed for the user to be\n     * considered subscribed.\n     */\n    async installWorker() {\n        if (!await this.shouldInstallWorker()) {\n            return;\n        }\n        const preInstallWorkerState = await this.getActiveState();\n        await this.installAlternatingWorker();\n        await new Promise(async (resolve) => {\n            const postInstallWorkerState = await this.getActiveState();\n            Log.debug(\"installWorker - Comparing pre and post states\", preInstallWorkerState, postInstallWorkerState);\n            if (preInstallWorkerState !== postInstallWorkerState &&\n                postInstallWorkerState !== ServiceWorkerActiveState.Installing) {\n                resolve();\n            }\n            else {\n                Log.debug(\"installWorker - Awaiting on navigator.serviceWorker's 'controllerchange' event\");\n                navigator.serviceWorker.addEventListener('controllerchange', async (e) => {\n                    const postInstallWorkerState = await this.getActiveState();\n                    if (postInstallWorkerState !== preInstallWorkerState &&\n                        postInstallWorkerState !== ServiceWorkerActiveState.Installing) {\n                        resolve();\n                    }\n                    else {\n                        Log.error(\"installWorker - SW's 'controllerchange' fired but no state change!\");\n                    }\n                });\n            }\n        });\n        if ((await this.getActiveState()) === ServiceWorkerActiveState.WorkerB) {\n            // If the worker is Worker B, reinstall Worker A\n            await this.installAlternatingWorker();\n        }\n        await this.establishServiceWorkerChannel();\n    }\n    async establishServiceWorkerChannel() {\n        const workerMessenger = this.context.workerMessenger;\n        workerMessenger.off();\n        workerMessenger.on(WorkerMessengerCommand.NotificationDisplayed, data => {\n            Log.debug(location.origin, 'Received notification display event from service worker.');\n            Event.trigger(OneSignal.EVENTS.NOTIFICATION_DISPLAYED, data);\n        });\n        workerMessenger.on(WorkerMessengerCommand.NotificationClicked, async (data) => {\n            let clickedListenerCallbackCount;\n            if (SdkEnvironment.getWindowEnv() === WindowEnvironmentKind.OneSignalProxyFrame) {\n                clickedListenerCallbackCount = await new Promise(resolve => {\n                    const proxyFrame = OneSignal.proxyFrame;\n                    if (proxyFrame) {\n                        proxyFrame.messenger.message(OneSignal.POSTMAM_COMMANDS.GET_EVENT_LISTENER_COUNT, OneSignal.EVENTS.NOTIFICATION_CLICKED, (reply) => {\n                            let callbackCount = reply.data;\n                            resolve(callbackCount);\n                        });\n                    }\n                });\n            }\n            else\n                clickedListenerCallbackCount = OneSignal.emitter.numberOfListeners(OneSignal.EVENTS.NOTIFICATION_CLICKED);\n            if (clickedListenerCallbackCount === 0) {\n                /*\n                  A site's page can be open but not listening to the\n                  notification.clicked event because it didn't call\n                  addListenerForNotificationOpened(). In this case, if there are no\n                  detected event listeners, we should save the event, instead of firing\n                  it without anybody receiving it.\n        \n                  Or, since addListenerForNotificationOpened() only works once (you have\n                  to call it again each time), maybe it was only called once and the\n                  user isn't receiving the notification.clicked event for subsequent\n                  notifications on the same browser tab.\n        \n                  Example: notificationClickHandlerMatch: 'origin', tab is clicked,\n                           event fires without anybody listening, calling\n                           addListenerForNotificationOpened() returns no results even\n                           though a notification was just clicked.\n                */\n                Log.debug('notification.clicked event received, but no event listeners; storing event in IndexedDb for later retrieval.');\n                /* For empty notifications without a URL, use the current document's URL */\n                let url = data.url;\n                if (!data.url) {\n                    // Least likely to modify, since modifying this property changes the page's URL\n                    url = location.href;\n                }\n                await Database.put('NotificationOpened', { url: url, data: data, timestamp: Date.now() });\n            }\n            else\n                Event.trigger(OneSignal.EVENTS.NOTIFICATION_CLICKED, data);\n        });\n        workerMessenger.on(WorkerMessengerCommand.RedirectPage, data => {\n            Log.debug(`${SdkEnvironment.getWindowEnv().toString()} Picked up command.redirect to ${data}, forwarding to host page.`);\n            const proxyFrame = OneSignal.proxyFrame;\n            if (proxyFrame) {\n                proxyFrame.messenger.message(OneSignal.POSTMAM_COMMANDS.SERVICEWORKER_COMMAND_REDIRECT, data);\n            }\n        });\n        workerMessenger.on(WorkerMessengerCommand.NotificationDismissed, data => {\n            Event.trigger(OneSignal.EVENTS.NOTIFICATION_DISMISSED, data);\n        });\n        const isHttps = OneSignalUtils.isHttps();\n        const isSafari = OneSignalUtils.isSafari();\n        workerMessenger.on(WorkerMessengerCommand.AreYouVisible, (incomingPayload) => {\n            // For https sites in Chrome and Firefox service worker (SW) can get correct value directly.\n            // For Safari, unfortunately, we need this messaging workaround because SW always gets false.\n            if (isHttps && isSafari) {\n                const payload = {\n                    timestamp: incomingPayload.timestamp,\n                    focused: document.hasFocus(),\n                };\n                workerMessenger.directPostMessageToSW(WorkerMessengerCommand.AreYouVisibleResponse, payload);\n            }\n            else {\n                const httpPayload = { timestamp: incomingPayload.timestamp };\n                const proxyFrame = OneSignal.proxyFrame;\n                if (proxyFrame) {\n                    proxyFrame.messenger.message(OneSignal.POSTMAM_COMMANDS.ARE_YOU_VISIBLE_REQUEST, httpPayload);\n                }\n            }\n        });\n    }\n    /**\n     * Installs the OneSignal service worker.\n     *\n     * Depending on the existing worker, the alternate swap worker may be\n     * installed or, for 3rd party workers, the existing worker may be uninstalled\n     * before installing ours.\n     */\n    async installAlternatingWorker() {\n        const workerState = await this.getActiveState();\n        if (workerState === ServiceWorkerActiveState.ThirdParty) {\n            Log.info(`[Service Worker Installation] 3rd party service worker detected.`);\n        }\n        const workerFullPath = ServiceWorkerHelper.getServiceWorkerHref(workerState, this.config);\n        const installUrlQueryParams = Utils.encodeHashAsUriComponent({\n            appId: this.context.appConfig.appId\n        });\n        const fullWorkerPath = `${workerFullPath}?${installUrlQueryParams}`;\n        const scope = `${OneSignalUtils.getBaseUrl()}${this.config.registrationOptions.scope}`;\n        Log.info(`[Service Worker Installation] Installing service worker ${fullWorkerPath} ${scope}.`);\n        try {\n            await navigator.serviceWorker.register(fullWorkerPath, { scope });\n        }\n        catch (error) {\n            Log.error(`[Service Worker Installation] Installing service worker failed ${error}`);\n            // Try accessing the service worker path directly to find out what the problem is and report it to OneSignal api.\n            // If we are inside the popup and service worker fails to register, it's not developer's fault.\n            // No need to report it to the api then.\n            const env = SdkEnvironment.getWindowEnv();\n            if (env === WindowEnvironmentKind.OneSignalSubscriptionPopup)\n                throw error;\n            const response = await fetch(fullWorkerPath);\n            if (response.status === 403 || response.status === 404)\n                throw new ServiceWorkerRegistrationError(response.status, response.statusText);\n            throw error;\n        }\n        Log.debug(`[Service Worker Installation] Service worker installed.`);\n    }\n}\n//# sourceMappingURL=ServiceWorkerManager.js.map","import OneSignalError from \"./OneSignalError\";\nexport var SubscriptionErrorReason;\n(function (SubscriptionErrorReason) {\n    SubscriptionErrorReason[SubscriptionErrorReason[\"InvalidSafariSetup\"] = 0] = \"InvalidSafariSetup\";\n    SubscriptionErrorReason[SubscriptionErrorReason[\"Blocked\"] = 1] = \"Blocked\";\n    SubscriptionErrorReason[SubscriptionErrorReason[\"Dismissed\"] = 2] = \"Dismissed\";\n})(SubscriptionErrorReason || (SubscriptionErrorReason = {}));\nexport default class SubscriptionError extends OneSignalError {\n    constructor(reason) {\n        switch (reason) {\n            case SubscriptionErrorReason.InvalidSafariSetup:\n                super('The Safari site URL, icon size, or push certificate is invalid, or Safari is in a private session.');\n                break;\n            case SubscriptionErrorReason.Blocked:\n                super('Notification permissions are blocked.');\n                break;\n            case SubscriptionErrorReason.Dismissed:\n                super('The notification permission prompt was dismissed.');\n                break;\n        }\n        /**\n         * Important! Required to make sure the correct error type is detected during instanceof checks.\n         * Same applies to all derived classes.\n         * https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n         */\n        Object.setPrototypeOf(this, SubscriptionError.prototype);\n    }\n}\n//# sourceMappingURL=SubscriptionError.js.map","import bowser from \"bowser\";\nimport Database from \"../services/Database\";\nimport OneSignalApiShared from \"../OneSignalApiShared\";\nimport { ServiceWorkerManager } from \"./ServiceWorkerManager\";\nimport Environment from \"../Environment\";\nimport Event from \"../Event\";\nimport Log from \"../libraries/Log\";\nimport { ServiceWorkerActiveState } from \"../helpers/ServiceWorkerHelper\";\nimport SdkEnvironment from \"../managers/SdkEnvironment\";\nimport { NotificationPermission } from \"../models/NotificationPermission\";\nimport { RawPushSubscription } from \"../models/RawPushSubscription\";\nimport { SubscriptionStateKind } from \"../models/SubscriptionStateKind\";\nimport { WindowEnvironmentKind } from \"../models/WindowEnvironmentKind\";\nimport { PushDeviceRecord } from \"../models/PushDeviceRecord\";\nimport { IntegrationKind } from \"../models/IntegrationKind\";\nimport { InvalidStateError, InvalidStateReason } from \"../errors/InvalidStateError\";\nimport PushPermissionNotGrantedError from \"../errors/PushPermissionNotGrantedError\";\nimport { PushPermissionNotGrantedErrorReason } from \"../errors/PushPermissionNotGrantedError\";\nimport { SdkInitError, SdkInitErrorKind } from \"../errors/SdkInitError\";\nimport SubscriptionError from \"../errors/SubscriptionError\";\nimport { SubscriptionErrorReason } from \"../errors/SubscriptionError\";\nimport ServiceWorkerRegistrationError from \"../errors/ServiceWorkerRegistrationError\";\nimport NotImplementedError from \"../errors/NotImplementedError\";\nimport { PermissionUtils } from \"../utils/PermissionUtils\";\nimport { base64ToUint8Array } from \"../utils/Encoding\";\nexport class SubscriptionManager {\n    constructor(context, config) {\n        this.context = context;\n        this.config = config;\n    }\n    static isSafari() {\n        return Environment.isSafari();\n    }\n    /**\n     * Subscribes for a web push subscription.\n     *\n     * This method is aware of different subscription environments like subscribing from a webpage,\n     * service worker, or OneSignal HTTP popup and will select the correct method. This is intended to\n     * be the single public API for obtaining a raw web push subscription (i.e. what the browser\n     * returns from a successful subscription).\n     */\n    async subscribe(subscriptionStrategy) {\n        const env = SdkEnvironment.getWindowEnv();\n        switch (env) {\n            case WindowEnvironmentKind.CustomIframe:\n            case WindowEnvironmentKind.Unknown:\n            case WindowEnvironmentKind.OneSignalProxyFrame:\n                throw new InvalidStateError(InvalidStateReason.UnsupportedEnvironment);\n        }\n        let rawPushSubscription;\n        switch (env) {\n            case WindowEnvironmentKind.ServiceWorker:\n                rawPushSubscription = await this.subscribeFcmFromWorker(subscriptionStrategy);\n                break;\n            case WindowEnvironmentKind.Host:\n            case WindowEnvironmentKind.OneSignalSubscriptionModal:\n            case WindowEnvironmentKind.OneSignalSubscriptionPopup:\n                /*\n                  Check our notification permission before subscribing.\n        \n                  - If notifications are blocked, we can't subscribe.\n                  - If notifications are granted, the user should be completely resubscribed.\n                  - If notifications permissions are untouched, the user will be prompted and then\n                    subscribed.\n        \n                  Subscribing is only possible on the top-level frame, so there's no permission ambiguity\n                  here.\n                */\n                if ((await OneSignal.privateGetNotificationPermission()) === NotificationPermission.Denied)\n                    throw new PushPermissionNotGrantedError(PushPermissionNotGrantedErrorReason.Blocked);\n                if (SubscriptionManager.isSafari()) {\n                    rawPushSubscription = await this.subscribeSafari();\n                    /* Now that permissions have been granted, install the service worker */\n                    Log.info(\"Installing SW on Safari\");\n                    try {\n                        await this.context.serviceWorkerManager.installWorker();\n                        Log.info(\"SW on Safari successfully installed\");\n                    }\n                    catch (e) {\n                        Log.error(\"SW on Safari failed to install.\");\n                    }\n                }\n                else {\n                    rawPushSubscription = await this.subscribeFcmFromPage(subscriptionStrategy);\n                }\n                break;\n            default:\n                throw new InvalidStateError(InvalidStateReason.UnsupportedEnvironment);\n        }\n        return rawPushSubscription;\n    }\n    /**\n     * Creates a device record from the provided raw push subscription and forwards this device record\n     * to OneSignal to create or update the device ID.\n     *\n     * @param rawPushSubscription The raw push subscription obtained from calling subscribe(). This\n     * can be null, in which case OneSignal's device record is set to unsubscribed.\n     *\n     * @param subscriptionState Describes whether the device record is subscribed, unsubscribed, or in\n     * another state. By default, this is set from the availability of rawPushSubscription (exists:\n     * Subscribed, null: Unsubscribed). Other use cases may result in creation of a device record that\n     * warrants a special subscription state. For example, a device ID can be retrieved by providing\n     * an identifier, and a new device record will be created if the identifier didn't exist. These\n     * records are marked with a special subscription state for tracking purposes.\n     */\n    async registerSubscription(pushSubscription, subscriptionState) {\n        /*\n          This may be called after the RawPushSubscription has been serialized across a postMessage\n          frame. This means it will only have object properties and none of the functions. We have to\n          recreate the RawPushSubscription.\n    \n          Keep in mind pushSubscription can be null in cases where resubscription isn't possible\n          (blocked permission).\n        */\n        if (pushSubscription) {\n            pushSubscription = RawPushSubscription.deserialize(pushSubscription);\n        }\n        const deviceRecord = PushDeviceRecord.createFromPushSubscription(this.config.appId, pushSubscription, subscriptionState);\n        let newDeviceId = undefined;\n        if (await this.isAlreadyRegisteredWithOneSignal()) {\n            await this.context.updateManager.sendPlayerUpdate(deviceRecord);\n        }\n        else {\n            newDeviceId = await this.context.updateManager.sendPlayerCreate(deviceRecord);\n            if (newDeviceId) {\n                await this.associateSubscriptionWithEmail(newDeviceId);\n            }\n        }\n        const subscription = await Database.getSubscription();\n        subscription.deviceId = newDeviceId;\n        subscription.optedOut = false;\n        if (pushSubscription) {\n            if (SubscriptionManager.isSafari()) {\n                subscription.subscriptionToken = pushSubscription.safariDeviceToken;\n            }\n            else {\n                subscription.subscriptionToken = pushSubscription.w3cEndpoint ? pushSubscription.w3cEndpoint.toString() : null;\n            }\n        }\n        else {\n            subscription.subscriptionToken = null;\n        }\n        await Database.setSubscription(subscription);\n        if (SdkEnvironment.getWindowEnv() !== WindowEnvironmentKind.ServiceWorker) {\n            Event.trigger(OneSignal.EVENTS.REGISTERED);\n        }\n        if (typeof OneSignal !== \"undefined\") {\n            OneSignal._sessionInitAlreadyRunning = false;\n        }\n        return subscription;\n    }\n    /**\n     * Used before subscribing for push, we request notification permissions\n     * before installing the service worker to prevent non-subscribers from\n     * querying our server for an updated service worker every 24 hours.\n     */\n    static async requestPresubscribeNotificationPermission() {\n        return await SubscriptionManager.requestNotificationPermission();\n    }\n    async unsubscribe(strategy) {\n        if (strategy === 0 /* DestroySubscription */) {\n            throw new NotImplementedError();\n        }\n        else if (strategy === 1 /* MarkUnsubscribed */) {\n            if (SdkEnvironment.getWindowEnv() === WindowEnvironmentKind.ServiceWorker) {\n                const { deviceId } = await Database.getSubscription();\n                await OneSignalApiShared.updatePlayer(this.context.appConfig.appId, deviceId, {\n                    notification_types: SubscriptionStateKind.MutedByApi\n                });\n                await Database.put('Options', { key: 'optedOut', value: true });\n            }\n            else {\n                throw new NotImplementedError();\n            }\n        }\n        else {\n            throw new NotImplementedError();\n        }\n    }\n    /**\n     * Calls Notification.requestPermission(), but returns a Promise instead of\n     * accepting a callback like the actual Notification.requestPermission();\n     *\n     * window.Notification.requestPermission: The callback was deprecated since Gecko 46 in favor of a Promise\n     */\n    static async requestNotificationPermission() {\n        const results = await window.Notification.requestPermission();\n        // TODO: Clean up our custom NotificationPermission enum\n        //         in favor of TS union type NotificationPermission instead of converting\n        return NotificationPermission[results];\n    }\n    /**\n     * Called after registering a subscription with OneSignal to associate this subscription with an\n     * email record if one exists.\n     */\n    async associateSubscriptionWithEmail(newDeviceId) {\n        const emailProfile = await Database.getEmailProfile();\n        if (!emailProfile.emailId) {\n            return;\n        }\n        // Update the push device record with a reference to the new email ID and email address\n        await OneSignalApiShared.updatePlayer(this.config.appId, newDeviceId, {\n            parent_player_id: emailProfile.emailId,\n            email: emailProfile.emailAddress\n        });\n    }\n    async isAlreadyRegisteredWithOneSignal() {\n        const { deviceId } = await Database.getSubscription();\n        return !!deviceId;\n    }\n    subscribeSafariPromptPermission() {\n        return new Promise(resolve => {\n            window.safari.pushNotification.requestPermission(`${SdkEnvironment.getOneSignalApiUrl().toString()}/safari`, this.config.safariWebId, {\n                app_id: this.config.appId\n            }, response => {\n                if (response.deviceToken) {\n                    resolve(response.deviceToken.toLowerCase());\n                }\n                else {\n                    resolve(null);\n                }\n            });\n        });\n    }\n    async subscribeSafari() {\n        const pushSubscriptionDetails = new RawPushSubscription();\n        if (!this.config.safariWebId) {\n            throw new SdkInitError(SdkInitErrorKind.MissingSafariWebId);\n        }\n        const { deviceToken: existingDeviceToken } = window.safari.pushNotification.permission(this.config.safariWebId);\n        pushSubscriptionDetails.existingSafariDeviceToken = existingDeviceToken;\n        if (!existingDeviceToken) {\n            /*\n              We're about to show the Safari native permission request. It can fail for a number of\n              reasons, e.g.:\n                - Setup-related reasons when developers just starting to get set up\n                  - Address bar URL doesn't match safari certificate allowed origins (case-sensitive)\n                  - Safari web ID doesn't match provided web ID\n                  - Browsing in a Safari private window\n                  - Bad icon DPI\n      \n              but shouldn't fail for sites that have already gotten Safari working.\n      \n              We'll show the permissionPromptDisplay event if the Safari user isn't already subscribed,\n              otherwise an already subscribed Safari user would not see the permission request again.\n             */\n            Event.trigger(OneSignal.EVENTS.PERMISSION_PROMPT_DISPLAYED);\n        }\n        const deviceToken = await this.subscribeSafariPromptPermission();\n        PermissionUtils.triggerNotificationPermissionChanged();\n        if (deviceToken) {\n            pushSubscriptionDetails.setFromSafariSubscription(deviceToken);\n        }\n        else {\n            throw new SubscriptionError(SubscriptionErrorReason.InvalidSafariSetup);\n        }\n        return pushSubscriptionDetails;\n    }\n    async subscribeFcmFromPage(subscriptionStrategy) {\n        /*\n          Before installing the service worker, request notification permissions. If\n          the visitor doesn't grant permissions, this saves bandwidth bleeding from\n          an unused install service worker periodically fetching an updated version\n          from our CDN.\n        */\n        /*\n          Trigger the permissionPromptDisplay event to the best of our knowledge.\n        */\n        if (SdkEnvironment.getWindowEnv() !== WindowEnvironmentKind.ServiceWorker &&\n            window.Notification.permission === NotificationPermission.Default) {\n            await Event.trigger(OneSignal.EVENTS.PERMISSION_PROMPT_DISPLAYED);\n            const permission = await SubscriptionManager.requestPresubscribeNotificationPermission();\n            /*\n              Notification permission changes are already broadcast by the page's\n              notificationpermissionchange handler. This means that allowing or\n              denying the permission prompt will cause double events. However, the\n              native event handler does not broadcast an event for dismissing the\n              prompt, because going from \"default\" permissions to \"default\"\n              permissions isn't a change. We specifically broadcast \"default\" to \"default\" changes.\n             */\n            if (permission === NotificationPermission.Default)\n                await PermissionUtils.triggerNotificationPermissionChanged(true);\n            // If the user did not grant push permissions, throw and exit\n            switch (permission) {\n                case NotificationPermission.Default:\n                    Log.debug('Exiting subscription and not registering worker because the permission was dismissed.');\n                    OneSignal._sessionInitAlreadyRunning = false;\n                    OneSignal._isRegisteringForPush = false;\n                    throw new PushPermissionNotGrantedError(PushPermissionNotGrantedErrorReason.Dismissed);\n                case NotificationPermission.Denied:\n                    Log.debug('Exiting subscription and not registering worker because the permission was blocked.');\n                    OneSignal._sessionInitAlreadyRunning = false;\n                    OneSignal._isRegisteringForPush = false;\n                    throw new PushPermissionNotGrantedError(PushPermissionNotGrantedErrorReason.Blocked);\n            }\n        }\n        /* Now that permissions have been granted, install the service worker */\n        try {\n            await this.context.serviceWorkerManager.installWorker();\n        }\n        catch (err) {\n            if (err instanceof ServiceWorkerRegistrationError) {\n                if (err.status === 403) {\n                    await this.context.subscriptionManager.registerFailedSubscription(SubscriptionStateKind.ServiceWorkerStatus403, this.context);\n                }\n                else if (err.status === 404) {\n                    await this.context.subscriptionManager.registerFailedSubscription(SubscriptionStateKind.ServiceWorkerStatus404, this.context);\n                }\n            }\n            throw err;\n        }\n        Log.debug('Waiting for the service worker to activate...');\n        const workerRegistration = await navigator.serviceWorker.ready;\n        Log.debug('Service worker is ready to continue subscribing.');\n        return await this.subscribeWithVapidKey(workerRegistration.pushManager, subscriptionStrategy);\n    }\n    async subscribeFcmFromWorker(subscriptionStrategy) {\n        /*\n          We're running inside of the service worker.\n    \n          Check to make sure our registration is activated, otherwise we can't\n          subscribe for push.\n    \n          HACK: Firefox doesn't set self.registration.active in the service worker\n          context. From a non-service worker context, like\n          navigator.serviceWorker.getRegistration().active, the property actually is\n          set, but it's just not set within the service worker context.\n    \n          Because of this, we're not able to check for this property on Firefox.\n         */\n        const swRegistration = self.registration;\n        if (!swRegistration.active && !bowser.firefox) {\n            throw new InvalidStateError(InvalidStateReason.ServiceWorkerNotActivated);\n            /*\n              Or should we wait for the service worker to be ready?\n      \n              await new Promise(resolve => self.onactivate = resolve);\n             */\n        }\n        /*\n          Check to make sure push permissions have been granted.\n         */\n        const pushPermission = await swRegistration.pushManager.permissionState({ userVisibleOnly: true });\n        if (pushPermission === 'denied') {\n            throw new PushPermissionNotGrantedError(PushPermissionNotGrantedErrorReason.Blocked);\n        }\n        else if (pushPermission === 'prompt') {\n            throw new PushPermissionNotGrantedError(PushPermissionNotGrantedErrorReason.Default);\n        }\n        return await this.subscribeWithVapidKey(swRegistration.pushManager, subscriptionStrategy);\n    }\n    /**\n     * Returns the correct VAPID key to use for subscription based on the browser type.\n     *\n     * If the VAPID key isn't present, undefined is returned instead of null.\n     */\n    getVapidKeyForBrowser() {\n        // Specifically return undefined instead of null if the key isn't available\n        let key = undefined;\n        if (bowser.firefox) {\n            /*\n              Firefox uses VAPID for application identification instead of\n              authentication, and so all apps share an identification key.\n             */\n            key = this.config.onesignalVapidPublicKey;\n        }\n        else {\n            /*\n              Chrome and Chrome-like browsers including Opera and Yandex use VAPID for\n              authentication, and so each app uses a uniquely generated key.\n             */\n            key = this.config.vapidPublicKey;\n        }\n        if (key) {\n            return base64ToUint8Array(key).buffer;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Uses the browser's PushManager interface to actually subscribe for a web push subscription.\n     *\n     * @param pushManager An instance of the browser's push manager, either from the page or from the\n     * service worker.\n     *\n     * @param subscriptionStrategy Given an existing push subscription, describes whether the existing\n     * push subscription is resubscribed as-is leaving it unchanged, or unsubscribed to make room for\n     * a new push subscription.\n     */\n    async subscribeWithVapidKey(pushManager, subscriptionStrategy) {\n        /*\n          Always try subscribing using VAPID by providing an applicationServerKey, except for cases\n          where the user is already subscribed, handled below.\n         */\n        const existingPushSubscription = await pushManager.getSubscription();\n        /* Depending on the subscription strategy, handle existing subscription in various ways */\n        switch (subscriptionStrategy) {\n            case 0 /* ResubscribeExisting */:\n                if (!existingPushSubscription)\n                    break;\n                if (existingPushSubscription.options) {\n                    Log.debug(\"[Subscription Manager] An existing push subscription exists and it's options is not null.\");\n                }\n                else {\n                    Log.debug('[Subscription Manager] An existing push subscription exists and options is null. ' +\n                        'Unsubscribing from push first now.');\n                    /*\n                      NOTE: Only applies to rare edge case of migrating from senderId to a VAPID subscription\n                      There isn't a great solution if PushSubscriptionOptions (supported on Chrome 54+) isn't\n                      supported.\n          \n                      We want to subscribe the user, but we don't know whether the user was subscribed via\n                      GCM's manifest.json or FCM's VAPID.\n          \n                      This bug (https://bugs.chromium.org/p/chromium/issues/detail?id=692577) shows that a\n                      mismatched sender ID error is possible if you subscribe via FCM's VAPID while the user\n                      was originally subscribed via GCM's manifest.json (fails silently).\n          \n                      Because of this, we should unsubscribe the user from push first and then resubscribe\n                      them.\n                    */\n                    /* We're unsubscribing, so we want to store the created at timestamp */\n                    await SubscriptionManager.doPushUnsubscribe(existingPushSubscription);\n                }\n                break;\n            case 1 /* SubscribeNew */:\n                /* Since we want a new subscription every time with this strategy, just unsubscribe. */\n                if (existingPushSubscription) {\n                    await SubscriptionManager.doPushUnsubscribe(existingPushSubscription);\n                }\n                break;\n        }\n        // Actually subscribe the user to push\n        const [newPushSubscription, isNewSubscription] = await SubscriptionManager.doPushSubscribe(pushManager, this.getVapidKeyForBrowser());\n        // Update saved create and expired times\n        await SubscriptionManager.updateSubscriptionTime(isNewSubscription, newPushSubscription.expirationTime);\n        // Create our own custom object from the browser's native PushSubscription object\n        const pushSubscriptionDetails = RawPushSubscription.setFromW3cSubscription(newPushSubscription);\n        if (existingPushSubscription) {\n            pushSubscriptionDetails.existingW3cPushSubscription =\n                RawPushSubscription.setFromW3cSubscription(existingPushSubscription);\n        }\n        return pushSubscriptionDetails;\n    }\n    static async updateSubscriptionTime(updateCreatedAt, expirationTime) {\n        const bundle = await Database.getSubscription();\n        if (updateCreatedAt) {\n            bundle.createdAt = new Date().getTime();\n        }\n        bundle.expirationTime = expirationTime;\n        await Database.setSubscription(bundle);\n    }\n    static async doPushUnsubscribe(pushSubscription) {\n        Log.debug('[Subscription Manager] Unsubscribing existing push subscription.');\n        const result = await pushSubscription.unsubscribe();\n        Log.debug(`[Subscription Manager] Unsubscribing existing push subscription result: ${result}`);\n        return result;\n    }\n    // Subscribes the ServiceWorker for a pushToken.\n    // If there is an error doing so unsubscribe from existing and try again\n    //    - This handles subscribing to new server VAPID key if it has changed.\n    // return type - [PushSubscription, createdNewPushSubscription(boolean)]\n    static async doPushSubscribe(pushManager, applicationServerKey) {\n        if (!applicationServerKey) {\n            throw new Error(\"Missing required 'applicationServerKey' to subscribe for push notifications!\");\n        }\n        const subscriptionOptions = {\n            userVisibleOnly: true,\n            applicationServerKey: applicationServerKey\n        };\n        Log.debug('[Subscription Manager] Subscribing to web push with these options:', subscriptionOptions);\n        try {\n            const existingSubscription = await pushManager.getSubscription();\n            return [await pushManager.subscribe(subscriptionOptions), !existingSubscription];\n        }\n        catch (e) {\n            if (e.name == \"InvalidStateError\") {\n                // This exception is thrown if the key for the existing applicationServerKey is different,\n                //    so we must unregister first.\n                // In Chrome, e.message contains will be the following in this case for reference;\n                // Registration failed - A subscription with a different applicationServerKey (or gcm_sender_id) already exists;\n                //    to change the applicationServerKey, unsubscribe then resubscribe.\n                Log.warn(\"[Subscription Manager] Couldn't re-subscribe due to applicationServerKey changing, \" +\n                    \"unsubscribe and attempting to subscribe with new key.\", e);\n                const subscription = await pushManager.getSubscription();\n                if (subscription) {\n                    await SubscriptionManager.doPushUnsubscribe(subscription);\n                }\n                return [await pushManager.subscribe(subscriptionOptions), true];\n            }\n            else\n                throw e; // If some other error, bubble the exception up\n        }\n    }\n    async isSubscriptionExpiring() {\n        const integrationKind = await SdkEnvironment.getIntegration();\n        const windowEnv = SdkEnvironment.getWindowEnv();\n        switch (integrationKind) {\n            case IntegrationKind.Secure:\n                return await this.isSubscriptionExpiringForSecureIntegration();\n            case IntegrationKind.SecureProxy:\n                if (windowEnv === WindowEnvironmentKind.Host) {\n                    const proxyFrameHost = OneSignal.proxyFrameHost;\n                    if (!proxyFrameHost) {\n                        throw new InvalidStateError(InvalidStateReason.NoProxyFrame);\n                    }\n                    else {\n                        return await proxyFrameHost.runCommand(OneSignal.POSTMAM_COMMANDS.SUBSCRIPTION_EXPIRATION_STATE);\n                    }\n                }\n                else {\n                    return await this.isSubscriptionExpiringForSecureIntegration();\n                }\n            case IntegrationKind.InsecureProxy:\n                /* If we're in an insecure frame context, check the stored expiration since we can't access\n                the actual push subscription. */\n                const { expirationTime } = await Database.getSubscription();\n                if (!expirationTime) {\n                    /* If an existing subscription does not have a stored expiration time, do not\n                    treat it as expired. The subscription may have been created before this feature was added,\n                    or the browser may not assign any expiration time. */\n                    return false;\n                }\n                /* The current time (in UTC) is past the expiration time (also in UTC) */\n                return new Date().getTime() >= expirationTime;\n        }\n    }\n    async isSubscriptionExpiringForSecureIntegration() {\n        const serviceWorkerState = await this.context.serviceWorkerManager.getActiveState();\n        if (!(serviceWorkerState === ServiceWorkerActiveState.WorkerA ||\n            serviceWorkerState === ServiceWorkerActiveState.WorkerB)) {\n            /* If the service worker isn't activated, there's no subscription to look for */\n            return false;\n        }\n        const serviceWorkerRegistration = await ServiceWorkerManager.getRegistration();\n        if (!serviceWorkerRegistration)\n            return false;\n        // It's possible to get here in Safari 11.1+ version\n        //   since they released support for service workers but not push api.\n        if (!serviceWorkerRegistration.pushManager)\n            return false;\n        const pushSubscription = await serviceWorkerRegistration.pushManager.getSubscription();\n        // Not subscribed to web push\n        if (!pushSubscription)\n            return false;\n        // No push subscription expiration time\n        if (!pushSubscription.expirationTime)\n            return false;\n        let { createdAt: subscriptionCreatedAt } = await Database.getSubscription();\n        if (!subscriptionCreatedAt) {\n            /* If we don't have a record of when the subscription was created, set it into the future to\n            guarantee expiration and obtain a new subscription */\n            const ONE_YEAR = 1000 * 60 * 60 * 24 * 365;\n            subscriptionCreatedAt = new Date().getTime() + ONE_YEAR;\n        }\n        const midpointExpirationTime = subscriptionCreatedAt + ((pushSubscription.expirationTime - subscriptionCreatedAt) / 2);\n        return !!pushSubscription.expirationTime && (\n        /* The current time (in UTC) is past the expiration time (also in UTC) */\n        new Date().getTime() >= pushSubscription.expirationTime ||\n            new Date().getTime() >= midpointExpirationTime);\n    }\n    /**\n     * Returns an object describing the user's actual push subscription state and opt-out status.\n     */\n    async getSubscriptionState() {\n        /* Safari should always return Secure because HTTP doesn't apply on Safari */\n        if (SubscriptionManager.isSafari()) {\n            return this.getSubscriptionStateForSecure();\n        }\n        const windowEnv = SdkEnvironment.getWindowEnv();\n        switch (windowEnv) {\n            case WindowEnvironmentKind.ServiceWorker:\n                const pushSubscription = await self.registration.pushManager.getSubscription();\n                const { optedOut } = await Database.getSubscription();\n                return {\n                    subscribed: !!pushSubscription,\n                    optedOut: !!optedOut\n                };\n            default:\n                /* Regular browser window environments */\n                const integration = await SdkEnvironment.getIntegration();\n                switch (integration) {\n                    case IntegrationKind.Secure:\n                        return this.getSubscriptionStateForSecure();\n                    case IntegrationKind.SecureProxy:\n                        switch (windowEnv) {\n                            case WindowEnvironmentKind.OneSignalProxyFrame:\n                            case WindowEnvironmentKind.OneSignalSubscriptionPopup:\n                            case WindowEnvironmentKind.OneSignalSubscriptionModal:\n                                return this.getSubscriptionStateForSecure();\n                            default:\n                                /* Re-run this command in the proxy frame */\n                                const proxyFrameHost = OneSignal.proxyFrameHost;\n                                const pushSubscriptionState = await proxyFrameHost.runCommand(OneSignal.POSTMAM_COMMANDS.GET_SUBSCRIPTION_STATE);\n                                return pushSubscriptionState;\n                        }\n                    case IntegrationKind.InsecureProxy:\n                        return await this.getSubscriptionStateForInsecure();\n                    default:\n                        throw new InvalidStateError(InvalidStateReason.UnsupportedEnvironment);\n                }\n        }\n    }\n    async getSubscriptionStateForSecure() {\n        const { deviceId, optedOut } = await Database.getSubscription();\n        if (SubscriptionManager.isSafari()) {\n            const subscriptionState = window.safari.pushNotification.permission(this.config.safariWebId);\n            const isSubscribedToSafari = !!(subscriptionState.permission === \"granted\" &&\n                subscriptionState.deviceToken &&\n                deviceId);\n            return {\n                subscribed: isSubscribedToSafari,\n                optedOut: !!optedOut,\n            };\n        }\n        const workerState = await this.context.serviceWorkerManager.getActiveState();\n        const workerRegistration = await ServiceWorkerManager.getRegistration();\n        const notificationPermission = await this.context.permissionManager.getNotificationPermission(this.context.appConfig.safariWebId);\n        const isWorkerActive = (workerState === ServiceWorkerActiveState.WorkerA ||\n            workerState === ServiceWorkerActiveState.WorkerB);\n        if (!workerRegistration) {\n            /* You can't be subscribed without a service worker registration */\n            return {\n                subscribed: false,\n                optedOut: !!optedOut,\n            };\n        }\n        /*\n         * Removing pushSubscription from this method due to inconsistent behavior between browsers.\n         * Doesn't matter for re-subscribing, worker is present and active.\n         * Previous implementation for reference:\n         * const pushSubscription = await workerRegistration.pushManager.getSubscription();\n         * const isPushEnabled = !!(\n         *   pushSubscription &&\n         *   deviceId &&\n         *   notificationPermission === NotificationPermission.Granted &&\n         *   isWorkerActive\n         * );\n         */\n        const isPushEnabled = !!(deviceId &&\n            notificationPermission === NotificationPermission.Granted &&\n            isWorkerActive);\n        return {\n            subscribed: isPushEnabled,\n            optedOut: !!optedOut,\n        };\n    }\n    async getSubscriptionStateForInsecure() {\n        /* For HTTP, we need to rely on stored values; we never have access to the actual data */\n        const { deviceId, subscriptionToken, optedOut } = await Database.getSubscription();\n        const notificationPermission = await this.context.permissionManager.getNotificationPermission(this.context.appConfig.safariWebId);\n        const isPushEnabled = !!(deviceId &&\n            subscriptionToken &&\n            notificationPermission === NotificationPermission.Granted);\n        return {\n            subscribed: isPushEnabled,\n            optedOut: !!optedOut,\n        };\n    }\n    /**\n     * Broadcasting to the server the fact user tried to subscribe but there was an error during service worker registration.\n     * Do it only once for the first page view.\n     * @param subscriptionState Describes what went wrong with the service worker installation.\n     */\n    async registerFailedSubscription(subscriptionState, context) {\n        if (context.pageViewManager.isFirstPageView()) {\n            context.subscriptionManager.registerSubscription(new RawPushSubscription(), subscriptionState);\n            context.pageViewManager.incrementPageViewCount();\n        }\n    }\n}\n//# sourceMappingURL=SubscriptionManager.js.map","/**\n * Used for VAPID, converts the VAPID public key into a byte format the browser accepts.\n */\nexport function base64ToUint8Array(base64String) {\n    const padding = '='.repeat((4 - base64String.length % 4) % 4);\n    const base64 = (base64String + padding).replace(/\\-/g, '+').replace(/_/g, '/');\n    const rawData = atob(base64);\n    const outputArray = new Uint8Array(rawData.length);\n    for (let i = 0; i < rawData.length; ++i) {\n        outputArray[i] = rawData.charCodeAt(i);\n    }\n    return outputArray;\n}\n/**\n * Used for VAPID, converts a browser-provided ArrayBuffer of the applicationServerKey back to its string form.\n */\nexport function arrayBufferToBase64(arrayBuffer) {\n    var base64 = '';\n    var encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    var bytes = new Uint8Array(arrayBuffer);\n    var byteLength = bytes.byteLength;\n    var byteRemainder = byteLength % 3;\n    var mainLength = byteLength - byteRemainder;\n    var a, b, c, d;\n    var chunk;\n    // Main loop deals with bytes in chunks of 3\n    for (var i = 0; i < mainLength; i = i + 3) {\n        // Combine the three bytes into a single integer\n        chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];\n        // Use bitmasks to extract 6-bit segments from the triplet\n        a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18\n        b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12\n        c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6\n        d = chunk & 63; // 63       = 2^6 - 1\n        // Convert the raw binary segments to the appropriate ASCII encoding\n        base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];\n    }\n    // Deal with the remaining bytes and padding\n    if (byteRemainder == 1) {\n        chunk = bytes[mainLength];\n        a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2\n        // Set the 4 least significant bits to zero\n        b = (chunk & 3) << 4; // 3   = 2^2 - 1\n        base64 += encodings[a] + encodings[b] + '==';\n    }\n    else if (byteRemainder == 2) {\n        chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];\n        a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10\n        b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4\n        // Set the 2 least significant bits to zero\n        c = (chunk & 15) << 2; // 15    = 2^4 - 1\n        base64 += encodings[a] + encodings[b] + encodings[c] + '=';\n    }\n    return base64;\n}\n/**\n * From: https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding\n */\nexport function base64Encode(str) {\n    // first we use encodeURIComponent to get percent-encoded UTF-8,\n    // then we convert the percent encodings into raw bytes which\n    // can be fed into btoa.\n    return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function toSolidBytes(match, p1) {\n        return String.fromCharCode('0x' + p1);\n    }));\n}\nexport function base64Decode(str) {\n    // Going backwards: from bytestream, to percent-encoding, to original string.\n    return decodeURIComponent(atob(str).split('').map(function (c) {\n        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n    }).join(''));\n}\n//# sourceMappingURL=Encoding.js.map","import { ServiceWorkerManager } from '../managers/ServiceWorkerManager';\nimport { SubscriptionManager } from '../managers/SubscriptionManager';\nimport Path from '../models/Path';\nimport SdkEnvironment from '../managers/SdkEnvironment';\nexport class ContextHelper {\n    static getServiceWorkerManager(context) {\n        const config = context.appConfig;\n        const envPrefix = SdkEnvironment.getBuildEnvPrefix();\n        const serviceWorkerManagerConfig = {\n            workerAPath: new Path(`/${envPrefix}OneSignalSDKWorker.js`),\n            workerBPath: new Path(`/${envPrefix}OneSignalSDKUpdaterWorker.js`),\n            registrationOptions: { scope: '/' }\n        };\n        if (config.userConfig) {\n            if (config.userConfig.path) {\n                serviceWorkerManagerConfig.workerAPath =\n                    new Path(`${config.userConfig.path}${envPrefix}${config.userConfig.serviceWorkerPath}`);\n                serviceWorkerManagerConfig.workerBPath =\n                    new Path(`${config.userConfig.path}${envPrefix}${config.userConfig.serviceWorkerUpdaterPath}`);\n            }\n            if (config.userConfig.serviceWorkerParam) {\n                serviceWorkerManagerConfig.registrationOptions = config.userConfig.serviceWorkerParam;\n            }\n        }\n        return new ServiceWorkerManager(context, serviceWorkerManagerConfig);\n    }\n    static getSubscriptionManager(context) {\n        const config = context.appConfig;\n        const subscriptionManagerConfig = {\n            safariWebId: config.safariWebId,\n            appId: config.appId,\n            vapidPublicKey: config.vapidPublicKey,\n            onesignalVapidPublicKey: config.onesignalVapidPublicKey,\n        };\n        return new SubscriptionManager(context, subscriptionManagerConfig);\n    }\n}\nexport default ContextHelper;\n//# sourceMappingURL=ContextHelper.js.map","import OneSignalError from \"./OneSignalError\";\nexport var NotSubscribedReason;\n(function (NotSubscribedReason) {\n    NotSubscribedReason[NotSubscribedReason[\"Unknown\"] = 0] = \"Unknown\";\n    NotSubscribedReason[NotSubscribedReason[\"NoDeviceId\"] = 1] = \"NoDeviceId\";\n    NotSubscribedReason[NotSubscribedReason[\"NoEmailSet\"] = 2] = \"NoEmailSet\";\n    NotSubscribedReason[NotSubscribedReason[\"OptedOut\"] = 3] = \"OptedOut\";\n})(NotSubscribedReason || (NotSubscribedReason = {}));\nexport class NotSubscribedError extends OneSignalError {\n    constructor(reason) {\n        switch (reason) {\n            case NotSubscribedReason.Unknown || NotSubscribedReason.NoDeviceId:\n                super('This operation can only be performed after the user is subscribed.');\n                break;\n            case NotSubscribedReason.NoEmailSet:\n                super('No email is currently set.');\n                break;\n            case NotSubscribedReason.OptedOut:\n                super('The user has manually opted out of receiving of notifications. This operation can only be performed after the user is fully resubscribed.');\n                break;\n        }\n        this.reason = NotSubscribedReason[reason];\n        /**\n         * Important! Required to make sure the correct error type is detected during instanceof checks.\n         * Same applies to all derived classes.\n         * https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n         */\n        Object.setPrototypeOf(this, NotSubscribedError.prototype);\n    }\n}\n//# sourceMappingURL=NotSubscribedError.js.map","import OneSignalApiShared from \"../OneSignalApiShared\";\nimport { SubscriptionStateKind } from '../models/SubscriptionStateKind';\nimport { NotSubscribedError, NotSubscribedReason } from \"../errors/NotSubscribedError\";\nimport MainHelper from '../helpers/MainHelper';\nimport Database from \"../services/Database\";\nimport Log from \"../libraries/Log\";\nimport Utils from \"../context/shared/utils/Utils\";\nimport { SessionOrigin } from \"../models/Session\";\nimport { logMethodCall } from '../utils';\nexport class UpdateManager {\n    constructor(context) {\n        this.context = context;\n        this.onSessionSent = context.pageViewManager.getPageViewCount() > 1;\n    }\n    async getDeviceId() {\n        const { deviceId } = await Database.getSubscription();\n        if (!deviceId) {\n            throw new NotSubscribedError(NotSubscribedReason.NoDeviceId);\n        }\n        return deviceId;\n    }\n    async createDeviceRecord() {\n        return MainHelper.createDeviceRecord(this.context.appConfig.appId);\n    }\n    async sendPlayerUpdate(deviceRecord) {\n        const existingUser = await this.context.subscriptionManager.isAlreadyRegisteredWithOneSignal();\n        if (!existingUser) {\n            Log.debug(\"Not sending the update because user is not registered with OneSignal (no device id)\");\n            return;\n        }\n        const deviceId = await this.getDeviceId();\n        if (!deviceRecord) {\n            deviceRecord = await this.createDeviceRecord();\n        }\n        if (this.onSessionSent) {\n            await OneSignalApiShared.updatePlayer(this.context.appConfig.appId, deviceId, Object.assign({ notification_types: SubscriptionStateKind.Subscribed }, deviceRecord.serialize()));\n        }\n        else {\n            await this.sendOnSessionUpdate(deviceRecord);\n        }\n    }\n    // If user has been subscribed before, send the on_session update to our backend on the first page view.\n    async sendOnSessionUpdate(deviceRecord) {\n        if (this.onSessionSent) {\n            return;\n        }\n        if (!this.context.pageViewManager.isFirstPageView()) {\n            return;\n        }\n        const existingUser = await this.context.subscriptionManager.isAlreadyRegisteredWithOneSignal();\n        if (!existingUser) {\n            Log.debug(\"Not sending the on session because user is not registered with OneSignal (no device id)\");\n            return;\n        }\n        const deviceId = await this.getDeviceId();\n        if (!deviceRecord) {\n            deviceRecord = await this.createDeviceRecord();\n        }\n        if (deviceRecord.subscriptionState !== SubscriptionStateKind.Subscribed &&\n            OneSignal.config.enableOnSession !== true) {\n            return;\n        }\n        try {\n            // Not sending on_session here but from SW instead.\n            // Not awaiting here on purpose\n            this.context.sessionManager.upsertSession(deviceId, deviceRecord, SessionOrigin.PlayerOnSession);\n            this.onSessionSent = true;\n        }\n        catch (e) {\n            Log.error(`Failed to update user session. Error \"${e.message}\" ${e.stack}`);\n        }\n    }\n    async sendPlayerCreate(deviceRecord) {\n        try {\n            const deviceId = await OneSignalApiShared.createUser(deviceRecord);\n            if (deviceId) {\n                Log.info(\"Subscribed to web push and registered with OneSignal\", deviceRecord, deviceId);\n                this.onSessionSent = true;\n                // Not awaiting here on purpose\n                this.context.sessionManager.upsertSession(deviceId, deviceRecord, SessionOrigin.PlayerCreate);\n                return deviceId;\n            }\n            Log.error(`Failed to create user.`);\n            return undefined;\n        }\n        catch (e) {\n            Log.error(`Failed to create user. Error \"${e.message}\" ${e.stack}`);\n            return undefined;\n        }\n    }\n    onSessionAlreadyCalled() {\n        return this.onSessionSent;\n    }\n    async sendExternalUserIdUpdate(externalUserId) {\n        const deviceId = await this.getDeviceId();\n        await OneSignalApiShared.updatePlayer(this.context.appConfig.appId, deviceId, {\n            external_user_id: Utils.getValueOrDefault(externalUserId, \"\")\n        });\n    }\n    async sendOutcomeDirect(appId, notificationIds, outcomeName, value) {\n        logMethodCall(\"sendOutcomeDirect\");\n        const deviceRecord = await this.createDeviceRecord();\n        const outcomeRequestData = {\n            app_id: appId,\n            id: outcomeName,\n            device_type: deviceRecord.deliveryPlatform,\n            notification_ids: notificationIds,\n            direct: true,\n        };\n        if (value !== undefined) {\n            outcomeRequestData.weight = value;\n        }\n        await OneSignalApiShared.sendOutcome(outcomeRequestData);\n    }\n    async sendOutcomeInfluenced(appId, notificationIds, outcomeName, value) {\n        logMethodCall(\"sendOutcomeInfluenced\");\n        const deviceRecord = await this.createDeviceRecord();\n        const outcomeRequestData = {\n            app_id: appId,\n            id: outcomeName,\n            device_type: deviceRecord.deliveryPlatform,\n            notification_ids: notificationIds,\n            direct: false,\n        };\n        if (value !== undefined) {\n            outcomeRequestData.weight = value;\n        }\n        await OneSignalApiShared.sendOutcome(outcomeRequestData);\n    }\n    async sendOutcomeUnattributed(appId, outcomeName, value) {\n        logMethodCall(\"sendOutcomeUnattributed\");\n        const deviceRecord = await this.createDeviceRecord();\n        const outcomeRequestData = {\n            app_id: appId,\n            id: outcomeName,\n            device_type: deviceRecord.deliveryPlatform,\n        };\n        if (value !== undefined) {\n            outcomeRequestData.weight = value;\n        }\n        await OneSignalApiShared.sendOutcome(outcomeRequestData);\n    }\n}\n//# sourceMappingURL=UpdateManager.js.map","export class SessionManager {\n    constructor(_context) { }\n    async upsertSession(_deviceId, _deviceRecord, _sessionOrigin) {\n        // TODO: how should it be implemented if called from inside of service worker???\n    }\n}\n//# sourceMappingURL=SessionManager.js.map","import { WorkerMessenger } from '../libraries/WorkerMessenger';\nimport { PageViewManager } from '../managers/PageViewManager';\nimport PermissionManager from '../managers/PermissionManager';\nimport ContextHelper from \"../helpers/ContextHelper\";\nimport { UpdateManager } from \"../managers/UpdateManager\";\nimport { SessionManager } from \"../managers/sessionManager/sw/SessionManager\";\nexport default class ContextSW {\n    constructor(appConfig) {\n        this.appConfig = appConfig;\n        this.subscriptionManager = ContextHelper.getSubscriptionManager(this);\n        this.serviceWorkerManager = ContextHelper.getServiceWorkerManager(this);\n        this.pageViewManager = new PageViewManager();\n        this.sessionManager = new SessionManager(this);\n        this.permissionManager = new PermissionManager();\n        this.workerMessenger = new WorkerMessenger(this);\n        this.updateManager = new UpdateManager(this);\n    }\n}\n//# sourceMappingURL=ContextSW.js.map","import OneSignalUtils from '../utils/OneSignalUtils';\nimport bowser from 'bowser';\nimport { InvalidArgumentError, InvalidArgumentReason } from '../errors/InvalidArgumentError';\nimport { NotificationPermission } from '../models/NotificationPermission';\nimport SdkEnvironment from '../managers/SdkEnvironment';\nimport LocalStorage from '../utils/LocalStorage';\n/**\n * A permission manager to consolidate the different quirks of obtaining and evaluating permissions\n * across Safari, Chrome, and Firefox.\n */\nexport default class PermissionManager {\n    static get STORED_PERMISSION_KEY() {\n        return 'storedNotificationPermission';\n    }\n    /**\n     * Returns an interpreted version of the browser's notification permission.\n     *\n     * On some environments, it isn't possible to obtain the actual notification\n     * permission. For example, starting with Chrome 62+, cross-origin iframes and\n     * insecure origins can no longer accurately detect the default notification\n     * permission state.\n     *\n     * For cross-origin iframes, returned permissions are correct except that\n     * \"denied\" is returned instead of \"default\".\n     *\n     * For insecure origins, returned permissions are always \"denied\". This\n     * differs from cross-origin iframes where the cross-origin iframes are\n     * acurrate if returning \"granted\", but insecure origins will always return\n     * \"denied\" regardless of the actual permission.\n     *\n     * This method therefore returns the notification permission best suited for\n     * our SDK, and it may not always be accurate. On most environments (i.e. not\n     * Chrome 62+), the returned permission will be accurate.\n     *\n     * @param safariWebId The Safari web ID necessary to access the permission\n     * state on Safari.\n     */\n    async getNotificationPermission(safariWebId) {\n        const reportedPermission = await this.getReportedNotificationPermission(safariWebId);\n        if (await this.isPermissionEnvironmentAmbiguous(reportedPermission))\n            return await this.getInterpretedAmbiguousPermission(reportedPermission);\n        return reportedPermission;\n    }\n    /**\n     * Returns the browser's actual notification permission as reported without any modifications.\n     *\n     * One challenge is determining the frame context our permission query needs to run in:\n     *\n     *   - For a regular top-level HTTPS site, query our current top-level frame\n     *\n     *   - For a custom web push setup in a child HTTPS iframe, query our current child iframe (even\n     *     though the returned permission is ambiguous on Chrome 62+ if our origin is different from\n     *     that of the top-level frame)\n     *\n     *   - For a regular HTTP site, query OneSignal's child subdomain.os.tc or subdomain.onesignal.com\n     *     iframe\n     *\n     *   - For a regular HTTP site embedded in a child iframe, still query the nested child's\n     *     OneSignal subdomain.os.tc or subdomain.onesignal.com iframe\n     *\n     * This simplifies into determining whether the web push setup is using OneSignal's subdomain. If\n     * not, we assume the current frame context, regardless of whether it is a child or top-level\n     * frame, is the current context to run the permission query in.\n     *\n     * @param safariWebId The Safari web ID necessary to access the permission state on Safari.\n     */\n    async getReportedNotificationPermission(safariWebId) {\n        if (bowser.safari)\n            return PermissionManager.getSafariNotificationPermission(safariWebId);\n        // Is this web push setup using subdomain.os.tc or subdomain.onesignal.com?\n        if (OneSignalUtils.isUsingSubscriptionWorkaround())\n            return await this.getOneSignalSubdomainNotificationPermission(safariWebId);\n        else\n            return this.getW3cNotificationPermission();\n    }\n    /**\n     * Returns the Safari browser's notification permission as reported by the browser.\n     *\n     * @param safariWebId The Safari web ID necessary to access the permission state on Safari.\n     */\n    static getSafariNotificationPermission(safariWebId) {\n        if (safariWebId)\n            return window.safari.pushNotification.permission(safariWebId).permission;\n        throw new InvalidArgumentError('safariWebId', InvalidArgumentReason.Empty);\n    }\n    /**\n     * Returns the notification permission as reported by the browser for non-Safari browsers. This\n     * includes Chrome, Firefox, Opera, Yandex, and every browser following the Notification API\n     * standard.\n     */\n    getW3cNotificationPermission() {\n        return window.Notification.permission;\n    }\n    /**\n     * Returns the notification permission as reported by the browser for the OneSignal subdomain\n     * iframe.\n     *\n     * @param safariWebId The Safari web ID necessary to access the permission state on Safari.\n     */\n    async getOneSignalSubdomainNotificationPermission(safariWebId) {\n        return new Promise(resolve => {\n            OneSignal.proxyFrameHost.message(OneSignal.POSTMAM_COMMANDS.REMOTE_NOTIFICATION_PERMISSION, { safariWebId: safariWebId }, (reply) => {\n                const remoteNotificationPermission = reply.data;\n                resolve(remoteNotificationPermission);\n            });\n        });\n    }\n    /**\n     * To interpret the browser's reported notification permission, we need to know whether we're in\n     * an environment where the returned permission should be treated ambiguously.\n     *\n     * The reported permission should only be treated ambiguously if:\n     *\n     *   - We're not on Safari or Firefox (Chromium, Chrome, Opera, and Yandex will all eventually\n     *     share the same Chrome 62+ codebase)\n     *\n     *   - And the reported permission is \"denied\"\n     *\n     *   - And the current frame context is either a cross-origin iframe or insecure\n     */\n    async isPermissionEnvironmentAmbiguous(permission) {\n        // For testing purposes, allows changing the browser user agent\n        const browser = OneSignalUtils.redetectBrowserUserAgent();\n        return (!browser.safari &&\n            !browser.firefox &&\n            permission === NotificationPermission.Denied &&\n            (this.isCurrentFrameContextCrossOrigin() ||\n                await SdkEnvironment.isFrameContextInsecure() ||\n                OneSignalUtils.isUsingSubscriptionWorkaround() ||\n                SdkEnvironment.isInsecureOrigin()));\n    }\n    /**\n     * Returns true if we're a cross-origin iframe.\n     *\n     * This means:\n     *\n     *   - We're not the top-level frame\n     *   - We're unable to access to the top-level frame's origin, or we can access the origin but it\n     *     is different. On most browsers, accessing the top-level origin should throw an exception.\n     */\n    isCurrentFrameContextCrossOrigin() {\n        let topFrameOrigin;\n        try {\n            // Accessing a cross-origin top-level frame's origin should throw an error\n            topFrameOrigin = window.top.location.origin;\n        }\n        catch (e) {\n            // We're in a cross-origin child iframe\n            return true;\n        }\n        return window.top !== window &&\n            topFrameOrigin !== window.location.origin;\n    }\n    /**\n     * To workaround Chrome 62+'s permission ambiguity for \"denied\" permissions,\n     * we assume the permission is \"default\" until we actually record the\n     * permission being \"denied\" or \"granted\".\n     *\n     * This allows our best-effort approach to subscribe new users, and upon\n     * subscribing, if we discover the actual permission to be denied, we record\n     * this for next time.\n     *\n     * @param reportedPermission The notification permission as reported by the\n     * browser without any modifications.\n     */\n    async getInterpretedAmbiguousPermission(reportedPermission) {\n        switch (reportedPermission) {\n            case NotificationPermission.Denied:\n                const storedPermission = this.getStoredPermission();\n                if (storedPermission) {\n                    // If we've recorded the last known actual browser permission, return that\n                    return storedPermission;\n                }\n                else {\n                    // If we don't have any stored permission, assume default\n                    return NotificationPermission.Default;\n                }\n            default:\n                return reportedPermission;\n        }\n    }\n    getStoredPermission() {\n        return LocalStorage.getStoredPermission();\n    }\n    setStoredPermission(permission) {\n        LocalStorage.setStoredPermission(permission);\n    }\n    async updateStoredPermission() {\n        // TODO verify if `OneSignal.config.safariWebId` should be passed as a parameter\n        const permission = await this.getNotificationPermission();\n        return this.setStoredPermission(permission);\n    }\n}\n//# sourceMappingURL=PermissionManager.js.map","import Environment from \"../Environment\";\nexport class BrowserUtils {\n    static decodeHtmlEntities(text) {\n        if (Environment.isBrowser()) {\n            if (!BrowserUtils.decodeTextArea) {\n                BrowserUtils.decodeTextArea = document.createElement(\"textarea\");\n            }\n        }\n        if (BrowserUtils.decodeTextArea) {\n            BrowserUtils.decodeTextArea.innerHTML = text;\n            return BrowserUtils.decodeTextArea.value;\n        }\n        else {\n            // Not running in a browser environment, text cannot be decoded\n            return text;\n        }\n    }\n}\nBrowserUtils.decodeTextArea = null;\nexport default BrowserUtils;\n//# sourceMappingURL=BrowserUtils.js.map","/**\n * LocalStorage with expiring keys.\n *\n * Used when synchronous data access is required, like when clicking the notify button to show the\n * popup conditionally based on a storage value. IndexedDb and cross-frame communication is\n * asynchronous and loses the direct user action privilege required to show a popup.\n */\nexport default class TimedLocalStorage {\n    /**\n     * Performs a feature test to determine whether LocalStorage is accessible. For example, a user's\n     * browser preferences set to prevent saving website data will disable LocalStorage.\n     */\n    static isLocalStorageSupported() {\n        try {\n            if (typeof localStorage === \"undefined\") {\n                return false;\n            }\n            localStorage.getItem(\"test\");\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    /**\n     * Sets a key in LocalStorage with an expiration time measured in minutes.\n     */\n    static setItem(key, value, expirationInMinutes) {\n        if (!TimedLocalStorage.isLocalStorageSupported()) {\n            return;\n        }\n        const expirationInMilliseconds = typeof expirationInMinutes !== \"undefined\" ?\n            expirationInMinutes * 60 * 1000 :\n            0;\n        const record = {\n            value: JSON.stringify(value),\n            timestamp: typeof expirationInMinutes !== \"undefined\" ?\n                new Date().getTime() + expirationInMilliseconds :\n                undefined,\n        };\n        localStorage.setItem(key, JSON.stringify(record));\n    }\n    /**\n     * Retrieves a key from LocalStorage if the expiration time when the key was set hasn't already\n     * expired.\n     */\n    static getItem(key) {\n        if (!TimedLocalStorage.isLocalStorageSupported()) {\n            return null;\n        }\n        const record = localStorage.getItem(key);\n        let parsedRecord;\n        try {\n            parsedRecord = JSON.parse(record);\n        }\n        catch (e) {\n            return null;\n        }\n        if (parsedRecord === null) {\n            return null;\n        }\n        if (parsedRecord.timestamp &&\n            new Date().getTime() >= parsedRecord.timestamp) {\n            localStorage.removeItem(key);\n            return null;\n        }\n        let parsedRecordValue = parsedRecord.value;\n        try {\n            parsedRecordValue = JSON.parse(parsedRecord.value);\n        }\n        catch (e) {\n            return parsedRecordValue;\n        }\n        return parsedRecordValue;\n    }\n    /**\n     * Removes an item from LocalStorage.\n     */\n    static removeItem(key) {\n        if (!TimedLocalStorage.isLocalStorageSupported()) {\n            return null;\n        }\n        localStorage.removeItem(key);\n    }\n}\n//# sourceMappingURL=TimedLocalStorage.js.map","/*\n LimitStore.put('colorado', 'rocky');\n [\"rocky\"]\n LimitStore.put('colorado', 'mountain');\n [\"rocky\", \"mountain\"]\n LimitStore.put('colorado', 'national');\n [\"mountain\", \"national\"]\n LimitStore.put('colorado', 'park');\n [\"national\", \"park\"]\n */\nexport default class LimitStore {\n    static put(key, value) {\n        if (LimitStore.store[key] === undefined) {\n            LimitStore.store[key] = [null, null];\n        }\n        LimitStore.store[key].push(value);\n        if (LimitStore.store[key].length == LimitStore.LIMIT + 1) {\n            LimitStore.store[key].shift();\n        }\n        return LimitStore.store[key];\n    }\n    static get(key) {\n        if (LimitStore.store[key] === undefined) {\n            LimitStore.store[key] = [null, null];\n        }\n        return LimitStore.store[key];\n    }\n    static getFirst(key) {\n        return LimitStore.get(key)[0];\n    }\n    static getLast(key) {\n        return LimitStore.get(key)[1];\n    }\n    static remove(key) {\n        delete LimitStore.store[key];\n    }\n    static isEmpty(key) {\n        let values = LimitStore.get(key);\n        return values[0] === null && values[1] === null;\n    }\n}\nLimitStore.store = {};\nLimitStore.LIMIT = 2;\n//# sourceMappingURL=LimitStore.js.map","import { hasCssClass, addCssClass, removeCssClass } from \"./utils\";\nimport Log from \"./libraries/Log\";\nexport class CustomLink {\n    static async initialize(config) {\n        if (!config || !config.enabled) {\n            return;\n        }\n        Log.info(\"Inititalize CustomLink\");\n        const sdkStylesLoadResult = await OneSignal.context.dynamicResourceLoader.loadSdkStylesheet();\n        if (sdkStylesLoadResult !== 0 /* Loaded */) {\n            Log.debug('Not initializing custom link button because styles failed to load.');\n            return;\n        }\n        const containerElements = document.querySelectorAll(CustomLink.containerSelector);\n        containerElements.forEach((element) => {\n            if (!CustomLink.isInitialized(element)) {\n                CustomLink.injectMarkup(element, config);\n            }\n        });\n        const isPushEnabled = await OneSignal.privateIsPushNotificationsEnabled();\n        const isOptedOut = await OneSignal.internalIsOptedOut();\n        const subscribeElements = document.querySelectorAll(CustomLink.subscribeSelector);\n        subscribeElements.forEach((element) => CustomLink.initSubscribeElement(element, config, isPushEnabled, isOptedOut));\n        const explanationElements = document.querySelectorAll(CustomLink.explanationSelector);\n        explanationElements.forEach((element) => CustomLink.initExplanationElement(element, config, isPushEnabled));\n    }\n    static injectMarkup(container, config) {\n        if (!config.text) {\n            Log.error(\"CustomLink: required property 'text' is missing in the config\");\n            return;\n        }\n        // Clearing out the contents of the container first\n        container.innerHTML = '';\n        if (config.text.explanation) {\n            const explanation = document.createElement(\"p\");\n            addCssClass(explanation, CustomLink.explanationClass);\n            container.appendChild(explanation);\n        }\n        if (config.text.subscribe) {\n            const subscribe = document.createElement(\"button\");\n            addCssClass(subscribe, CustomLink.subscribeClass);\n            container.appendChild(subscribe);\n        }\n        CustomLink.markAsInitialized(container);\n    }\n    static initSubscribeElement(element, config, isPushEnabled, isOptedOut) {\n        if (config.text && config.text.subscribe) {\n            if (!isPushEnabled) {\n                element.textContent = config.text.subscribe;\n            }\n        }\n        if (config.text && config.text.unsubscribe) {\n            if (isPushEnabled) {\n                element.textContent = config.text.unsubscribe;\n            }\n        }\n        CustomLink.setResetClass(element);\n        CustomLink.setStateClass(element, isPushEnabled);\n        CustomLink.setStyleClass(element, config);\n        CustomLink.setSizeClass(element, config);\n        CustomLink.setCustomColors(element, config);\n        if (config.unsubscribeEnabled !== true) {\n            addCssClass(element, \"hide\");\n        }\n        element.setAttribute(CustomLink.subscriptionStateAttribute, isPushEnabled.toString());\n        element.setAttribute(CustomLink.optedOutAttribute, isOptedOut.toString());\n        if (!CustomLink.isInitialized(element)) {\n            element.addEventListener(\"click\", () => {\n                Log.info(\"CustomLink: subscribe clicked\");\n                CustomLink.handleClick(element);\n            });\n            CustomLink.markAsInitialized(element);\n        }\n    }\n    static async handleClick(element) {\n        const state = element.getAttribute(CustomLink.subscriptionStateAttribute) === \"true\";\n        const optedOut = element.getAttribute(CustomLink.optedOutAttribute) === \"true\";\n        if (state) {\n            const isPushEnabled = await OneSignal.privateIsPushNotificationsEnabled();\n            if (isPushEnabled) {\n                await OneSignal.setSubscription(false);\n            }\n        }\n        else {\n            if (!optedOut) {\n                const autoAccept = !OneSignal.environmentInfo.requiresUserInteraction;\n                const options = { autoAccept };\n                await OneSignal.registerForPushNotifications(options);\n            }\n            else {\n                await OneSignal.setSubscription(true);\n            }\n        }\n    }\n    static initExplanationElement(element, config, isPushEnabled) {\n        if (config.text && config.text.explanation) {\n            element.textContent = config.text.explanation;\n        }\n        CustomLink.setResetClass(element);\n        CustomLink.setStateClass(element, isPushEnabled);\n        CustomLink.setSizeClass(element, config);\n        if (config.unsubscribeEnabled !== true) {\n            addCssClass(element, \"hide\");\n        }\n    }\n    // Using stricter HTMLElement class for element parameter to access style property\n    static setCustomColors(element, config) {\n        if (config.style === \"button\" && config.color && config.color.button && config.color.text) {\n            element.style.backgroundColor = config.color.button;\n            element.style.color = config.color.text;\n        }\n        else if (config.style === \"link\" && config.color && config.color.text) {\n            element.style.color = config.color.text;\n        }\n    }\n    static setStateClass(element, subscribed) {\n        const oldClassName = subscribed ? \"state-unsubscribed\" : \"state-subscribed\";\n        const newClassName = subscribed ? \"state-subscribed\" : \"state-unsubscribed\";\n        if (hasCssClass(element, oldClassName)) {\n            removeCssClass(element, oldClassName);\n        }\n        if (!hasCssClass(element, newClassName)) {\n            addCssClass(element, newClassName);\n        }\n    }\n    static setStyleClass(element, config) {\n        if (!config || !config.style) {\n            return;\n        }\n        const newClassName = config.style;\n        if (!hasCssClass(element, newClassName)) {\n            addCssClass(element, newClassName);\n        }\n    }\n    static setSizeClass(element, config) {\n        if (!config || !config.size) {\n            return;\n        }\n        const newClassName = config.size;\n        if (!hasCssClass(element, newClassName)) {\n            addCssClass(element, newClassName);\n        }\n    }\n    static setResetClass(element) {\n        const newClassName = CustomLink.resetClass;\n        if (!hasCssClass(element, newClassName)) {\n            addCssClass(element, newClassName);\n        }\n    }\n    static markAsInitialized(element) {\n        element.setAttribute(CustomLink.initializedAttribute, \"true\");\n    }\n    static isInitialized(element) {\n        return element.getAttribute(CustomLink.initializedAttribute) === \"true\";\n    }\n}\nCustomLink.initializedAttribute = \"data-cl-initialized\";\nCustomLink.subscriptionStateAttribute = \"data-cl-state\";\nCustomLink.optedOutAttribute = \"data-cl-optedout\";\nCustomLink.containerClass = \"onesignal-customlink-container\";\nCustomLink.containerSelector = `.${CustomLink.containerClass}`;\nCustomLink.subscribeClass = \"onesignal-customlink-subscribe\";\nCustomLink.subscribeSelector = `.${CustomLink.subscribeClass}`;\nCustomLink.explanationClass = \"onesignal-customlink-explanation\";\nCustomLink.explanationSelector = `.${CustomLink.explanationClass}`;\nCustomLink.resetClass = \"onesignal-reset\";\nexport default CustomLink;\n//# sourceMappingURL=CustomLink.js.map","export default class PromptsHelper {\n    static isCategorySlidedownConfigured(context) {\n        const { promptOptions } = context.appConfig.userConfig;\n        if (!promptOptions || !promptOptions.slidedown || !promptOptions.slidedown.categories) {\n            return false;\n        }\n        return (!!promptOptions.slidedown.categories.tags && promptOptions.slidedown.categories.tags.length > 0);\n    }\n}\n//# sourceMappingURL=PromptsHelper.js.map","import Event from '../Event';\nimport LimitStore from '../LimitStore';\nimport OneSignalApiShared from '../OneSignalApiShared';\nimport Database from '../services/Database';\nimport Log from '../libraries/Log';\nimport { CustomLink } from \"../CustomLink\";\nimport { OneSignalUtils } from \"../utils/OneSignalUtils\";\nimport { BrowserUtils } from \"../utils/BrowserUtils\";\nimport PromptsHelper from './PromptsHelper';\nimport LocalStorage from '../utils/LocalStorage';\nexport default class EventHelper {\n    static onNotificationPermissionChange() {\n        EventHelper.checkAndTriggerSubscriptionChanged();\n    }\n    static async onInternalSubscriptionSet(optedOut) {\n        LimitStore.put('subscription.optedOut', optedOut);\n    }\n    static async checkAndTriggerSubscriptionChanged() {\n        OneSignalUtils.logMethodCall('checkAndTriggerSubscriptionChanged');\n        const context = OneSignal.context;\n        const subscriptionState = await context.subscriptionManager.getSubscriptionState();\n        const isPushEnabled = await OneSignal.privateIsPushNotificationsEnabled();\n        const appState = await Database.getAppState();\n        const { lastKnownPushEnabled } = appState;\n        const didStateChange = (lastKnownPushEnabled === null ||\n            isPushEnabled !== lastKnownPushEnabled);\n        if (!didStateChange)\n            return;\n        Log.info(`The user's subscription state changed from ` +\n            `${lastKnownPushEnabled === null ? '(not stored)' : lastKnownPushEnabled}  ${subscriptionState.subscribed}`);\n        LocalStorage.setIsPushNotificationsEnabled(isPushEnabled);\n        appState.lastKnownPushEnabled = isPushEnabled;\n        await Database.setAppState(appState);\n        EventHelper.triggerSubscriptionChanged(isPushEnabled);\n    }\n    static async _onSubscriptionChanged(newSubscriptionState) {\n        EventHelper.onSubscriptionChanged_showWelcomeNotification(newSubscriptionState);\n        EventHelper.onSubscriptionChanged_sendCategorySlidedownTags(newSubscriptionState);\n        EventHelper.onSubscriptionChanged_evaluateNotifyButtonDisplayPredicate();\n        EventHelper.onSubscriptionChanged_updateCustomLink();\n    }\n    static async onSubscriptionChanged_sendCategorySlidedownTags(isSubscribed) {\n        if (isSubscribed !== true) {\n            return;\n        }\n        const { context } = OneSignal;\n        if (PromptsHelper.isCategorySlidedownConfigured(context)) {\n            await OneSignal.context.tagManager.sendTags(false);\n        }\n    }\n    static async onSubscriptionChanged_showWelcomeNotification(isSubscribed) {\n        if (OneSignal.__doNotShowWelcomeNotification) {\n            Log.debug('Not showing welcome notification because user has previously subscribed.');\n            return;\n        }\n        if (isSubscribed === true) {\n            const { deviceId } = await Database.getSubscription();\n            const { appId } = await Database.getAppConfig();\n            let welcome_notification_opts = OneSignal.config.userConfig.welcomeNotification;\n            let welcome_notification_disabled = welcome_notification_opts !== undefined && welcome_notification_opts['disable'] === true;\n            let title = welcome_notification_opts !== undefined &&\n                welcome_notification_opts['title'] !== undefined &&\n                welcome_notification_opts['title'] !== null\n                ? welcome_notification_opts['title']\n                : '';\n            let message = welcome_notification_opts !== undefined &&\n                welcome_notification_opts['message'] !== undefined &&\n                welcome_notification_opts['message'] !== null &&\n                welcome_notification_opts['message'].length > 0\n                ? welcome_notification_opts['message']\n                : 'Thanks for subscribing!';\n            let unopenableWelcomeNotificationUrl = new URL(location.href).origin + '?_osp=do_not_open';\n            let url = welcome_notification_opts && welcome_notification_opts['url'] && welcome_notification_opts['url'].length > 0\n                ? welcome_notification_opts['url']\n                : unopenableWelcomeNotificationUrl;\n            title = BrowserUtils.decodeHtmlEntities(title);\n            message = BrowserUtils.decodeHtmlEntities(message);\n            if (!welcome_notification_disabled) {\n                Log.debug('Sending welcome notification.');\n                OneSignalApiShared.sendNotification(appId, [deviceId], { en: title }, { en: message }, url, null, { __isOneSignalWelcomeNotification: true }, undefined);\n                Event.trigger(OneSignal.EVENTS.WELCOME_NOTIFICATION_SENT, {\n                    title: title,\n                    message: message,\n                    url: url\n                });\n            }\n        }\n    }\n    static async onSubscriptionChanged_evaluateNotifyButtonDisplayPredicate() {\n        if (!OneSignal.config.userConfig.notifyButton)\n            return;\n        const displayPredicate = OneSignal.config.userConfig.notifyButton.displayPredicate;\n        if (displayPredicate && typeof displayPredicate === \"function\" && OneSignal.notifyButton) {\n            const predicateResult = await displayPredicate();\n            if (predicateResult !== false) {\n                Log.debug('Showing notify button because display predicate returned true.');\n                OneSignal.notifyButton.launcher.show();\n            }\n            else {\n                Log.debug('Hiding notify button because display predicate returned false.');\n                OneSignal.notifyButton.launcher.hide();\n            }\n        }\n    }\n    static async onSubscriptionChanged_updateCustomLink() {\n        if (OneSignal.config.userConfig.promptOptions) {\n            await CustomLink.initialize(OneSignal.config.userConfig.promptOptions.customlink);\n        }\n    }\n    static triggerSubscriptionChanged(to) {\n        Event.trigger(OneSignal.EVENTS.SUBSCRIPTION_CHANGED, to);\n    }\n    /**\n     * When notifications are clicked, because the site isn't open, the notification is stored in the database. The next\n     * time the page opens, the event is triggered if its less than 5 minutes (usually page opens instantly from click).\n     *\n     * This method is fired for both HTTPS and HTTP sites, so for HTTP sites, the host URL needs to be used, not the\n     * subdomain.onesignal.com URL.\n     */\n    static async fireStoredNotificationClicks(url = document.URL) {\n        async function fireEventWithNotification(clickedNotificationInfo) {\n            // Remove the notification from the recently clicked list\n            // Once this page processes this retroactively provided clicked event, nothing should get the same event\n            const appState = await Database.getAppState();\n            appState.clickedNotifications[clickedNotificationInfo.url] = null;\n            await Database.setAppState(appState);\n            /* Clicked notifications look like:\n            {\n              \"url\": \"https://notify.tech\",\n              \"data\": {\n                \"id\": \"f44dfcc7-e8cd-47c6-af7e-e2b7ac68afca\",\n                \"heading\": \"Example Notification\",\n                \"content\": \"This is an example notification.\",\n                \"icon\": \"https://onesignal.com/images/notification_logo.png\"\n                (there would be a URL field here if it was set)\n              },\n              \"timestamp\": 1490998270607\n            }\n            */\n            const { data: notification, timestamp } = clickedNotificationInfo;\n            if (timestamp) {\n                const minutesSinceNotificationClicked = (Date.now() - timestamp) / 1000 / 60;\n                if (minutesSinceNotificationClicked > 5)\n                    return;\n            }\n            Event.trigger(OneSignal.EVENTS.NOTIFICATION_CLICKED, notification);\n        }\n        const appState = await Database.getAppState();\n        /* Is the flag notificationClickHandlerMatch: origin enabled?\n    \n           If so, this means we should provide a retroactive notification.clicked event as long as there exists any recently clicked\n           notification that matches this site's origin.\n    \n           Otherwise, the default behavior is to only provide a retroactive notification.clicked event if this page's URL exactly\n           matches the notification's URL.\n        */\n        const notificationClickHandlerMatch = await Database.get('Options', 'notificationClickHandlerMatch');\n        if (notificationClickHandlerMatch === 'origin') {\n            for (const clickedNotificationUrl of Object.keys(appState.clickedNotifications)) {\n                // Using notificationClickHandlerMatch: 'origin', as long as the notification's URL's origin matches our current tab's origin,\n                // fire the clicked event\n                if (new URL(clickedNotificationUrl).origin === location.origin) {\n                    const clickedNotification = appState.clickedNotifications[clickedNotificationUrl];\n                    await fireEventWithNotification(clickedNotification);\n                }\n            }\n        }\n        else {\n            /*\n              If a user is on https://site.com, document.URL and location.href both report the page's URL as https://site.com/.\n              This causes checking for notifications for the current URL to fail, since there is a notification for https://site.com,\n              but there is no notification for https://site.com/.\n      \n              As a workaround, if there are no notifications for https://site.com/, we'll do a check for https://site.com.\n            */\n            var pageClickedNotifications = appState.clickedNotifications[url];\n            if (pageClickedNotifications) {\n                await fireEventWithNotification(pageClickedNotifications);\n            }\n            else if (!pageClickedNotifications && url.endsWith('/')) {\n                var urlWithoutTrailingSlash = url.substring(0, url.length - 1);\n                pageClickedNotifications = appState.clickedNotifications[urlWithoutTrailingSlash];\n                if (pageClickedNotifications) {\n                    await fireEventWithNotification(pageClickedNotifications);\n                }\n            }\n        }\n    }\n}\n//# sourceMappingURL=EventHelper.js.map","export var Browser;\n(function (Browser) {\n    Browser[\"Safari\"] = \"safari\";\n    Browser[\"Firefox\"] = \"firefox\";\n    Browser[\"Chrome\"] = \"chrome\";\n    Browser[\"Opera\"] = \"opera\";\n    Browser[\"Edge\"] = \"edge\";\n    Browser[\"Other\"] = \"other\";\n})(Browser || (Browser = {}));\n//# sourceMappingURL=Browser.js.map","import PushPermissionNotGrantedError from '../errors/PushPermissionNotGrantedError';\nimport { PushPermissionNotGrantedErrorReason } from '../errors/PushPermissionNotGrantedError';\nimport { WindowEnvironmentKind } from '../models/WindowEnvironmentKind';\nimport EventHelper from './EventHelper';\nimport { InvalidStateError, InvalidStateReason } from '../errors/InvalidStateError';\nimport { NotificationPermission } from '../models/NotificationPermission';\nimport { RawPushSubscription } from '../models/RawPushSubscription';\nimport Log from '../libraries/Log';\nimport SdkEnvironment from '../managers/SdkEnvironment';\nimport { PermissionUtils } from \"../utils/PermissionUtils\";\nimport LocalStorage from '../utils/LocalStorage';\nimport { SessionOrigin } from \"../models/Session\";\nimport MainHelper from \"./MainHelper\";\nimport PageServiceWorkerHelper from \"./page/ServiceWorkerHelper\";\nimport { Browser } from \"../context/browser/models/Browser\";\nexport default class SubscriptionHelper {\n    static async registerForPush() {\n        const isPushEnabled = LocalStorage.getIsPushNotificationsEnabled();\n        return await SubscriptionHelper.internalRegisterForPush(isPushEnabled);\n    }\n    static async internalRegisterForPush(isPushEnabled) {\n        const context = OneSignal.context;\n        let subscription = null;\n        /*\n          Within the same page navigation (the same session), do not register for\n          push if the user is already subscribed, otherwise the user will have its\n          session count incremented on each page refresh. However, if the user is\n          not subscribed, subscribe.\n        */\n        if (isPushEnabled && !context.pageViewManager.isFirstPageView()) {\n            Log.debug('Not registering for push because the user is subscribed and this is not the first page view.');\n            Log.debug(\"But we want to rekindle their session.\");\n            const deviceId = await MainHelper.getDeviceId();\n            if (deviceId) {\n                const deviceRecord = await MainHelper.createDeviceRecord(OneSignal.config.appId, true);\n                await OneSignal.context.sessionManager.upsertSession(deviceId, deviceRecord, SessionOrigin.PageRefresh);\n            }\n            else {\n                Log.error(\"Should have been impossible to have push as enabled but no device id.\");\n            }\n            return null;\n        }\n        if (typeof OneSignal !== \"undefined\") {\n            if (OneSignal._isRegisteringForPush)\n                return null;\n            else\n                OneSignal._isRegisteringForPush = true;\n        }\n        switch (SdkEnvironment.getWindowEnv()) {\n            case WindowEnvironmentKind.Host:\n            case WindowEnvironmentKind.OneSignalSubscriptionModal:\n                try {\n                    const rawSubscription = await context.subscriptionManager.subscribe(0 /* ResubscribeExisting */);\n                    subscription = await context.subscriptionManager.registerSubscription(rawSubscription);\n                    context.pageViewManager.incrementPageViewCount();\n                    await PermissionUtils.triggerNotificationPermissionChanged();\n                    await EventHelper.checkAndTriggerSubscriptionChanged();\n                }\n                catch (e) {\n                    Log.info(e);\n                }\n                break;\n            case WindowEnvironmentKind.OneSignalSubscriptionPopup:\n                /*\n                  This is the code for the HTTP popup.\n                 */\n                const windowCreator = opener || parent;\n                let rawSubscription;\n                // Update the stored permission first, so we know the real value even if the user closes the\n                // popup\n                await context.permissionManager.updateStoredPermission();\n                try {\n                    /* If the user doesn't grant permissions, a PushPermissionNotGrantedError will be thrown here. */\n                    rawSubscription = await context.subscriptionManager.subscribe(1 /* SubscribeNew */);\n                    // Update the permission to granted\n                    await context.permissionManager.updateStoredPermission();\n                }\n                catch (e) {\n                    // Update the permission to denied or default\n                    await context.permissionManager.updateStoredPermission();\n                    if (e instanceof PushPermissionNotGrantedError) {\n                        switch (e.reason) {\n                            case PushPermissionNotGrantedErrorReason.Blocked:\n                                await context.permissionManager.updateStoredPermission();\n                                /* Force update false, because the iframe installs a native\n                                permission change handler that will be triggered when the user\n                                clicks out of the popup back to the parent page */\n                                OneSignal.subscriptionPopup.message(OneSignal.POSTMAM_COMMANDS.REMOTE_NOTIFICATION_PERMISSION_CHANGED, {\n                                    permission: NotificationPermission.Denied,\n                                    forceUpdatePermission: false\n                                });\n                                break;\n                            case PushPermissionNotGrantedErrorReason.Dismissed:\n                                /* Force update true because default permissions (before\n                                prompting) -> default permissions (after prompting) isn't a\n                                change, but we still want to be notified about it */\n                                OneSignal.subscriptionPopup.message(OneSignal.POSTMAM_COMMANDS.REMOTE_NOTIFICATION_PERMISSION_CHANGED, {\n                                    permission: NotificationPermission.Default,\n                                    forceUpdatePermission: true\n                                });\n                                break;\n                        }\n                    }\n                    /*\n                      Popup native permission request was blocked or dismissed\n                      Close the window\n                    */\n                    if (windowCreator) {\n                        window.close();\n                        return null;\n                    }\n                }\n                OneSignal.subscriptionPopup.message(OneSignal.POSTMAM_COMMANDS.FINISH_REMOTE_REGISTRATION, {\n                    rawPushSubscription: rawSubscription.serialize()\n                }, (message) => {\n                    if (message.data.progress === true) {\n                        Log.debug('Got message from host page that remote reg. is in progress, closing popup.');\n                        if (windowCreator) {\n                            window.close();\n                        }\n                    }\n                    else {\n                        Log.debug('Got message from host page that remote reg. could not be finished.');\n                    }\n                });\n                break;\n            default:\n                if (typeof OneSignal !== \"undefined\")\n                    OneSignal._isRegisteringForPush = false;\n                throw new InvalidStateError(InvalidStateReason.UnsupportedEnvironment);\n        }\n        if (typeof OneSignal !== \"undefined\")\n            OneSignal._isRegisteringForPush = false;\n        return subscription;\n    }\n    static getRawPushSubscriptionForSafari(safariWebId) {\n        const subscription = new RawPushSubscription();\n        const { deviceToken: existingDeviceToken } = window.safari.pushNotification.permission(safariWebId);\n        subscription.existingSafariDeviceToken = existingDeviceToken;\n        return subscription;\n    }\n    static async getRawPushSubscriptionFromServiceWorkerRegistration() {\n        const registration = await PageServiceWorkerHelper.getRegistration();\n        if (!registration) {\n            return null;\n        }\n        const swSubscription = await registration.pushManager.getSubscription();\n        if (!swSubscription) {\n            return null;\n        }\n        return RawPushSubscription.setFromW3cSubscription(swSubscription);\n    }\n    static async getRawPushSubscriptionWhenUsingSubscriptionWorkaround() {\n        // we would need to message service worker to get it. we'll get it from inside if necessary\n        return null;\n    }\n    static async getRawPushSubscription(environmentInfo, safariWebId) {\n        if (environmentInfo.browserType === Browser.Safari) {\n            return SubscriptionHelper.getRawPushSubscriptionForSafari(safariWebId);\n        }\n        if (environmentInfo.isUsingSubscriptionWorkaround) {\n            return SubscriptionHelper.getRawPushSubscriptionWhenUsingSubscriptionWorkaround();\n        }\n        if (environmentInfo.isBrowserAndSupportsServiceWorkers) {\n            return await SubscriptionHelper.getRawPushSubscriptionFromServiceWorkerRegistration();\n        }\n        return null;\n    }\n}\n//# sourceMappingURL=SubscriptionHelper.js.map","import { InvalidStateError, InvalidStateReason } from '../errors/InvalidStateError';\nimport Event from '../Event';\nimport SdkEnvironment from '../managers/SdkEnvironment';\nimport Database from '../services/Database';\nimport TimedLocalStorage from '../modules/TimedLocalStorage';\nimport Log from '../libraries/Log';\nimport { SubscriptionStateKind } from '../models/SubscriptionStateKind';\nimport { NotificationPermission } from \"../models/NotificationPermission\";\nimport { PushDeviceRecord } from \"../models/PushDeviceRecord\";\nimport { OneSignalUtils } from \"../utils/OneSignalUtils\";\nimport { PermissionUtils } from \"../utils/PermissionUtils\";\nimport { Utils } from \"../context/shared/utils/Utils\";\nimport SubscriptionHelper from \"./SubscriptionHelper\";\nimport { SERVER_CONFIG_DEFAULTS_SLIDEDOWN } from '../config';\nexport default class MainHelper {\n    static async getCurrentNotificationType() {\n        const currentPermission = await OneSignal.context.permissionManager.getNotificationPermission(OneSignal.context.appConfig.safariWebId);\n        if (currentPermission === NotificationPermission.Default) {\n            return SubscriptionStateKind.Default;\n        }\n        if (currentPermission === NotificationPermission.Denied) {\n            // Due to this issue https://github.com/OneSignal/OneSignal-Website-SDK/issues/289 we cannot reliably detect\n            // \"default\" permission in HTTP context. Browser reports denied for both \"default\" and \"denied\" statuses.\n            // Returning SubscriptionStateKind.Default for this case.\n            return (OneSignalUtils.isUsingSubscriptionWorkaround()) ?\n                SubscriptionStateKind.Default :\n                SubscriptionStateKind.NotSubscribed;\n        }\n        const existingUser = await OneSignal.context.subscriptionManager.isAlreadyRegisteredWithOneSignal();\n        if (currentPermission === NotificationPermission.Granted && existingUser) {\n            const isPushEnabled = await OneSignal.privateIsPushNotificationsEnabled();\n            return isPushEnabled ? SubscriptionStateKind.Subscribed : SubscriptionStateKind.MutedByApi;\n        }\n        return SubscriptionStateKind.Default;\n    }\n    /**\n     * If the user has manually opted out of notifications (OneSignal.setSubscription), returns -2; otherwise returns 1.\n     * @param isOptedIn The result of OneSignal.getSubscription().\n     */\n    static getNotificationTypeFromOptIn(isOptedIn) {\n        if (isOptedIn == true || isOptedIn == null) {\n            return SubscriptionStateKind.Subscribed;\n        }\n        else {\n            return SubscriptionStateKind.MutedByApi;\n        }\n    }\n    /**\n     * Returns true if a LocalStorage entry exists for noting the user dismissed the native prompt.\n     */\n    static wasHttpsNativePromptDismissed() {\n        return TimedLocalStorage.getItem('onesignal-notification-prompt') === 'dismissed';\n    }\n    /**\n     * Stores a flag in sessionStorage that we've already shown the HTTP slidedown to this user and that we should not\n     * show it again until they open a new window or tab to the site.\n     */\n    static markHttpSlidedownShown() {\n        sessionStorage.setItem('ONESIGNAL_HTTP_PROMPT_SHOWN', 'true');\n    }\n    /**\n     * Returns true if the HTTP slidedown was already shown inside the same session.\n     */\n    static isHttpPromptAlreadyShown() {\n        return sessionStorage.getItem('ONESIGNAL_HTTP_PROMPT_SHOWN') == 'true';\n    }\n    static async checkAndTriggerNotificationPermissionChanged() {\n        const previousPermission = await Database.get('Options', 'notificationPermission');\n        const currentPermission = await OneSignal.getNotificationPermission();\n        if (previousPermission !== currentPermission) {\n            await PermissionUtils.triggerNotificationPermissionChanged();\n            await Database.put('Options', {\n                key: 'notificationPermission',\n                value: currentPermission\n            });\n        }\n    }\n    static async getNotificationIcons() {\n        const appId = await MainHelper.getAppId();\n        if (!appId) {\n            throw new InvalidStateError(InvalidStateReason.MissingAppId);\n        }\n        const url = `${SdkEnvironment.getOneSignalApiUrl().toString()}/apps/${appId}/icon`;\n        const response = await fetch(url);\n        const data = await response.json();\n        if (data.errors) {\n            Log.error(`API call %c${url}`, Utils.getConsoleStyle('code'), 'failed with:', data.errors);\n            throw new Error('Failed to get notification icons.');\n        }\n        return data;\n    }\n    static getSlidedownPermissionMessageOptions(promptOptions) {\n        if (!promptOptions || !promptOptions.slidedown) {\n            const actionMessage = !!promptOptions ? promptOptions.actionMessage :\n                SERVER_CONFIG_DEFAULTS_SLIDEDOWN.actionMessage;\n            const acceptButtonText = !!promptOptions ? promptOptions.acceptButtonText :\n                SERVER_CONFIG_DEFAULTS_SLIDEDOWN.acceptButton;\n            const cancelButtonText = !!promptOptions ? promptOptions.cancelButtonText :\n                SERVER_CONFIG_DEFAULTS_SLIDEDOWN.cancelButton;\n            return {\n                enabled: false,\n                autoPrompt: false,\n                actionMessage,\n                acceptButtonText,\n                cancelButtonText,\n            };\n        }\n        // slidedown prompt options are defined\n        const { categories } = promptOptions.slidedown;\n        if (!!categories) {\n            categories.positiveUpdateButton = Utils.getValueOrDefault(categories.positiveUpdateButton, SERVER_CONFIG_DEFAULTS_SLIDEDOWN.categoryDefaults.positiveUpdateButton);\n            categories.negativeUpdateButton = Utils.getValueOrDefault(categories.negativeUpdateButton, SERVER_CONFIG_DEFAULTS_SLIDEDOWN.categoryDefaults.negativeUpdateButton);\n            categories.updateMessage = Utils.getValueOrDefault(categories.updateMessage, SERVER_CONFIG_DEFAULTS_SLIDEDOWN.categoryDefaults.updateMessage);\n        }\n        return {\n            enabled: promptOptions.slidedown.enabled,\n            autoPrompt: promptOptions.slidedown.autoPrompt,\n            actionMessage: promptOptions.slidedown.actionMessage || SERVER_CONFIG_DEFAULTS_SLIDEDOWN.actionMessage,\n            acceptButtonText: promptOptions.slidedown.acceptButtonText || SERVER_CONFIG_DEFAULTS_SLIDEDOWN.acceptButton,\n            cancelButtonText: promptOptions.slidedown.cancelButtonText || SERVER_CONFIG_DEFAULTS_SLIDEDOWN.cancelButton,\n            categories\n        };\n    }\n    static getFullscreenPermissionMessageOptions(promptOptions) {\n        if (!promptOptions) {\n            return null;\n        }\n        if (!promptOptions.fullscreen) {\n            return promptOptions;\n        }\n        return {\n            autoAcceptTitle: promptOptions.fullscreen.autoAcceptTitle,\n            actionMessage: promptOptions.fullscreen.actionMessage,\n            exampleNotificationTitleDesktop: promptOptions.fullscreen.title,\n            exampleNotificationTitleMobile: promptOptions.fullscreen.title,\n            exampleNotificationMessageDesktop: promptOptions.fullscreen.message,\n            exampleNotificationMessageMobile: promptOptions.fullscreen.message,\n            exampleNotificationCaption: promptOptions.fullscreen.caption,\n            acceptButtonText: promptOptions.fullscreen.acceptButton,\n            cancelButtonText: promptOptions.fullscreen.cancelButton,\n        };\n    }\n    static getPromptOptionsQueryString() {\n        let promptOptions = MainHelper.getFullscreenPermissionMessageOptions(OneSignal.config.userConfig.promptOptions);\n        let promptOptionsStr = '';\n        if (promptOptions) {\n            let hash = MainHelper.getPromptOptionsPostHash();\n            for (let key of Object.keys(hash)) {\n                var value = hash[key];\n                promptOptionsStr += '&' + key + '=' + value;\n            }\n        }\n        return promptOptionsStr;\n    }\n    static getPromptOptionsPostHash() {\n        let promptOptions = MainHelper.getFullscreenPermissionMessageOptions(OneSignal.config.userConfig.promptOptions);\n        if (promptOptions) {\n            var legacyParams = {\n                exampleNotificationTitleDesktop: 'exampleNotificationTitle',\n                exampleNotificationMessageDesktop: 'exampleNotificationMessage',\n                exampleNotificationTitleMobile: 'exampleNotificationTitle',\n                exampleNotificationMessageMobile: 'exampleNotificationMessage'\n            };\n            for (let legacyParamKey of Object.keys(legacyParams)) {\n                let legacyParamValue = legacyParams[legacyParamKey];\n                if (promptOptions[legacyParamKey]) {\n                    promptOptions[legacyParamValue] = promptOptions[legacyParamKey];\n                }\n            }\n            var allowedPromptOptions = [\n                'autoAcceptTitle',\n                'siteName',\n                'autoAcceptTitle',\n                'subscribeText',\n                'showGraphic',\n                'actionMessage',\n                'exampleNotificationTitle',\n                'exampleNotificationMessage',\n                'exampleNotificationCaption',\n                'acceptButtonText',\n                'cancelButtonText',\n                'timeout'\n            ];\n            var hash = {};\n            for (var i = 0; i < allowedPromptOptions.length; i++) {\n                var key = allowedPromptOptions[i];\n                var value = promptOptions[key];\n                var encoded_value = encodeURIComponent(value);\n                if (value || value === false || value === '') {\n                    hash[key] = encoded_value;\n                }\n            }\n        }\n        return hash;\n    }\n    static triggerCustomPromptClicked(clickResult) {\n        Event.trigger(OneSignal.EVENTS.CUSTOM_PROMPT_CLICKED, {\n            result: clickResult\n        });\n    }\n    static async getAppId() {\n        if (OneSignal.config.appId) {\n            return Promise.resolve(OneSignal.config.appId);\n        }\n        else {\n            const appId = await Database.get('Ids', 'appId');\n            return appId;\n        }\n    }\n    static async createDeviceRecord(appId, includeSubscription = false) {\n        let subscription;\n        if (includeSubscription) {\n            // TODO: refactor to replace config with dependency injection\n            const rawSubscription = await SubscriptionHelper.getRawPushSubscription(OneSignal.environmentInfo, OneSignal.config.safariWebId);\n            if (rawSubscription) {\n                subscription = rawSubscription;\n            }\n        }\n        const deviceRecord = new PushDeviceRecord(subscription);\n        deviceRecord.appId = appId;\n        deviceRecord.subscriptionState = await MainHelper.getCurrentNotificationType();\n        return deviceRecord;\n    }\n    static async getDeviceId() {\n        const subscription = await OneSignal.database.getSubscription();\n        return subscription.deviceId || undefined;\n    }\n}\n//# sourceMappingURL=MainHelper.js.map","import Log from \"../../libraries/Log\";\nexport default class ServiceWorkerHelper {\n    // Gets details on the service-worker (if any) that controls the current page\n    static async getRegistration() {\n        try {\n            // location.href is used for <base> tag compatibility when it is set to a different origin\n            return await navigator.serviceWorker.getRegistration(location.href);\n        }\n        catch (e) {\n            // This could be null in an HTTP context or error if the user doesn't accept cookies\n            Log.warn(\"[Service Worker Status] Error Checking service worker registration\", location.href, e);\n            return null;\n        }\n    }\n}\n//# sourceMappingURL=ServiceWorkerHelper.js.map","export var ConfigIntegrationKind;\n(function (ConfigIntegrationKind) {\n    ConfigIntegrationKind[\"TypicalSite\"] = \"typical\";\n    ConfigIntegrationKind[\"WordPress\"] = \"wordpress\";\n    ConfigIntegrationKind[\"Shopify\"] = \"shopify\";\n    ConfigIntegrationKind[\"Blogger\"] = \"blogger\";\n    ConfigIntegrationKind[\"Magento\"] = \"magento\";\n    ConfigIntegrationKind[\"Drupal\"] = \"drupal\";\n    ConfigIntegrationKind[\"SquareSpace\"] = \"squarespace\";\n    ConfigIntegrationKind[\"Joomla\"] = \"joomla\";\n    ConfigIntegrationKind[\"Weebly\"] = \"weebly\";\n    ConfigIntegrationKind[\"Wix\"] = \"wix\";\n    ConfigIntegrationKind[\"Custom\"] = \"custom\";\n})(ConfigIntegrationKind || (ConfigIntegrationKind = {}));\nexport var NotificationClickMatchBehavior;\n(function (NotificationClickMatchBehavior) {\n    NotificationClickMatchBehavior[\"Exact\"] = \"exact\";\n    NotificationClickMatchBehavior[\"Origin\"] = \"origin\";\n})(NotificationClickMatchBehavior || (NotificationClickMatchBehavior = {}));\nexport var NotificationClickActionBehavior;\n(function (NotificationClickActionBehavior) {\n    NotificationClickActionBehavior[\"Navigate\"] = \"navigate\";\n    NotificationClickActionBehavior[\"Focus\"] = \"focus\";\n})(NotificationClickActionBehavior || (NotificationClickActionBehavior = {}));\n//# sourceMappingURL=AppConfig.js.map","import { ConfigIntegrationKind } from \"../models/AppConfig\";\nimport { WindowEnvironmentKind } from \"../models/WindowEnvironmentKind\";\nimport { SdkInitError, SdkInitErrorKind } from \"../errors/SdkInitError\";\nimport SdkEnvironment from \"../managers/SdkEnvironment\";\nimport OneSignalUtils from \"../utils/OneSignalUtils\";\nimport Utils from \"../context/shared/utils/Utils\";\nimport MainHelper from './MainHelper';\nimport { SERVER_CONFIG_DEFAULTS_SESSION, SERVER_CONFIG_DEFAULTS_PROMPT_DELAYS } from \"../config\";\nimport TagUtils from '../../src/utils/TagUtils';\nexport var IntegrationConfigurationKind;\n(function (IntegrationConfigurationKind) {\n    /**\n     * Configuration comes from the dashboard only.\n     */\n    IntegrationConfigurationKind[IntegrationConfigurationKind[\"Dashboard\"] = 0] = \"Dashboard\";\n    /**\n     * Configuration comes from user-provided JavaScript code only.\n     */\n    IntegrationConfigurationKind[IntegrationConfigurationKind[\"JavaScript\"] = 1] = \"JavaScript\";\n})(IntegrationConfigurationKind || (IntegrationConfigurationKind = {}));\nconst MAX_CATEGORIES = 10;\nexport class ConfigHelper {\n    static async getAppConfig(userConfig, downloadServerAppConfig) {\n        try {\n            if (!userConfig || !userConfig.appId || !OneSignalUtils.isValidUuid(userConfig.appId))\n                throw new SdkInitError(SdkInitErrorKind.InvalidAppId);\n            const serverConfig = await downloadServerAppConfig(userConfig.appId);\n            const appConfig = this.getMergedConfig(userConfig, serverConfig);\n            this.checkRestrictedOrigin(appConfig);\n            return appConfig;\n        }\n        catch (e) {\n            if (e) {\n                if (e.code === 1)\n                    throw new SdkInitError(SdkInitErrorKind.InvalidAppId);\n                else if (e.code === 2)\n                    throw new SdkInitError(SdkInitErrorKind.AppNotConfiguredForWebPush);\n            }\n            throw e;\n        }\n    }\n    static checkRestrictedOrigin(appConfig) {\n        if (appConfig.restrictedOriginEnabled) {\n            if (SdkEnvironment.getWindowEnv() !== WindowEnvironmentKind.ServiceWorker) {\n                if (window.top === window &&\n                    !Utils.contains(window.location.hostname, \".os.tc\") &&\n                    !Utils.contains(window.location.hostname, \".onesignal.com\") &&\n                    !this.doesCurrentOriginMatchConfigOrigin(appConfig.origin)) {\n                    throw new SdkInitError(SdkInitErrorKind.WrongSiteUrl, {\n                        siteUrl: appConfig.origin\n                    });\n                }\n            }\n        }\n    }\n    static doesCurrentOriginMatchConfigOrigin(configOrigin) {\n        try {\n            return location.origin === new URL(configOrigin).origin;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    static getIntegrationCapabilities(integration) {\n        switch (integration) {\n            case ConfigIntegrationKind.Custom:\n            case ConfigIntegrationKind.WordPress:\n                return { configuration: IntegrationConfigurationKind.JavaScript };\n            default:\n                return { configuration: IntegrationConfigurationKind.Dashboard };\n        }\n    }\n    static getMergedConfig(userConfig, serverConfig) {\n        const configIntegrationKind = this.getConfigIntegrationKind(serverConfig);\n        const subdomain = this.getSubdomainForConfigIntegrationKind(configIntegrationKind, userConfig, serverConfig);\n        const allowLocalhostAsSecureOrigin = (serverConfig.config.setupBehavior ?\n            serverConfig.config.setupBehavior.allowLocalhostAsSecureOrigin :\n            userConfig.allowLocalhostAsSecureOrigin);\n        const isUsingSubscriptionWorkaround = OneSignalUtils.internalIsUsingSubscriptionWorkaround(subdomain, allowLocalhostAsSecureOrigin);\n        const mergedUserConfig = this.getUserConfigForConfigIntegrationKind(configIntegrationKind, userConfig, serverConfig, isUsingSubscriptionWorkaround);\n        return {\n            appId: serverConfig.app_id,\n            subdomain,\n            origin: serverConfig.config.origin,\n            httpUseOneSignalCom: serverConfig.config.http_use_onesignal_com,\n            cookieSyncEnabled: serverConfig.features.cookie_sync.enable,\n            restrictedOriginEnabled: serverConfig.features.restrict_origin && serverConfig.features.restrict_origin.enable,\n            metrics: {\n                enable: serverConfig.features.metrics.enable,\n                mixpanelReportingToken: serverConfig.features.metrics.mixpanel_reporting_token\n            },\n            safariWebId: serverConfig.config.safari_web_id,\n            vapidPublicKey: serverConfig.config.vapid_public_key,\n            onesignalVapidPublicKey: serverConfig.config.onesignal_vapid_public_key,\n            emailAuthRequired: serverConfig.features.email && serverConfig.features.email.require_auth,\n            userConfig: mergedUserConfig,\n            // default confirmed deliveries feature to off\n            receiveReceiptsEnable: serverConfig.features.receive_receipts_enable || false,\n            enableOnSession: Utils.valueOrDefault(serverConfig.features.enable_on_session, SERVER_CONFIG_DEFAULTS_SESSION.enableOnSessionForUnsubcribed),\n            sessionThreshold: Utils.valueOrDefault(serverConfig.features.session_threshold, SERVER_CONFIG_DEFAULTS_SESSION.reportingThreshold),\n            enableSessionDuration: Utils.valueOrDefault(serverConfig.features.web_on_focus_enabled, SERVER_CONFIG_DEFAULTS_SESSION.enableOnFocus)\n        };\n    }\n    static getConfigIntegrationKind(serverConfig) {\n        if (serverConfig.config.integration)\n            return serverConfig.config.integration.kind;\n        return ConfigIntegrationKind.Custom;\n    }\n    static getCustomLinkConfig(serverConfig) {\n        const initialState = {\n            enabled: false,\n            style: \"button\",\n            size: \"medium\",\n            unsubscribeEnabled: false,\n            text: {\n                explanation: \"\",\n                subscribe: \"\",\n                unsubscribe: \"\",\n            },\n            color: {\n                button: \"\",\n                text: \"\",\n            }\n        };\n        if (!serverConfig || !serverConfig.config ||\n            !serverConfig.config.staticPrompts || !serverConfig.config.staticPrompts.customlink ||\n            !serverConfig.config.staticPrompts.customlink.enabled) {\n            return initialState;\n        }\n        const customlink = serverConfig.config.staticPrompts.customlink;\n        return {\n            enabled: customlink.enabled,\n            style: customlink.style,\n            size: customlink.size,\n            unsubscribeEnabled: customlink.unsubscribeEnabled,\n            text: customlink.text ? {\n                subscribe: customlink.text.subscribe,\n                unsubscribe: customlink.text.unsubscribe,\n                explanation: customlink.text.explanation,\n            } : initialState.text,\n            color: customlink.color ? {\n                button: customlink.color.button,\n                text: customlink.color.text,\n            } : initialState.color,\n        };\n    }\n    /**\n     * Used for Custom Code Integration Type\n     * @param  {AppUserConfigPromptOptions|undefined} promptOptions\n     * @param  {ServerAppConfigPrompt} defaultsFromServer\n     * @param  {AppUserConfig} wholeUserConfig\n     * @param  {boolean=false} isUsingSubscriptionWorkaround\n     * @returns AppUserConfigPromptOptions\n     */\n    static injectDefaultsIntoPromptOptions(promptOptions, defaultsFromServer, wholeUserConfig, isUsingSubscriptionWorkaround = false) {\n        let customlinkUser = { enabled: false };\n        if (promptOptions && promptOptions.customlink) {\n            customlinkUser = promptOptions.customlink;\n        }\n        const customlinkDefaults = defaultsFromServer.customlink;\n        const promptOptionsConfig = Object.assign({}, promptOptions, { customlink: {\n                enabled: Utils.getValueOrDefault(customlinkUser.enabled, customlinkDefaults.enabled),\n                style: Utils.getValueOrDefault(customlinkUser.style, customlinkDefaults.style),\n                size: Utils.getValueOrDefault(customlinkUser.size, customlinkDefaults.size),\n                unsubscribeEnabled: Utils.getValueOrDefault(customlinkUser.unsubscribeEnabled, customlinkDefaults.unsubscribeEnabled),\n                text: {\n                    subscribe: Utils.getValueOrDefault(customlinkUser.text ? customlinkUser.text.subscribe : undefined, customlinkDefaults.text.subscribe),\n                    unsubscribe: Utils.getValueOrDefault(customlinkUser.text ? customlinkUser.text.unsubscribe : undefined, customlinkDefaults.text.unsubscribe),\n                    explanation: Utils.getValueOrDefault(customlinkUser.text ? customlinkUser.text.explanation : undefined, customlinkDefaults.text.explanation),\n                },\n                color: {\n                    button: Utils.getValueOrDefault(customlinkUser.color ? customlinkUser.color.button : undefined, customlinkDefaults.color.button),\n                    text: Utils.getValueOrDefault(customlinkUser.color ? customlinkUser.color.text : undefined, customlinkDefaults.color.text),\n                },\n            } });\n        if (promptOptionsConfig.slidedown) {\n            promptOptionsConfig.slidedown.enabled = !!promptOptionsConfig.slidedown.enabled;\n            promptOptionsConfig.slidedown.autoPrompt = promptOptionsConfig.slidedown.hasOwnProperty(\"autoPrompt\") ?\n                !!promptOptionsConfig.slidedown.enabled && !!promptOptionsConfig.slidedown.autoPrompt :\n                !!promptOptionsConfig.slidedown.enabled;\n            promptOptionsConfig.slidedown.pageViews = Utils.getValueOrDefault(promptOptionsConfig.slidedown.pageViews, SERVER_CONFIG_DEFAULTS_PROMPT_DELAYS.pageViews);\n            promptOptionsConfig.slidedown.timeDelay = Utils.getValueOrDefault(promptOptionsConfig.slidedown.timeDelay, SERVER_CONFIG_DEFAULTS_PROMPT_DELAYS.timeDelay);\n            if (promptOptionsConfig.slidedown.categories) {\n                const { categories } = promptOptionsConfig.slidedown;\n                promptOptionsConfig.slidedown.categories = TagUtils.limitCategoriesToMaxCount(categories, MAX_CATEGORIES);\n            }\n        }\n        else {\n            promptOptionsConfig.slidedown = MainHelper.getSlidedownPermissionMessageOptions(promptOptionsConfig);\n            promptOptionsConfig.slidedown.enabled = false;\n            promptOptionsConfig.slidedown.autoPrompt = false;\n            promptOptionsConfig.slidedown.pageViews = SERVER_CONFIG_DEFAULTS_PROMPT_DELAYS.pageViews;\n            promptOptionsConfig.slidedown.timeDelay = SERVER_CONFIG_DEFAULTS_PROMPT_DELAYS.timeDelay;\n        }\n        if (promptOptionsConfig.native) {\n            promptOptionsConfig.native.enabled = !!promptOptionsConfig.native.enabled;\n            promptOptionsConfig.native.autoPrompt = promptOptionsConfig.native.hasOwnProperty(\"autoPrompt\") ?\n                !!promptOptionsConfig.native.enabled && !!promptOptionsConfig.native.autoPrompt :\n                !!promptOptionsConfig.native.enabled;\n            promptOptionsConfig.native.pageViews = Utils.getValueOrDefault(promptOptionsConfig.native.pageViews, SERVER_CONFIG_DEFAULTS_PROMPT_DELAYS.pageViews);\n            promptOptionsConfig.native.timeDelay = Utils.getValueOrDefault(promptOptionsConfig.native.timeDelay, SERVER_CONFIG_DEFAULTS_PROMPT_DELAYS.timeDelay);\n        }\n        else {\n            promptOptionsConfig.native = {\n                enabled: false,\n                autoPrompt: false,\n                pageViews: SERVER_CONFIG_DEFAULTS_PROMPT_DELAYS.pageViews,\n                timeDelay: SERVER_CONFIG_DEFAULTS_PROMPT_DELAYS.timeDelay\n            };\n        }\n        /**\n         * If autoRegister is true, show native prompt for https and slidedown for http ignoring any other related\n         * prompt options.\n         */\n        if (wholeUserConfig.autoRegister === true) {\n            if (isUsingSubscriptionWorkaround) {\n                // disable native prompt\n                promptOptionsConfig.native.enabled = false;\n                promptOptionsConfig.native.autoPrompt = false;\n                // enable slidedown & make it autoPrompt\n                promptOptionsConfig.slidedown.enabled = true;\n                promptOptionsConfig.slidedown.autoPrompt = true;\n            }\n            else {\n                //enable native prompt & make it autoPrompt\n                promptOptionsConfig.native.enabled = true;\n                promptOptionsConfig.native.autoPrompt = true;\n                //leave slidedown settings without change\n            }\n        }\n        promptOptionsConfig.autoPrompt = promptOptionsConfig.native.autoPrompt ||\n            promptOptionsConfig.slidedown.autoPrompt;\n        return promptOptionsConfig;\n    }\n    /**\n     * Used only with Dashboard Configuration\n     * @param  {ServerAppConfig} serverConfig\n     * @returns AppUserConfigPromptOptions\n     */\n    static getPromptOptionsForDashboardConfiguration(serverConfig) {\n        const staticPrompts = serverConfig.config.staticPrompts;\n        const native = staticPrompts.native ? {\n            enabled: staticPrompts.native.enabled,\n            autoPrompt: staticPrompts.native.enabled && staticPrompts.native.autoPrompt !== false,\n            pageViews: Utils.getValueOrDefault(staticPrompts.native.pageViews, SERVER_CONFIG_DEFAULTS_PROMPT_DELAYS.pageViews),\n            timeDelay: Utils.getValueOrDefault(staticPrompts.native.timeDelay, SERVER_CONFIG_DEFAULTS_PROMPT_DELAYS.timeDelay)\n        } : {\n            enabled: false,\n            autoPrompt: false,\n            pageViews: SERVER_CONFIG_DEFAULTS_PROMPT_DELAYS.pageViews,\n            timeDelay: SERVER_CONFIG_DEFAULTS_PROMPT_DELAYS.timeDelay\n        };\n        let categories;\n        if (staticPrompts.slidedown.categories) {\n            categories = TagUtils.limitCategoriesToMaxCount(staticPrompts.slidedown.categories, MAX_CATEGORIES);\n        }\n        const slidedown = {\n            enabled: staticPrompts.slidedown.enabled,\n            // for backwards compatibility if not specifically false, then assume true for autoPrompt on slidedown\n            autoPrompt: staticPrompts.slidedown.enabled &&\n                staticPrompts.slidedown.autoPrompt !== false,\n            pageViews: Utils.getValueOrDefault(staticPrompts.slidedown.pageViews, SERVER_CONFIG_DEFAULTS_PROMPT_DELAYS.pageViews),\n            timeDelay: Utils.getValueOrDefault(staticPrompts.slidedown.timeDelay, SERVER_CONFIG_DEFAULTS_PROMPT_DELAYS.timeDelay),\n            actionMessage: staticPrompts.slidedown.actionMessage,\n            acceptButtonText: staticPrompts.slidedown.acceptButton,\n            cancelButtonText: staticPrompts.slidedown.cancelButton,\n            categories\n        };\n        return {\n            autoPrompt: native.autoPrompt || slidedown.autoPrompt,\n            native,\n            slidedown,\n            fullscreen: {\n                enabled: staticPrompts.fullscreen.enabled,\n                actionMessage: staticPrompts.fullscreen.actionMessage,\n                acceptButton: staticPrompts.fullscreen.acceptButton,\n                cancelButton: staticPrompts.fullscreen.cancelButton,\n                title: staticPrompts.fullscreen.title,\n                message: staticPrompts.fullscreen.message,\n                caption: staticPrompts.fullscreen.caption,\n                autoAcceptTitle: staticPrompts.fullscreen.autoAcceptTitle,\n            },\n            customlink: this.getCustomLinkConfig(serverConfig),\n        };\n    }\n    static getUserConfigForConfigIntegrationKind(configIntegrationKind, userConfig, serverConfig, isUsingSubscriptionWorkaround = false) {\n        const integrationCapabilities = this.getIntegrationCapabilities(configIntegrationKind);\n        switch (integrationCapabilities.configuration) {\n            case IntegrationConfigurationKind.Dashboard:\n                /*\n                  Ignores code-based initialization configuration and uses dashboard configuration only.\n                 */\n                return {\n                    appId: serverConfig.app_id,\n                    autoRegister: false,\n                    autoResubscribe: serverConfig.config.autoResubscribe,\n                    path: serverConfig.config.serviceWorker.path,\n                    serviceWorkerPath: serverConfig.config.serviceWorker.workerName,\n                    serviceWorkerUpdaterPath: serverConfig.config.serviceWorker.updaterWorkerName,\n                    serviceWorkerParam: { scope: serverConfig.config.serviceWorker.registrationScope },\n                    subdomainName: serverConfig.config.siteInfo.proxyOrigin,\n                    promptOptions: this.getPromptOptionsForDashboardConfiguration(serverConfig),\n                    welcomeNotification: {\n                        disable: !serverConfig.config.welcomeNotification.enable,\n                        title: serverConfig.config.welcomeNotification.title,\n                        message: serverConfig.config.welcomeNotification.message,\n                        url: serverConfig.config.welcomeNotification.url\n                    },\n                    notifyButton: {\n                        enable: serverConfig.config.staticPrompts.bell.enabled,\n                        displayPredicate: serverConfig.config.staticPrompts.bell.hideWhenSubscribed ?\n                            () => {\n                                return OneSignal.isPushNotificationsEnabled()\n                                    .then((isPushEnabled) => {\n                                    /* The user is subscribed, so we want to return \"false\" to hide the notify button */\n                                    return !isPushEnabled;\n                                });\n                            } :\n                            null,\n                        size: serverConfig.config.staticPrompts.bell.size,\n                        position: serverConfig.config.staticPrompts.bell.location,\n                        showCredit: false,\n                        offset: {\n                            bottom: `${serverConfig.config.staticPrompts.bell.offset.bottom}px`,\n                            left: `${serverConfig.config.staticPrompts.bell.offset.left}px`,\n                            right: `${serverConfig.config.staticPrompts.bell.offset.right}px`\n                        },\n                        colors: {\n                            'circle.background': serverConfig.config.staticPrompts.bell.color.main,\n                            'circle.foreground': serverConfig.config.staticPrompts.bell.color.accent,\n                            'badge.background': 'black',\n                            'badge.foreground': 'white',\n                            'badge.bordercolor': 'black',\n                            'pulse.color': serverConfig.config.staticPrompts.bell.color.accent,\n                            'dialog.button.background.hovering': serverConfig.config.staticPrompts.bell.color.main,\n                            'dialog.button.background.active': serverConfig.config.staticPrompts.bell.color.main,\n                            'dialog.button.background': serverConfig.config.staticPrompts.bell.color.main,\n                            'dialog.button.foreground': 'white',\n                        },\n                        text: {\n                            'tip.state.unsubscribed': serverConfig.config.staticPrompts.bell.tooltip.unsubscribed,\n                            'tip.state.subscribed': serverConfig.config.staticPrompts.bell.tooltip.subscribed,\n                            'tip.state.blocked': serverConfig.config.staticPrompts.bell.tooltip.blocked,\n                            'message.prenotify': serverConfig.config.staticPrompts.bell.tooltip.unsubscribed,\n                            'message.action.subscribing': serverConfig.config.staticPrompts.bell.message.subscribing,\n                            'message.action.subscribed': serverConfig.config.staticPrompts.bell.message.subscribing,\n                            'message.action.resubscribed': serverConfig.config.staticPrompts.bell.message.subscribing,\n                            'message.action.unsubscribed': serverConfig.config.staticPrompts.bell.message.unsubscribing,\n                            'dialog.main.title': serverConfig.config.staticPrompts.bell.dialog.main.title,\n                            'dialog.main.button.subscribe': serverConfig.config.staticPrompts.bell.dialog.main.subscribeButton,\n                            'dialog.main.button.unsubscribe': serverConfig.config.staticPrompts.bell.dialog.main.unsubscribeButton,\n                            'dialog.blocked.title': serverConfig.config.staticPrompts.bell.dialog.blocked.title,\n                            'dialog.blocked.message': serverConfig.config.staticPrompts.bell.dialog.blocked.message,\n                        },\n                    },\n                    persistNotification: serverConfig.config.notificationBehavior ?\n                        serverConfig.config.notificationBehavior.display.persist : undefined,\n                    webhooks: {\n                        cors: serverConfig.config.webhooks.corsEnable,\n                        'notification.displayed': serverConfig.config.webhooks.notificationDisplayedHook,\n                        'notification.clicked': serverConfig.config.webhooks.notificationClickedHook,\n                        'notification.dismissed': serverConfig.config.webhooks.notificationDismissedHook,\n                    },\n                    notificationClickHandlerMatch: serverConfig.config.notificationBehavior ?\n                        serverConfig.config.notificationBehavior.click.match : undefined,\n                    notificationClickHandlerAction: serverConfig.config.notificationBehavior ?\n                        serverConfig.config.notificationBehavior.click.action : undefined,\n                    allowLocalhostAsSecureOrigin: serverConfig.config.setupBehavior ?\n                        serverConfig.config.setupBehavior.allowLocalhostAsSecureOrigin : undefined,\n                    requiresUserPrivacyConsent: userConfig.requiresUserPrivacyConsent,\n                    outcomes: {\n                        direct: serverConfig.config.outcomes.direct,\n                        indirect: {\n                            enabled: serverConfig.config.outcomes.indirect.enabled,\n                            influencedTimePeriodMin: serverConfig.config.outcomes.indirect.notification_attribution.minutes_since_displayed,\n                            influencedNotificationsLimit: serverConfig.config.outcomes.indirect.notification_attribution.limit,\n                        },\n                        unattributed: serverConfig.config.outcomes.unattributed,\n                    }\n                };\n            case IntegrationConfigurationKind.JavaScript:\n                /*\n                  Ignores dashboard configuration and uses code-based configuration only.\n                  Except injecting some default values for prompts.\n                */\n                const config = Object.assign({}, userConfig, { promptOptions: this.injectDefaultsIntoPromptOptions(userConfig.promptOptions, serverConfig.config.staticPrompts, userConfig, isUsingSubscriptionWorkaround) }, {\n                    serviceWorkerParam: typeof OneSignal !== 'undefined' && !!OneSignal.SERVICE_WORKER_PARAM\n                        ? OneSignal.SERVICE_WORKER_PARAM\n                        : { scope: '/' },\n                    serviceWorkerPath: typeof OneSignal !== 'undefined' && !!OneSignal.SERVICE_WORKER_PATH\n                        ? OneSignal.SERVICE_WORKER_PATH\n                        : 'OneSignalSDKWorker.js',\n                    serviceWorkerUpdaterPath: typeof OneSignal !== 'undefined' && !!OneSignal.SERVICE_WORKER_UPDATER_PATH\n                        ? OneSignal.SERVICE_WORKER_UPDATER_PATH\n                        : 'OneSignalSDUpdaterKWorker.js',\n                    path: !!userConfig.path ? userConfig.path : '/'\n                }, { outcomes: {\n                        direct: serverConfig.config.outcomes.direct,\n                        indirect: {\n                            enabled: serverConfig.config.outcomes.indirect.enabled,\n                            influencedTimePeriodMin: serverConfig.config.outcomes.indirect.notification_attribution.minutes_since_displayed,\n                            influencedNotificationsLimit: serverConfig.config.outcomes.indirect.notification_attribution.limit,\n                        },\n                        unattributed: serverConfig.config.outcomes.unattributed,\n                    } });\n                if (userConfig.hasOwnProperty(\"autoResubscribe\")) {\n                    config.autoResubscribe = !!userConfig.autoResubscribe;\n                }\n                else if (userConfig.hasOwnProperty(\"autoRegister\")) {\n                    config.autoResubscribe = !!userConfig.autoRegister;\n                }\n                else {\n                    config.autoResubscribe = !!serverConfig.config.autoResubscribe;\n                }\n                return config;\n        }\n    }\n    /**\n     * Describes how to merge a dashboard-set subdomain with a/lack of user-supplied subdomain.\n     */\n    static getSubdomainForConfigIntegrationKind(configIntegrationKind, userConfig, serverConfig) {\n        const integrationCapabilities = this.getIntegrationCapabilities(configIntegrationKind);\n        const userValue = userConfig.subdomainName;\n        let serverValue = '';\n        switch (integrationCapabilities.configuration) {\n            case IntegrationConfigurationKind.Dashboard:\n                serverValue = serverConfig.config.siteInfo.proxyOriginEnabled ?\n                    serverConfig.config.siteInfo.proxyOrigin :\n                    undefined;\n                break;\n            case IntegrationConfigurationKind.JavaScript:\n                serverValue = serverConfig.config.subdomain;\n                break;\n        }\n        if (serverValue && !this.shouldUseServerConfigSubdomain(userValue, integrationCapabilities)) {\n            return undefined;\n        }\n        else {\n            return serverValue;\n        }\n    }\n    static shouldUseServerConfigSubdomain(userProvidedSubdomain, capabilities) {\n        switch (capabilities.configuration) {\n            case IntegrationConfigurationKind.Dashboard:\n                /*\n                  Dashboard config using the new web config editor always takes precedence.\n                 */\n                return true;\n            case IntegrationConfigurationKind.JavaScript:\n                /*\n                 * An HTTPS site may be using either a native push integration or a fallback\n                 * subdomain integration. Our SDK decides the integration based on whether\n                 * init option subdomainName appears and the site's protocol.\n                 *\n                 * To avoid having developers write JavaScript to customize the SDK,\n                 * configuration properties like subdomainName are downloaded on page start.\n                 *\n                 * New developers setting up web push can omit subdomainName, but existing\n                 * developers already having written code to configure OneSignal aren't\n                 * removing their code.\n                 *\n                 * When an HTTPS site is configured with a subdomain on the server-side, we do\n                 * not apply it even though we've downloaded this configuration unless the\n                 * user also declares it manually in their initialization code.\n                 */\n                switch (location.protocol) {\n                    case 'https:':\n                        return !!userProvidedSubdomain;\n                    case 'http:':\n                        return true;\n                    default:\n                        return false;\n                }\n        }\n    }\n}\n//# sourceMappingURL=ConfigHelper.js.map","import { deepCopy } from '../../src/utils';\nexport default class TagUtils {\n    static convertTagsApiToBooleans(tags) {\n        const convertedTags = {};\n        Object.keys(tags).forEach(key => {\n            convertedTags[key] = tags[key] === \"1\" ? true : false;\n        });\n        return convertedTags;\n    }\n    static convertTagsBooleansToApi(tags) {\n        const convertedTags = {};\n        Object.keys(tags).forEach(key => {\n            convertedTags[key] = tags[key] === true ? \"1\" : \"0\";\n        });\n        return convertedTags;\n    }\n    /**\n     * Used in determining what Tag/Category preferences changed in order\n     * to only update what is necessary\n     * @param  {TagsObject} localTags - tags from taggingContainer with values of type \"number\"\n     * @param  {TagsObject} remoteTags - remote player tags with values of type \"number\"\n     * @returns array of keys of corresponding different values (finds difference)\n     */\n    static getObjectDifference(localTags, remoteTags) {\n        const finalTags = {};\n        // Going off local tags since it's our categories. Trying to find only changed tags and returning those\n        // as a final object.\n        Object.keys(localTags).forEach(key => {\n            // only if user's tag value did not change, skip it\n            if (remoteTags[key] === localTags[key]) {\n                return;\n            }\n            finalTags[key] = localTags[key];\n        });\n        return finalTags;\n    }\n    static markAllTagsAsSpecified(categoryArray, checked) {\n        categoryArray.forEach(category => {\n            category.checked = checked;\n        });\n    }\n    static isTagObjectEmpty(tags) {\n        return Object.keys(tags).length === 0;\n    }\n    /**\n     * Uses configured categories and remote player tags to calculate which boxes should be checked\n     * @param  {TagCategory[]} categories\n     * @param  {TagsObjectWithBoolean} existingPlayerTags?\n     */\n    static getCheckedTagCategories(categories, existingPlayerTags) {\n        if (!existingPlayerTags) {\n            return categories;\n        }\n        const isExistingPlayerTagsEmpty = TagUtils.isTagObjectEmpty(existingPlayerTags);\n        if (isExistingPlayerTagsEmpty) {\n            const categoriesCopy = deepCopy(categories);\n            TagUtils.markAllTagsAsSpecified(categoriesCopy, true);\n            return categoriesCopy;\n        }\n        const categoriesCopy = deepCopy(categories);\n        return categoriesCopy.map(category => {\n            const existingTagValue = existingPlayerTags[category.tag];\n            category.checked = TagUtils.getCheckedStatusForTagValue(existingTagValue);\n            return category;\n        });\n    }\n    static getCheckedStatusForTagValue(tagValue) {\n        // If user does not have tag assigned to them, consider it selected\n        if (tagValue === undefined) {\n            return true;\n        }\n        return tagValue;\n    }\n    static limitCategoriesToMaxCount(categories, max) {\n        const categoriesCopy = deepCopy(categories);\n        categoriesCopy.tags = categories.tags.slice(0, max);\n        return categoriesCopy;\n    }\n}\n//# sourceMappingURL=TagUtils.js.map","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === \"object\") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n","import bowser from \"bowser\";\nimport Environment from \"../Environment\";\nimport { WorkerMessenger, WorkerMessengerCommand } from \"../libraries/WorkerMessenger\";\nimport SdkEnvironment from \"../managers/SdkEnvironment\";\nimport ContextSW from \"../models/ContextSW\";\nimport OneSignalApiBase from \"../OneSignalApiBase\";\nimport OneSignalApiSW from \"../OneSignalApiSW\";\nimport Database from \"../services/Database\";\nimport { RawPushSubscription } from \"../models/RawPushSubscription\";\nimport { SubscriptionStateKind } from \"../models/SubscriptionStateKind\";\nimport { PushDeviceRecord } from \"../models/PushDeviceRecord\";\nimport { SessionStatus } from \"../models/Session\";\nimport Log from \"../libraries/sw/Log\";\nimport { ConfigHelper } from \"../helpers/ConfigHelper\";\nimport { OneSignalUtils } from \"../utils/OneSignalUtils\";\nimport { Utils } from \"../context/shared/utils/Utils\";\nimport ServiceWorkerHelper from \"../helpers/ServiceWorkerHelper\";\nimport { cancelableTimeout } from \"../helpers/sw/CancelableTimeout\";\nimport { DeviceRecord } from '../models/DeviceRecord';\n/**\n * The main service worker script fetching and displaying notifications to users in the background even when the client\n * site is not running. The worker is registered via the navigator.serviceWorker.register() call after the user first\n * allows notification permissions, and is a pre-requisite to subscribing for push notifications.\n *\n * For HTTPS sites, the service worker is registered site-wide at the top-level scope. For HTTP sites, the service\n * worker is registered to the iFrame pointing to subdomain.onesignal.com.\n */\nexport class ServiceWorker {\n    /**\n     * An incrementing integer defined in package.json. Value doesn't matter as long as it's different from the\n     * previous version.\n     */\n    static get VERSION() {\n        return Environment.version();\n    }\n    /**\n     * Describes what context the JavaScript code is running in and whether we're running in local development mode.\n     */\n    static get environment() {\n        return Environment;\n    }\n    static get log() {\n        return Log;\n    }\n    /**\n     * An interface to the browser's IndexedDB.\n     */\n    static get database() {\n        return Database;\n    }\n    /**\n     * Describes the current browser name and version.\n     */\n    static get browser() {\n        return bowser;\n    }\n    /**\n     * Allows message passing between this service worker and its controlled clients, or webpages. Controlled\n     * clients include any HTTPS site page, or the nested iFrame pointing to OneSignal on any HTTP site. This allows\n     * events like notification dismissed, clicked, and displayed to be fired on the clients. It also allows the\n     * clients to communicate with the service worker to close all active notifications.\n     */\n    static get workerMessenger() {\n        if (!self.workerMessenger) {\n            self.workerMessenger = new WorkerMessenger(null);\n        }\n        return self.workerMessenger;\n    }\n    /**\n     * Service worker entry point.\n     */\n    static run() {\n        self.addEventListener('push', ServiceWorker.onPushReceived);\n        self.addEventListener('notificationclose', ServiceWorker.onNotificationClosed);\n        self.addEventListener('notificationclick', event => event.waitUntil(ServiceWorker.onNotificationClicked(event)));\n        self.addEventListener('install', ServiceWorker.onServiceWorkerInstalled);\n        self.addEventListener('activate', ServiceWorker.onServiceWorkerActivated);\n        self.addEventListener('pushsubscriptionchange', (event) => {\n            event.waitUntil(ServiceWorker.onPushSubscriptionChange(event));\n        });\n        self.addEventListener('message', (event) => {\n            const data = event.data;\n            if (!data || !data.command) {\n                return;\n            }\n            const payload = data.payload;\n            switch (data.command) {\n                case WorkerMessengerCommand.SessionUpsert:\n                    Log.debug(\"[Service Worker] Received SessionUpsert\", payload);\n                    ServiceWorker.debounceRefreshSession(event, payload);\n                    break;\n                case WorkerMessengerCommand.SessionDeactivate:\n                    Log.debug(\"[Service Worker] Received SessionDeactivate\", payload);\n                    ServiceWorker.debounceRefreshSession(event, payload);\n                    break;\n                default:\n                    return;\n            }\n        });\n        /*\n          According to\n          https://w3c.github.io/ServiceWorker/#run-service-worker-algorithm:\n    \n          \"user agents are encouraged to show a warning that the event listeners\n          must be added on the very first evaluation of the worker script.\"\n    \n          We have to register our event handler statically (not within an\n          asynchronous method) so that the browser can optimize not waking up the\n          service worker for events that aren't known for sure to be listened for.\n    \n          Also see: https://github.com/w3c/ServiceWorker/issues/1156\n        */\n        Log.debug('Setting up message listeners.');\n        // self.addEventListener('message') is statically added inside the listen() method\n        ServiceWorker.workerMessenger.listen();\n        // Install messaging event handlers for page <-> service worker communication\n        ServiceWorker.setupMessageListeners();\n    }\n    static async getAppId() {\n        if (self.location.search) {\n            const match = self.location.search.match(/appId=([0-9a-z-]+)&?/i);\n            // Successful regex matches are at position 1\n            if (match && match.length > 1) {\n                const appId = match[1];\n                return appId;\n            }\n        }\n        const { appId } = await Database.getAppConfig();\n        return appId;\n    }\n    static setupMessageListeners() {\n        ServiceWorker.workerMessenger.on(WorkerMessengerCommand.WorkerVersion, _ => {\n            Log.debug('[Service Worker] Received worker version message.');\n            ServiceWorker.workerMessenger.broadcast(WorkerMessengerCommand.WorkerVersion, Environment.version());\n        });\n        ServiceWorker.workerMessenger.on(WorkerMessengerCommand.Subscribe, async (appConfigBundle) => {\n            const appConfig = appConfigBundle;\n            Log.debug('[Service Worker] Received subscribe message.');\n            const context = new ContextSW(appConfig);\n            const rawSubscription = await context.subscriptionManager.subscribe(0 /* ResubscribeExisting */);\n            const subscription = await context.subscriptionManager.registerSubscription(rawSubscription);\n            ServiceWorker.workerMessenger.broadcast(WorkerMessengerCommand.Subscribe, subscription.serialize());\n        });\n        ServiceWorker.workerMessenger.on(WorkerMessengerCommand.SubscribeNew, async (appConfigBundle) => {\n            const appConfig = appConfigBundle;\n            Log.debug('[Service Worker] Received subscribe new message.');\n            const context = new ContextSW(appConfig);\n            const rawSubscription = await context.subscriptionManager.subscribe(1 /* SubscribeNew */);\n            const subscription = await context.subscriptionManager.registerSubscription(rawSubscription);\n            ServiceWorker.workerMessenger.broadcast(WorkerMessengerCommand.SubscribeNew, subscription.serialize());\n        });\n        ServiceWorker.workerMessenger.on(WorkerMessengerCommand.AmpSubscriptionState, async (_appConfigBundle) => {\n            Log.debug('[Service Worker] Received AMP subscription state message.');\n            const pushSubscription = await self.registration.pushManager.getSubscription();\n            if (!pushSubscription) {\n                ServiceWorker.workerMessenger.broadcast(WorkerMessengerCommand.AmpSubscriptionState, false);\n            }\n            else {\n                const permission = await self.registration.pushManager.permissionState(pushSubscription.options);\n                const { optedOut } = await Database.getSubscription();\n                const isSubscribed = !!pushSubscription && permission === \"granted\" && optedOut !== true;\n                ServiceWorker.workerMessenger.broadcast(WorkerMessengerCommand.AmpSubscriptionState, isSubscribed);\n            }\n        });\n        ServiceWorker.workerMessenger.on(WorkerMessengerCommand.AmpSubscribe, async () => {\n            Log.debug('[Service Worker] Received AMP subscribe message.');\n            const appId = await ServiceWorker.getAppId();\n            const appConfig = await ConfigHelper.getAppConfig({ appId }, OneSignalApiSW.downloadServerAppConfig);\n            const context = new ContextSW(appConfig);\n            const rawSubscription = await context.subscriptionManager.subscribe(0 /* ResubscribeExisting */);\n            const subscription = await context.subscriptionManager.registerSubscription(rawSubscription);\n            ServiceWorker.workerMessenger.broadcast(WorkerMessengerCommand.AmpSubscribe, subscription.deviceId);\n        });\n        ServiceWorker.workerMessenger.on(WorkerMessengerCommand.AmpUnsubscribe, async () => {\n            Log.debug('[Service Worker] Received AMP unsubscribe message.');\n            const appId = await ServiceWorker.getAppId();\n            const appConfig = await ConfigHelper.getAppConfig({ appId }, OneSignalApiSW.downloadServerAppConfig);\n            const context = new ContextSW(appConfig);\n            await context.subscriptionManager.unsubscribe(1 /* MarkUnsubscribed */);\n            ServiceWorker.workerMessenger.broadcast(WorkerMessengerCommand.AmpUnsubscribe, null);\n        });\n        ServiceWorker.workerMessenger.on(WorkerMessengerCommand.AreYouVisibleResponse, async (payload) => {\n            Log.debug('[Service Worker] Received response for AreYouVisible', payload);\n            if (!self.clientsStatus) {\n                return;\n            }\n            const timestamp = payload.timestamp;\n            if (self.clientsStatus.timestamp !== timestamp) {\n                return;\n            }\n            self.clientsStatus.receivedResponsesCount++;\n            if (payload.focused) {\n                self.clientsStatus.hasAnyActiveSessions = true;\n            }\n        });\n        ServiceWorker.workerMessenger.on(WorkerMessengerCommand.SetLogging, async (payload) => {\n            if (payload.shouldLog) {\n                self.shouldLog = true;\n            }\n            else {\n                self.shouldLog = undefined;\n            }\n        });\n    }\n    /**\n     * Occurs when a push message is received.\n     * This method handles the receipt of a push signal on all web browsers except Safari, which uses the OS to handle\n     * notifications.\n     */\n    static onPushReceived(event) {\n        Log.debug(`Called %conPushReceived(${JSON.stringify(event, null, 4)}):`, Utils.getConsoleStyle('code'), event);\n        event.waitUntil(ServiceWorker.parseOrFetchNotifications(event)\n            .then(async (notifications) => {\n            //Display push notifications in the order we received them\n            const notificationEventPromiseFns = [];\n            const notificationReceivedPromises = [];\n            const appId = await Database.get(\"Ids\", \"appId\");\n            for (let rawNotification of notifications) {\n                Log.debug('Raw Notification from OneSignal:', rawNotification);\n                let notification = ServiceWorker.buildStructuredNotificationObject(rawNotification);\n                const notificationReceived = {\n                    notificationId: notification.id,\n                    appId,\n                    url: notification.url,\n                    timestamp: new Date().getTime(),\n                };\n                notificationReceivedPromises.push(Database.put(\"NotificationReceived\", notificationReceived));\n                // TODO: decide what to do with all the notif received promises\n                // Probably should have it's own error handling but not blocking the rest of the execution?\n                // Never nest the following line in a callback from the point of entering from retrieveNotifications\n                notificationEventPromiseFns.push((notif => {\n                    return ServiceWorker.displayNotification(notif)\n                        .then(() => {\n                        return ServiceWorker.workerMessenger.broadcast(WorkerMessengerCommand.NotificationDisplayed, notif).catch(e => Log.error(e));\n                    })\n                        .then(() => ServiceWorker.executeWebhooks('notification.displayed', notif)\n                        .then(() => ServiceWorker.sendConfirmedDelivery(notif)).catch(e => Log.error(e)));\n                }).bind(null, notification));\n            }\n            return notificationEventPromiseFns.reduce((p, fn) => {\n                return p = p.then(fn);\n            }, Promise.resolve());\n        })\n            .catch(e => {\n            Log.debug('Failed to display a notification:', e);\n            if (ServiceWorker.UNSUBSCRIBED_FROM_NOTIFICATIONS) {\n                Log.debug('Because we have just unsubscribed from notifications, we will not show anything.');\n                return undefined;\n            }\n        }));\n    }\n    /**\n     * Makes a POST call to a specified URL to forward certain events.\n     * @param event The name of the webhook event. Affects the DB key pulled for settings and the final event the user\n     *              consumes.\n     * @param notification A JSON object containing notification details the user consumes.\n     * @returns {Promise}\n     */\n    static async executeWebhooks(event, notification) {\n        const webhookTargetUrl = await Database.get('Options', `webhooks.${event}`);\n        if (!webhookTargetUrl)\n            return null;\n        const { deviceId } = await Database.getSubscription();\n        const isServerCorsEnabled = await Database.get('Options', 'webhooks.cors');\n        // JSON.stringify() does not include undefined values\n        // Our response will not contain those fields here which have undefined values\n        const postData = {\n            event: event,\n            id: notification.id,\n            userId: deviceId,\n            action: notification.action,\n            buttons: notification.buttons,\n            heading: notification.heading,\n            content: notification.content,\n            url: notification.url,\n            icon: notification.icon,\n            data: notification.data\n        };\n        const fetchOptions = {\n            method: 'post',\n            mode: 'no-cors',\n            body: JSON.stringify(postData),\n        };\n        if (isServerCorsEnabled) {\n            fetchOptions.mode = 'cors';\n            fetchOptions.headers = {\n                'X-OneSignal-Event': event,\n                'Content-Type': 'application/json'\n            };\n        }\n        Log.debug(`Executing ${event} webhook ${isServerCorsEnabled ? 'with' : 'without'} CORS %cPOST ${webhookTargetUrl}`, Utils.getConsoleStyle('code'), ':', postData);\n        return await fetch(webhookTargetUrl, fetchOptions);\n    }\n    /**\n     * Makes a PUT call to log the delivery of the notification\n     * @param notification A JSON object containing notification details.\n     * @returns {Promise}\n     */\n    static async sendConfirmedDelivery(notification) {\n        if (!notification)\n            return null;\n        // Received receipts enabled?\n        if (notification.rr !== \"y\")\n            return null;\n        const appId = await ServiceWorker.getAppId();\n        const { deviceId } = await Database.getSubscription();\n        // app and notification ids are required, decided to exclude deviceId from required params\n        // In rare case we don't have it we can still report as confirmed to backend to increment count\n        const hasRequiredParams = !!(appId && notification.id);\n        if (!hasRequiredParams) {\n            return null;\n        }\n        // JSON.stringify() does not include undefined values\n        // Our response will not contain those fields here which have undefined values\n        const postData = {\n            player_id: deviceId,\n            app_id: appId\n        };\n        Log.debug(`Called %csendConfirmedDelivery(${JSON.stringify(notification, null, 4)})`, Utils.getConsoleStyle('code'));\n        return await OneSignalApiBase.put(`notifications/${notification.id}/report_received`, postData);\n    }\n    /**\n     * Gets an array of active window clients along with whether each window client is the HTTP site's iFrame or an\n     * HTTPS site page.\n     * An active window client is a browser tab that is controlled by the service worker.\n     * Technically, this list should only ever contain clients that are iFrames, or clients that are HTTPS site pages,\n     * and not both. This doesn't really matter though.\n     * @returns {Promise}\n     */\n    static async getActiveClients() {\n        const windowClients = await self.clients.matchAll({ type: 'window', includeUncontrolled: true });\n        const activeClients = [];\n        for (const client of windowClients) {\n            const windowClient = client;\n            windowClient.isSubdomainIframe = false;\n            // Test if this window client is the HTTP subdomain iFrame pointing to subdomain.onesignal.com\n            if (client.frameType && client.frameType === 'nested') {\n                // Subdomain iFrames point to 'https://subdomain.onesignal.com...'\n                if (!Utils.contains(client.url, '.os.tc') &&\n                    !Utils.contains(client.url, '.onesignal.com')) {\n                    continue;\n                }\n                // Indicates this window client is an HTTP subdomain iFrame\n                windowClient.isSubdomainIframe = true;\n            }\n            activeClients.push(windowClient);\n        }\n        return activeClients;\n    }\n    static async updateSessionBasedOnHasActive(event, hasAnyActiveSessions, options) {\n        if (hasAnyActiveSessions) {\n            await ServiceWorkerHelper.upsertSession(options.sessionThreshold, options.enableSessionDuration, options.deviceRecord, options.deviceId, options.sessionOrigin, options.outcomesConfig);\n        }\n        else {\n            const cancelableFinalize = await ServiceWorkerHelper.deactivateSession(options.sessionThreshold, options.enableSessionDuration, options.outcomesConfig);\n            if (cancelableFinalize) {\n                self.cancel = cancelableFinalize.cancel;\n                event.waitUntil(cancelableFinalize.promise);\n            }\n        }\n    }\n    static async refreshSession(event, options) {\n        Log.debug(\"[Service Worker] refreshSession\");\n        /**\n         * if https -> getActiveClients -> check for the first focused\n         * unfortunately, not enough for safari, it always returns false for focused state of a client\n         * have to workaround it with messaging to the client.\n         *\n         * if http, also have to workaround with messaging:\n         *   SW to iframe -> iframe to page -> page to iframe -> iframe to SW\n         */\n        if (options.isHttps) {\n            const windowClients = await self.clients.matchAll({ type: \"window\", includeUncontrolled: false });\n            if (options.isSafari) {\n                await ServiceWorker.checkIfAnyClientsFocusedAndUpdateSession(event, windowClients, options);\n            }\n            else {\n                const hasAnyActiveSessions = windowClients.some(w => w.focused);\n                Log.debug(\"[Service Worker] isHttps hasAnyActiveSessions\", hasAnyActiveSessions);\n                await ServiceWorker.updateSessionBasedOnHasActive(event, hasAnyActiveSessions, options);\n            }\n            return;\n        }\n        else {\n            const osClients = await ServiceWorker.getActiveClients();\n            await ServiceWorker.checkIfAnyClientsFocusedAndUpdateSession(event, osClients, options);\n        }\n    }\n    static async checkIfAnyClientsFocusedAndUpdateSession(event, windowClients, sessionInfo) {\n        const timestamp = new Date().getTime();\n        self.clientsStatus = {\n            timestamp,\n            sentRequestsCount: 0,\n            receivedResponsesCount: 0,\n            hasAnyActiveSessions: false,\n        };\n        const payload = { timestamp };\n        windowClients.forEach(c => {\n            if (self.clientsStatus) {\n                // keeping track of number of sent requests mostly for debugging purposes\n                self.clientsStatus.sentRequestsCount++;\n            }\n            c.postMessage({ command: WorkerMessengerCommand.AreYouVisible, payload });\n        });\n        const updateOnHasActive = async () => {\n            if (!self.clientsStatus) {\n                return;\n            }\n            if (self.clientsStatus.timestamp !== timestamp) {\n                return;\n            }\n            Log.debug(\"updateSessionBasedOnHasActive\", self.clientsStatus);\n            await ServiceWorker.updateSessionBasedOnHasActive(event, self.clientsStatus.hasAnyActiveSessions, sessionInfo);\n            self.clientsStatus = undefined;\n        };\n        const getClientStatusesCancelable = cancelableTimeout(updateOnHasActive, 0.5);\n        self.cancel = getClientStatusesCancelable.cancel;\n        event.waitUntil(getClientStatusesCancelable.promise);\n    }\n    static debounceRefreshSession(event, options) {\n        Log.debug(\"[Service Worker] debounceRefreshSession\", options);\n        if (self.cancel) {\n            self.cancel();\n            self.cancel = undefined;\n        }\n        const executeRefreshSession = async () => {\n            await ServiceWorker.refreshSession(event, options);\n        };\n        const cancelableRefreshSession = cancelableTimeout(executeRefreshSession, 1);\n        self.cancel = cancelableRefreshSession.cancel;\n        event.waitUntil(cancelableRefreshSession.promise);\n    }\n    /**\n     * Constructs a structured notification object from the raw notification fetched from OneSignal's server. This\n     * object is passed around from event to event, and is also returned to the host page for notification event details.\n     * Constructed in onPushReceived, and passed along to other event handlers.\n     * @param rawNotification The raw notification JSON returned from OneSignal's server.\n     */\n    static buildStructuredNotificationObject(rawNotification) {\n        let notification = {\n            id: rawNotification.custom.i,\n            heading: rawNotification.title,\n            content: rawNotification.alert,\n            data: rawNotification.custom.a,\n            url: rawNotification.custom.u,\n            rr: rawNotification.custom.rr,\n            icon: rawNotification.icon,\n            image: rawNotification.image,\n            tag: rawNotification.tag,\n            badge: rawNotification.badge,\n            vibrate: rawNotification.vibrate\n        };\n        // Add action buttons\n        if (rawNotification.o) {\n            notification.buttons = [];\n            for (let rawButton of rawNotification.o) {\n                notification.buttons.push({\n                    action: rawButton.i,\n                    title: rawButton.n,\n                    icon: rawButton.p,\n                    url: rawButton.u\n                });\n            }\n        }\n        return Utils.trimUndefined(notification);\n    }\n    /**\n     * Given an image URL, returns a proxied HTTPS image using the https://images.weserv.nl service.\n     * For a null image, returns null so that no icon is displayed.\n     * If the image protocol is HTTPS, or origin contains localhost or starts with 192.168.*.*, we do not proxy the image.\n     * @param imageUrl An HTTP or HTTPS image URL.\n     */\n    static ensureImageResourceHttps(imageUrl) {\n        if (imageUrl) {\n            try {\n                let parsedImageUrl = new URL(imageUrl);\n                if (parsedImageUrl.hostname === 'localhost' ||\n                    parsedImageUrl.hostname.indexOf('192.168') !== -1 ||\n                    parsedImageUrl.hostname === '127.0.0.1' ||\n                    parsedImageUrl.protocol === 'https:') {\n                    return imageUrl;\n                }\n                if (parsedImageUrl.hostname === 'i0.wp.com' ||\n                    parsedImageUrl.hostname === 'i1.wp.com' ||\n                    parsedImageUrl.hostname === 'i2.wp.com' ||\n                    parsedImageUrl.hostname === 'i3.wp.com') {\n                    /* Their site already uses Jetpack, just make sure Jetpack is HTTPS */\n                    return `https://${parsedImageUrl.hostname}${parsedImageUrl.pathname}`;\n                }\n                /* HTTPS origin hosts can be used by prefixing the hostname with ssl: */\n                let replacedImageUrl = parsedImageUrl.host + parsedImageUrl.pathname;\n                return `https://i0.wp.com/${replacedImageUrl}`;\n            }\n            catch (e) { }\n        }\n        else\n            return null;\n    }\n    /**\n     * Given a structured notification object, HTTPS-ifies the notification icons and action button icons, if they exist.\n     */\n    static ensureNotificationResourcesHttps(notification) {\n        if (notification) {\n            if (notification.icon) {\n                notification.icon = ServiceWorker.ensureImageResourceHttps(notification.icon);\n            }\n            if (notification.image) {\n                notification.image = ServiceWorker.ensureImageResourceHttps(notification.image);\n            }\n            if (notification.buttons && notification.buttons.length > 0) {\n                for (let button of notification.buttons) {\n                    if (button.icon) {\n                        button.icon = ServiceWorker.ensureImageResourceHttps(button.icon);\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Actually displays a visible notification to the user.\n     * Any event needing to display a notification calls this so that all the display options can be centralized here.\n     * @param notification A structured notification object.\n     */\n    static async displayNotification(notification, overrides) {\n        Log.debug(`Called %cdisplayNotification(${JSON.stringify(notification, null, 4)}):`, Utils.getConsoleStyle('code'), notification);\n        // Use the default title if one isn't provided\n        const defaultTitle = await ServiceWorker._getTitle();\n        // Use the default icon if one isn't provided\n        const defaultIcon = await Database.get('Options', 'defaultIcon');\n        // Get option of whether we should leave notification displaying indefinitely\n        const persistNotification = await Database.get('Options', 'persistNotification');\n        // Get app ID for tag value\n        const appId = await ServiceWorker.getAppId();\n        notification.heading = notification.heading ? notification.heading : defaultTitle;\n        notification.icon = notification.icon ? notification.icon : (defaultIcon ? defaultIcon : undefined);\n        const extra = {};\n        extra.tag = notification.tag || appId;\n        extra.persistNotification = persistNotification !== false;\n        // Allow overriding some values\n        if (!overrides)\n            overrides = {};\n        notification = Object.assign({}, notification, overrides);\n        ServiceWorker.ensureNotificationResourcesHttps(notification);\n        let notificationOptions = {\n            body: notification.content,\n            icon: notification.icon,\n            /*\n             On Chrome 56, a large image can be displayed:\n             https://bugs.chromium.org/p/chromium/issues/detail?id=614456\n             */\n            image: notification.image,\n            /*\n             On Chrome 44+, use this property to store extra information which\n             you can read back when the notification gets invoked from a\n             notification click or dismissed event. We serialize the\n             notification in the 'data' field and read it back in other events.\n             See:\n             https://developers.google.com/web/updates/2015/05/notifying-you-of-changes-to-notifications?hl=en\n             */\n            data: notification,\n            /*\n             On Chrome 48+, action buttons show below the message body of the\n             notification. Clicking either button takes the user to a link. See:\n             https://developers.google.com/web/updates/2016/01/notification-actions\n             */\n            actions: notification.buttons,\n            /*\n             Tags are any string value that groups notifications together. Two\n             or notifications sharing a tag replace each other.\n             */\n            tag: extra.tag,\n            /*\n             On Chrome 47+ (desktop), notifications will be dismissed after 20\n             seconds unless requireInteraction is set to true. See:\n             https://developers.google.com/web/updates/2015/10/notification-requireInteractiom\n             */\n            requireInteraction: extra.persistNotification,\n            /*\n             On Chrome 50+, by default notifications replacing\n             identically-tagged notifications no longer vibrate/signal the user\n             that a new notification has come in. This flag allows subsequent\n             notifications to re-alert the user. See:\n             https://developers.google.com/web/updates/2016/03/notifications\n             */\n            renotify: true,\n            /*\n             On Chrome 53+, returns the URL of the image used to represent the\n             notification when there is not enough space to display the\n             notification itself.\n      \n             The URL of an image to represent the notification when there is not\n             enough space to display the notification itself such as, for\n             example, the Android Notification Bar. On Android devices, the\n             badge should accommodate devices up to 4x resolution, about 96 by\n             96 px, and the image will be automatically masked.\n             */\n            badge: notification.badge,\n            /*\n            A vibration pattern to run with the display of the notification. A\n            vibration pattern can be an array with as few as one member. The\n            values are times in milliseconds where the even indices (0, 2, 4,\n            etc.) indicate how long to vibrate and the odd indices indicate how\n            long to pause. For example [300, 100, 400] would vibrate 300ms,\n            pause 100ms, then vibrate 400ms.\n             */\n            vibrate: notification.vibrate\n        };\n        notificationOptions = ServiceWorker.fixPlatformSpecificDisplayIssues(notificationOptions);\n        return self.registration.showNotification(notification.heading, notificationOptions);\n    }\n    /**\n     * Fixes display issue with some notification options causing the notification to never show!\n     * This happens when setting requireInteraction = true on the following platforms;\n     *   * macOS 10.15+ - Chrome based browsers\n     *      - https://bugs.chromium.org/p/chromium/issues/detail?id=1007418\n     *   * macOS 10.14+ - Opera\n     *      - https://forums.opera.com/topic/31334/push-notifications-with-requireinteraction-true-do-not-display-on-macos\n     * @param notificationOptions - Value passed to ServiceWorkerRegistration.prototype.showNotification\n     */\n    static fixPlatformSpecificDisplayIssues(notificationOptions) {\n        const clone = Object.assign({}, notificationOptions);\n        const browser = OneSignalUtils.redetectBrowserUserAgent();\n        if (browser.chrome && browser.mac && Utils.isVersionAtLeast(browser.osversion, 10.15)) {\n            clone.requireInteraction = false;\n        }\n        else if (browser.opera && browser.mac && Utils.isVersionAtLeast(browser.osversion, 10.14)) {\n            clone.requireInteraction = false;\n        }\n        return clone;\n    }\n    /**\n     * Returns false if the given URL matches a few special URLs designed to skip opening a URL when clicking a\n     * notification. Otherwise returns true and the link will be opened.\n     * @param url\n       */\n    static shouldOpenNotificationUrl(url) {\n        return (url !== 'javascript:void(0);' &&\n            url !== 'do_not_open' &&\n            !Utils.contains(url, '_osp=do_not_open'));\n    }\n    /**\n     * Occurs when a notification is dismissed by the user (clicking the 'X') or all notifications are cleared.\n     * Supported on: Chrome 50+ only\n     */\n    static onNotificationClosed(event) {\n        Log.debug(`Called %conNotificationClosed(${JSON.stringify(event, null, 4)}):`, Utils.getConsoleStyle('code'), event);\n        let notification = event.notification.data;\n        ServiceWorker.workerMessenger.broadcast(WorkerMessengerCommand.NotificationDismissed, notification).catch(e => Log.error(e));\n        event.waitUntil(ServiceWorker.executeWebhooks('notification.dismissed', notification));\n    }\n    /**\n     * After clicking a notification, determines the URL to open based on whether an action button was clicked or the\n     * notification body was clicked.\n     */\n    static async getNotificationUrlToOpen(notification) {\n        // Defaults to the URL the service worker was registered\n        // TODO: This should be fixed for HTTP sites\n        let launchUrl = self.registration.scope;\n        // Use the user-provided default URL if one exists\n        const { defaultNotificationUrl: dbDefaultNotificationUrl } = await Database.getAppState();\n        if (dbDefaultNotificationUrl)\n            launchUrl = dbDefaultNotificationUrl;\n        // If the user clicked an action button, use the URL provided by the action button\n        // Unless the action button URL is null\n        if (notification.action) {\n            // Find the URL tied to the action button that was clicked\n            for (let button of notification.buttons) {\n                if (button.action === notification.action &&\n                    button.url &&\n                    button.url !== '') {\n                    launchUrl = button.url;\n                }\n            }\n        }\n        else if (notification.url &&\n            notification.url !== '') {\n            // The user clicked the notification body instead of an action button\n            launchUrl = notification.url;\n        }\n        return launchUrl;\n    }\n    /**\n     * Occurs when the notification's body or action buttons are clicked. Does not occur if the notification is\n     * dismissed by clicking the 'X' icon. See the notification close event for the dismissal event.\n     */\n    static async onNotificationClicked(event) {\n        Log.debug(`Called %conNotificationClicked(${JSON.stringify(event, null, 4)}):`, Utils.getConsoleStyle('code'), event);\n        // Close the notification first here, before we do anything that might fail\n        event.notification.close();\n        const notificationData = event.notification.data;\n        // Chrome 48+: Get the action button that was clicked\n        if (event.action)\n            notificationData.action = event.action;\n        let notificationClickHandlerMatch = 'exact';\n        let notificationClickHandlerAction = 'navigate';\n        const matchPreference = await Database.get('Options', 'notificationClickHandlerMatch');\n        if (matchPreference)\n            notificationClickHandlerMatch = matchPreference;\n        const actionPreference = await this.database.get('Options', 'notificationClickHandlerAction');\n        if (actionPreference)\n            notificationClickHandlerAction = actionPreference;\n        const launchUrl = await ServiceWorker.getNotificationUrlToOpen(notificationData);\n        const notificationOpensLink = ServiceWorker.shouldOpenNotificationUrl(launchUrl);\n        const appId = await Database.get(\"Ids\", \"appId\");\n        const deviceType = DeviceRecord.prototype.getDeliveryPlatform();\n        let saveNotificationClickedPromise;\n        const notificationClicked = {\n            notificationId: notificationData.id,\n            appId,\n            url: launchUrl,\n            timestamp: new Date().getTime(),\n        };\n        Log.info(\"NotificationClicked\", notificationClicked);\n        saveNotificationClickedPromise = (async (notificationClicked) => {\n            try {\n                const existingSession = await Database.getCurrentSession();\n                if (existingSession && existingSession.status === SessionStatus.Active) {\n                    return;\n                }\n                await Database.put(\"NotificationClicked\", notificationClicked);\n                // upgrade existing session to be directly attributed to the notif\n                // if it results in re-focusing the site\n                if (existingSession) {\n                    existingSession.notificationId = notificationClicked.notificationId;\n                    await Database.upsertSession(existingSession);\n                }\n            }\n            catch (e) {\n                Log.error(\"Failed to save clicked notification.\", e);\n            }\n        })(notificationClicked);\n        // Start making REST API requests BEFORE self.clients.openWindow is called.\n        // It will cause the service worker to stop on Chrome for Android when site is added to the home screen.\n        const { deviceId } = await Database.getSubscription();\n        const convertedAPIRequests = ServiceWorker.sendConvertedAPIRequests(appId, deviceId, notificationData, deviceType);\n        /*\n         Check if we can focus on an existing tab instead of opening a new url.\n         If an existing tab with exactly the same URL already exists, then this existing tab is focused instead of\n         an identical new tab being created. With a special setting, any existing tab matching the origin will\n         be focused instead of an identical new tab being created.\n         */\n        const activeClients = await ServiceWorker.getActiveClients();\n        let doNotOpenLink = false;\n        for (const client of activeClients) {\n            let clientUrl = client.url;\n            if (client.isSubdomainIframe) {\n                const lastKnownHostUrl = await Database.get('Options', 'lastKnownHostUrl');\n                // TODO: clientUrl is being overwritten by defaultUrl and lastKnownHostUrl.\n                //       Should only use clientUrl if it is not null.\n                //       Also need to decide which to use over the other.\n                clientUrl = lastKnownHostUrl;\n                if (!lastKnownHostUrl) {\n                    clientUrl = await Database.get('Options', 'defaultUrl');\n                }\n            }\n            let clientOrigin = '';\n            try {\n                clientOrigin = new URL(clientUrl).origin;\n            }\n            catch (e) {\n                Log.error(`Failed to get the HTTP site's actual origin:`, e);\n            }\n            let launchOrigin = null;\n            try {\n                // Check if the launchUrl is valid; it can be null\n                launchOrigin = new URL(launchUrl).origin;\n            }\n            catch (e) { }\n            if ((notificationClickHandlerMatch === 'exact' && clientUrl === launchUrl) ||\n                (notificationClickHandlerMatch === 'origin' && clientOrigin === launchOrigin)) {\n                if ((client['isSubdomainIframe'] && clientUrl === launchUrl) ||\n                    (!client['isSubdomainIframe'] && client.url === launchUrl) ||\n                    (notificationClickHandlerAction === 'focus' && clientOrigin === launchOrigin)) {\n                    ServiceWorker.workerMessenger.unicast(WorkerMessengerCommand.NotificationClicked, notificationData, client);\n                    try {\n                        if (client instanceof WindowClient)\n                            await client.focus();\n                    }\n                    catch (e) {\n                        Log.error(\"Failed to focus:\", client, e);\n                    }\n                }\n                else {\n                    /*\n                    We must focus first; once the client navigates away, it may not be to a service worker-controlled page, and\n                    the client ID may change, making it unable to focus.\n          \n                    client.navigate() is available on Chrome 49+ and Firefox 50+.\n                     */\n                    if (client['isSubdomainIframe']) {\n                        try {\n                            Log.debug('Client is subdomain iFrame. Attempting to focus() client.');\n                            if (client instanceof WindowClient)\n                                await client.focus();\n                        }\n                        catch (e) {\n                            Log.error(\"Failed to focus:\", client, e);\n                        }\n                        if (notificationOpensLink) {\n                            Log.debug(`Redirecting HTTP site to ${launchUrl}.`);\n                            await Database.put(\"NotificationOpened\", { url: launchUrl, data: notificationData, timestamp: Date.now() });\n                            ServiceWorker.workerMessenger.unicast(WorkerMessengerCommand.RedirectPage, launchUrl, client);\n                        }\n                        else {\n                            Log.debug('Not navigating because link is special.');\n                        }\n                    }\n                    else if (client instanceof WindowClient && client.navigate) {\n                        try {\n                            Log.debug('Client is standard HTTPS site. Attempting to focus() client.');\n                            if (client instanceof WindowClient)\n                                await client.focus();\n                        }\n                        catch (e) {\n                            Log.error(\"Failed to focus:\", client, e);\n                        }\n                        try {\n                            if (notificationOpensLink) {\n                                Log.debug(`Redirecting HTTPS site to (${launchUrl}).`);\n                                await Database.put(\"NotificationOpened\", { url: launchUrl, data: notificationData, timestamp: Date.now() });\n                                await client.navigate(launchUrl);\n                            }\n                            else {\n                                Log.debug('Not navigating because link is special.');\n                            }\n                        }\n                        catch (e) {\n                            Log.error(\"Failed to navigate:\", client, launchUrl, e);\n                        }\n                    }\n                    else {\n                        // If client.navigate() isn't available, we have no other option but to open a new tab to the URL.\n                        await Database.put(\"NotificationOpened\", { url: launchUrl, data: notificationData, timestamp: Date.now() });\n                        await ServiceWorker.openUrl(launchUrl);\n                    }\n                }\n                doNotOpenLink = true;\n                break;\n            }\n        }\n        if (notificationOpensLink && !doNotOpenLink) {\n            await Database.put(\"NotificationOpened\", { url: launchUrl, data: notificationData, timestamp: Date.now() });\n            await ServiceWorker.openUrl(launchUrl);\n        }\n        if (saveNotificationClickedPromise) {\n            await saveNotificationClickedPromise;\n        }\n        return await convertedAPIRequests;\n    }\n    /**\n     * Makes network calls for the notification open event to;\n     *    1. OneSignal.com to increase the notification open count.\n     *    2. A website developer defined webhook URL, if set.\n     */\n    static async sendConvertedAPIRequests(appId, deviceId, notificationData, deviceType) {\n        if (!notificationData.id) {\n            console.error(\"No notification id, skipping networks calls to report open!\");\n            return;\n        }\n        let onesignalRestPromise;\n        if (appId) {\n            onesignalRestPromise = OneSignalApiBase.put(`notifications/${notificationData.id}`, {\n                app_id: appId,\n                player_id: deviceId,\n                opened: true,\n                device_type: deviceType\n            });\n        }\n        else\n            console.error(\"No app Id, skipping OneSignal API call for notification open!\");\n        await ServiceWorker.executeWebhooks('notification.clicked', notificationData);\n        if (onesignalRestPromise)\n            await onesignalRestPromise;\n    }\n    /**\n     * Attempts to open the given url in a new browser tab. Called when a notification is clicked.\n     * @param url May not be well-formed.\n     */\n    static async openUrl(url) {\n        Log.debug('Opening notification URL:', url);\n        try {\n            return await self.clients.openWindow(url);\n        }\n        catch (e) {\n            Log.warn(`Failed to open the URL '${url}':`, e);\n            return null;\n        }\n    }\n    static onServiceWorkerInstalled(event) {\n        Log.info(\"Installing service worker...\");\n        // At this point, the old service worker is still in control\n        event.waitUntil(self.skipWaiting());\n    }\n    /*\n     1/11/16: Enable the waiting service worker to immediately become the active service worker: https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope/skipWaiting\n     */\n    static onServiceWorkerActivated(event) {\n        // The old service worker is gone now\n        Log.info(`%cOneSignal Service Worker activated (version ${Environment.version()}, ${SdkEnvironment.getWindowEnv().toString()} environment).`, Utils.getConsoleStyle('bold'));\n        event.waitUntil(self.clients.claim());\n    }\n    static async onPushSubscriptionChange(event) {\n        Log.debug(`Called %conPushSubscriptionChange(${JSON.stringify(event, null, 4)}):`, Utils.getConsoleStyle('code'), event);\n        const appId = await ServiceWorker.getAppId();\n        if (!appId) {\n            // Without an app ID, we can't make any calls\n            return;\n        }\n        const appConfig = await ConfigHelper.getAppConfig({ appId }, OneSignalApiSW.downloadServerAppConfig);\n        if (!appConfig) {\n            // Without a valid app config (e.g. deleted app), we can't make any calls\n            return;\n        }\n        const context = new ContextSW(appConfig);\n        // Get our current device ID\n        let deviceIdExists;\n        {\n            let { deviceId } = await Database.getSubscription();\n            deviceIdExists = !!deviceId;\n            if (!deviceIdExists && event.oldSubscription) {\n                // We don't have the device ID stored, but we can look it up from our old subscription\n                deviceId = await OneSignalApiSW.getUserIdFromSubscriptionIdentifier(appId, PushDeviceRecord.prototype.getDeliveryPlatform(), event.oldSubscription.endpoint);\n                // Store the device ID, so it can be looked up when subscribing\n                const subscription = await Database.getSubscription();\n                subscription.deviceId = deviceId;\n                await Database.setSubscription(subscription);\n            }\n            deviceIdExists = !!deviceId;\n        }\n        // Get our new push subscription\n        let rawPushSubscription;\n        // Set it initially by the provided new push subscription\n        const providedNewSubscription = event.newSubscription;\n        if (providedNewSubscription) {\n            rawPushSubscription = RawPushSubscription.setFromW3cSubscription(providedNewSubscription);\n        }\n        else {\n            // Otherwise set our push registration by resubscribing\n            try {\n                rawPushSubscription = await context.subscriptionManager.subscribe(1 /* SubscribeNew */);\n            }\n            catch (e) {\n                // Let rawPushSubscription be null\n            }\n        }\n        const hasNewSubscription = !!rawPushSubscription;\n        if (!deviceIdExists && !hasNewSubscription) {\n            await Database.remove('Ids', 'userId');\n            await Database.remove('Ids', 'registrationId');\n        }\n        else {\n            /*\n              Determine subscription state we should set new record to.\n      \n              If the permission is revoked, we should set the subscription state to permission revoked.\n             */\n            let subscriptionState = null;\n            const pushPermission = Notification.permission;\n            if (pushPermission !== \"granted\") {\n                subscriptionState = SubscriptionStateKind.PermissionRevoked;\n            }\n            else if (!rawPushSubscription) {\n                /*\n                  If it's not a permission revoked issue, the subscription expired or was revoked by the\n                  push server.\n                 */\n                subscriptionState = SubscriptionStateKind.PushSubscriptionRevoked;\n            }\n            // rawPushSubscription may be null if no push subscription was retrieved\n            await context.subscriptionManager.registerSubscription(rawPushSubscription, subscriptionState);\n        }\n    }\n    /**\n     * Returns a promise that is fulfilled with either the default title from the database (first priority) or the page title from the database (alternate result).\n     */\n    static _getTitle() {\n        return new Promise(resolve => {\n            Promise.all([Database.get('Options', 'defaultTitle'), Database.get('Options', 'pageTitle')])\n                .then(([defaultTitle, pageTitle]) => {\n                if (defaultTitle !== null) {\n                    resolve(defaultTitle);\n                }\n                else if (pageTitle != null) {\n                    resolve(pageTitle);\n                }\n                else {\n                    resolve('');\n                }\n            });\n        });\n    }\n    /**\n     * Returns an array of raw notification objects, read from the event.data.payload property\n     * @param event\n     * @returns An array of notifications. The new web push protocol will only ever contain one notification, however\n     * an array is returned for backwards compatibility with the rest of the service worker plumbing.\n       */\n    static parseOrFetchNotifications(event) {\n        if (!event || !event.data) {\n            return Promise.reject(\"Missing event.data on push payload!\");\n        }\n        const isValidPayload = ServiceWorker.isValidPushPayload(event.data);\n        if (isValidPayload) {\n            Log.debug(\"Received a valid encrypted push payload.\");\n            return Promise.resolve([event.data.json()]);\n        }\n        /*\n         We received a push message payload from another service provider or a malformed\n         payload. The last received notification will be displayed.\n        */\n        return Promise.reject(`Unexpected push message payload received: ${event.data}`);\n    }\n    /**\n     * Returns true if the raw data payload is a OneSignal push message in the format of the new web push protocol.\n     * Otherwise returns false.\n     * @param rawData The raw PushMessageData from the push event's event.data, not already parsed to JSON.\n     */\n    static isValidPushPayload(rawData) {\n        try {\n            const payload = rawData.json();\n            if (payload &&\n                payload.custom &&\n                payload.custom.i &&\n                OneSignalUtils.isValidUuid(payload.custom.i)) {\n                return true;\n            }\n            else {\n                Log.debug('isValidPushPayload: Valid JSON but missing notification UUID:', payload);\n                return false;\n            }\n        }\n        catch (e) {\n            Log.debug('isValidPushPayload: Parsing to JSON failed with:', e);\n            return false;\n        }\n    }\n}\n// Expose this class to the global scope\nif (typeof self === \"undefined\" &&\n    typeof global !== \"undefined\") {\n    global.OneSignalWorker = ServiceWorker;\n}\nelse {\n    self.OneSignalWorker = ServiceWorker;\n}\n// Run our main file\nif (typeof self !== \"undefined\") {\n    ServiceWorker.run();\n}\n//# sourceMappingURL=ServiceWorker.js.map","module.exports = function() {\r\n\tthrow new Error(\"define cannot be used indirect\");\r\n};\r\n","/**\n * New clients will only be including this entry file, which will result in a reduced service worker size.\n */\nimport { ServiceWorker } from '../../src/service-worker/ServiceWorker';\nself.OneSignal = ServiceWorker;\n//# sourceMappingURL=worker.js.map"],"sourceRoot":""}